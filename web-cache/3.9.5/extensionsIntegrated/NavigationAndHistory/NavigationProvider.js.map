{"version":3,"sources":["extensionsIntegrated/NavigationAndHistory/NavigationProvider.js"],"names":["define","require","exports","module","Strings","MainViewManager","DocumentManager","EditorManager","ProjectManager","CommandManager","Commands","Menus","KeyBindingManager","FileSystem","Metrics","KeyboardPrefs","JSON","parse","NAVIGATION_JUMP_BACK","NAVIGATION_JUMP_FWD","_NAVIGATION_RESET_FOR_TESTS","MAX_NAV_FRAMES_COUNT","$navback","$navForward","$searchNav","$newProject","$showInTree","jumpBackwardStack","jumpForwardStack","jumpInProgress","commandJumpBack","commandJumpFwd","_hasNavBackFrames","length","_hasNavForwardFrames","_setEnableBackNavButton","enabled","removeClass","addClass","_setEnableForwardNavButton","_validateNavigationCmds","setEnabled","_validateFrame","entry","deferred","$","Deferred","fileEntry","getFileForPath","filePath","indexInWS","inMem","findInWorkingSet","paneId","reject","resolve","exists","err","nonEditorView","_hash","_validateMarkers","promise","NavigationFrame","editor","selectionObj","fileWithoutEditor","fileWithoutEditorPaneID","this","cm","_codeMirror","_paneId","uId","Date","getTime","console","error","fileToUse","document","file","_path","constructor","name","bookMarkIds","selections","ranges","_createMarkers","_recordJumpDef","event","force","target","_refreshInProgress","origin","window","type","_recordCurrentPos","navFrame","shift","_clearMarkers","currentEditPos","lastBack","pop","push","_isRangerOverlap","prevStart","prevEnd","curStart","curEnd","temp","_isSimilarSelection","prev","current","_","isEqual","startPrev","anchor","start","endPrev","head","end","startCur","endCur","psc","ch","psl","line","pec","pel","csc","csl","cec","cel","_isSimilarBookmarks","_getCurrentEditNavFrame","currentFullEditor","getCurrentFullEditor","currentlyViewedFile","getCurrentlyViewedFile","currentEditNavFrame","listSelections","getActivePaneId","_navigateBack","skipCurrentFile","done","goTo","fail","execute","always","_navigateForward","_initNavigationMenuItems","menu","getMenu","AppMenuBar","NAVIGATE_MENU","addMenuItem","AFTER","NAVIGATE_PREV_DOC","_initNavigationCommands","register","CMD_NAVIGATE_BACKWARD","CMD_NAVIGATE_FORWARD","Phoenix","isTestWindow","_clearStacks","get","addBinding","_backupLiveMarkers","frames","index","frame","_handleEditorDestroy","_handleEditorCleanup","_removeBackwardFramesForFile","filter","_validateFileHash","_removeForwardFramesForFile","_removeFileFromStack","_reinstateMarkers","_captureBackFrame","_handleActiveEditorChange","previous","off","on","_currentFileChanged","_evt","activeFullEditor","_initHandlers","_navigateBackClicked","evt","countEvent","EVENT_TYPE","UI","shiftKey","focusActivePane","_navigateForwardClicked","_showInFileTreeClicked","NAVIGATE_SHOW_IN_FILE_TREE","_findInFiles","CMD_FIND_IN_FILES","_newProjectClicked","FILE_NEW_PROJECT","_getShortcutDisplay","baseStr","commandID","shortCut","getKeyBindingsDisplay","updateTooltips","attr","CMD_SHOW_IN_TREE","CMD_PROJECT_NEW","_setupNavigationButtons","$mainNavBarRight","$mainNavBarLeft","find","EVENT_KEY_BINDING_ADDED","contextmenu","init","prototype","_backupSelectionRanges","range","rangeStart","rangeEnd","bookMark","setBookmark","id","markText","className","marker","selection","self","markers","getAllMarks","indexOf","from","to","clear","thisDoc","getOpenDocumentForPath","_masterEditor","FILE_OPEN","fullPath","setSelections"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2017 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n/*global _ */\n/**\n * Manages Editor navigation history to aid back/fwd movement between the edit positions\n * in the active project context. The navigation history is purely in-memory and not\n * persisted to file system when a project is being closed.\n */\ndefine(function (require, exports, module) {\n\n\n    var Strings                 = require(\"strings\"),\n        MainViewManager         = require(\"view/MainViewManager\"),\n        DocumentManager         = require(\"document/DocumentManager\"),\n        EditorManager           = require(\"editor/EditorManager\"),\n        ProjectManager          = require(\"project/ProjectManager\"),\n        CommandManager          = require(\"command/CommandManager\"),\n        Commands                = require(\"command/Commands\"),\n        Menus                   = require(\"command/Menus\"),\n        KeyBindingManager       = require(\"command/KeyBindingManager\"),\n        FileSystem              = require(\"filesystem/FileSystem\"),\n        Metrics                 = require(\"utils/Metrics\");\n\n    var KeyboardPrefs = JSON.parse(require(\"text!./keyboard.json\"));\n\n    // Command constants for navigation history\n    const NAVIGATION_JUMP_BACK      = \"navigation.jump.back\",\n        NAVIGATION_JUMP_FWD       = \"navigation.jump.fwd\",\n        _NAVIGATION_RESET_FOR_TESTS       = \"navigation.jump.reset.tests\";\n\n    // The latency time to capture an explicit cursor movement as a navigation frame\n    var MAX_NAV_FRAMES_COUNT = 50;\n\n    let $navback = null,\n        $navForward = null,\n        $searchNav = null,\n        $newProject = null,\n        $showInTree = null;\n\n   /**\n    * Contains list of most recently known cursor positions.\n    * @private\n    * @type {Array.<Object>}\n    */\n    var jumpBackwardStack = [];\n\n   /**\n    * Contains list of most recently traversed cursor positions using NAVIGATION_JUMP_BACK command.\n    * @private\n    * @type {Array.<Object>}\n    */\n    var jumpForwardStack = [],\n        jumpInProgress = false,\n        commandJumpBack,\n        commandJumpFwd;\n\n   /**\n    * Function to check if there are any navigatable frame backward.\n    * @private\n    */\n    function _hasNavBackFrames() {\n        return (jumpBackwardStack.length > 0);\n    }\n\n    function _hasNavForwardFrames() {\n        return jumpForwardStack.length > 0;\n    }\n\n    function _setEnableBackNavButton(enabled) {\n        if(enabled){\n            $navback.removeClass('nav-back-btn-disabled').addClass('nav-back-btn');\n        } else {\n            $navback.removeClass('nav-back-btn').addClass('nav-back-btn-disabled');\n        }\n    }\n\n    function _setEnableForwardNavButton(enabled) {\n        if(enabled){\n            $navForward.removeClass('nav-forward-btn-disabled').addClass('nav-forward-btn');\n        } else {\n            $navForward.removeClass('nav-forward-btn').addClass('nav-forward-btn-disabled');\n        }\n    }\n\n   /**\n    * Function to enable/disable navigation command based on cursor positions availability.\n    * @private\n    */\n    function _validateNavigationCmds() {\n        commandJumpBack.setEnabled(_hasNavBackFrames());\n        commandJumpFwd.setEnabled(_hasNavForwardFrames());\n        _setEnableBackNavButton(_hasNavBackFrames());\n        _setEnableForwardNavButton(_hasNavForwardFrames());\n    }\n\n   /**\n    * Function to check existence of a file entry, validity of markers\n    * @private\n    */\n    function _validateFrame(entry) {\n        var deferred = new $.Deferred(),\n            fileEntry = FileSystem.getFileForPath(entry.filePath);\n\n        if (entry.inMem) {\n            var indexInWS = MainViewManager.findInWorkingSet(entry.paneId, entry.filePath);\n            // Remove entry if InMemoryFile is not found in Working set\n            if (indexInWS === -1) {\n                deferred.reject();\n            } else {\n                deferred.resolve();\n            }\n        } else {\n            fileEntry.exists(function (err, exists) {\n                if (!err && exists) {\n                    // Additional check to handle external modification and mutation of the doc text affecting markers\n                    if(entry.nonEditorView){\n                        deferred.resolve(); // no markers, file exists, valid\n                    } else if (fileEntry._hash !== entry._hash) {\n                        deferred.reject();\n                    } else if (!entry._validateMarkers()) {\n                        deferred.reject();\n                    } else {\n                        deferred.resolve();\n                    }\n                } else {\n                    deferred.reject();\n                }\n            });\n        }\n\n        return deferred.promise();\n    }\n\n   /**\n    * Prototype to capture a navigation frame and it's various data/functional attributues\n    */\n    function NavigationFrame(editor, selectionObj, fileWithoutEditor, fileWithoutEditorPaneID) {\n        if(editor) {\n            this.cm = editor._codeMirror;\n            this.paneId = editor._paneId;\n        }\n        this.uId = (new Date()).getTime();\n\n        if(editor && fileWithoutEditor) {\n            console.error(\"Both Editor and fileWithoutEditor set for NavigationFrame, only one is expected!!!\");\n        }\n        if(fileWithoutEditor) {\n            this.nonEditorView = true;\n            this.paneId = fileWithoutEditorPaneID;\n        }\n        const fileToUse = fileWithoutEditor ? fileWithoutEditor : editor.document.file;\n        this.filePath = fileToUse._path;\n        this.inMem = fileToUse.constructor.name === \"InMemoryFile\";\n        this._hash = fileToUse._hash;\n\n        this.bookMarkIds = [];\n        if(selectionObj){\n            this.selections = selectionObj.ranges || [];\n            this._createMarkers(selectionObj.ranges);\n        } else {\n            this.selections = [];\n        }\n    }\n\n   /**\n    * Lifecycle event handler of the editor for which this frame is captured\n    */\n    NavigationFrame.prototype._handleEditorDestroy = function (editor) {\n        this._backupSelectionRanges();\n        this._clearMarkers();\n        this.cm = null;\n        this.bookMarkIds = null;\n    };\n\n    /**\n    * Function to re-create CM TextMarkers for previously backed up ranges\n    * This logic is required to ensure that the captured navigation positions\n    * stay valid and contextual even when the actual document text mutates.\n    * The mutations which are handled here :\n    * -> Addition/Deletion of lines before the captured position\n    * -> Addition/Updation of characters in the captured selection\n    */\n    NavigationFrame.prototype._reinstateMarkers = function (editor) {\n        this.cm = editor._codeMirror;\n        this.paneId = editor._paneId;\n        this._createMarkers(this.selections);\n    };\n\n\n    /**\n    * Function to validate an existing frame against a file '_hash' to detect\n    * external change so that the frame can be discarded\n    */\n    NavigationFrame.prototype._validateFileHash = function (file) {\n        return this.filePath === file._path ? this._hash === file._hash : true;\n    };\n\n   /**\n    * Function to create CM TextMarkers for the navigated positions/selections.\n    * This logic is required to ensure that the captured navigation positions\n    * stay valid and contextual even when the actual document text mutates.\n    * The mutations which are handled here :\n    * -> Addition/Deletion of lines before the captured position\n    * -> Addition/Updation of characters in the captured selection\n    */\n    NavigationFrame.prototype._createMarkers = function (ranges) {\n        if(!ranges){\n            return;\n        }\n        let range,\n            rangeStart,\n            rangeEnd,\n            index,\n            bookMark;\n\n        this.bookMarkIds = [];\n        for (index in ranges) {\n            range = ranges[index];\n            rangeStart = range.anchor || range.start;\n            rangeEnd = range.head || range.end;\n            // 'markText' has to used for a non-zero length position, if current selection is\n            // of zero length use bookmark instead.\n            if (rangeStart.line === rangeEnd.line && rangeStart.ch === rangeEnd.ch) {\n                bookMark = this.cm.setBookmark(rangeStart, rangeEnd);\n                this.bookMarkIds.push(bookMark.id);\n            } else {\n                this.cm.markText(rangeStart, rangeEnd, {className: (this.uId)});\n            }\n        }\n    };\n\n   /**\n    * Function to actually convert the CM markers to CM positions which can be used to\n    * set selections or cursor positions in Editor.\n    */\n    NavigationFrame.prototype._backupSelectionRanges = function () {\n        if (!this.cm) {\n            return;\n        }\n\n        var marker,\n            selection,\n            index;\n\n        // Reset selections first.\n        this.selections = [];\n        var self = this;\n\n        // Collate only the markers we used to mark selections/cursors\n        var markers = this.cm.getAllMarks().filter(function (entry) {\n            if (entry.className === self.uId || self.bookMarkIds.indexOf(entry.id) !== -1) {\n                return entry;\n            }\n        });\n\n        // Iterate over CM textmarkers and collate the updated(if?) positions\n        for (index in markers) {\n            marker = markers[index];\n            selection = marker.find();\n            if (marker.type === \"bookmark\") {\n                this.selections.push({start: selection, end: selection});\n            } else {\n                this.selections.push({start: selection.from, end: selection.to});\n            }\n        }\n    };\n\n   /**\n    * Function to clean up the markers in cm\n    */\n    NavigationFrame.prototype._clearMarkers = function () {\n        if (!this.cm) {\n            return;\n        }\n        var self = this;\n\n        // clear only the markers we used to mark selections/cursors\n        this.cm.getAllMarks().filter(function (entry) {\n            if (entry.className === self.uId || self.bookMarkIds.indexOf(entry.id) !== -1) {\n                entry.clear();\n            }\n        });\n    };\n\n    /**\n    * Function to check if we have valid markers in cm for this frame\n    */\n    NavigationFrame.prototype._validateMarkers = function () {\n        if(this.nonEditorView){\n            return true;\n        }\n        this._backupSelectionRanges();\n        return this.selections.length;\n    };\n\n   /**\n    * Function to actually navigate to the position(file,selections) captured in this frame\n    */\n    NavigationFrame.prototype.goTo = function () {\n        const self = this;\n        this._backupSelectionRanges();\n        jumpInProgress = true;\n\n        // To ensure we don't reopen the same doc in the last known pane\n        // rather bring it to the same pane where user has opened it\n        let thisDoc = DocumentManager.getOpenDocumentForPath(this.filePath);\n        if (thisDoc && thisDoc._masterEditor) {\n            this.paneId = thisDoc._masterEditor._paneId;\n        }\n\n        CommandManager.execute(Commands.FILE_OPEN, {fullPath: this.filePath, paneId: this.paneId}).done(function () {\n            if(!self.nonEditorView) {\n                EditorManager.getCurrentFullEditor().setSelections(self.selections, true);\n            }\n            _validateNavigationCmds();\n        }).always(function () {\n            jumpInProgress = false;\n        });\n    };\n\n\n   /**\n    * Function to capture a non-zero set of selections as a navigation frame.\n    * The assumptions behind capturing a frame as a navigation frame are :\n    *\n    * -> If it's set by user explicitly (using mouse click or jump to definition)\n    * -> By clicking on search results\n    * -> Change of cursor by keyboard navigation keys or actual edits are not captured.\n    *\n    * @private\n    */\n    function _recordJumpDef(event, selectionObj, force) {\n        // Don't capture frames if we are navigating or document text is being refreshed(fileSync in progress)\n        if (jumpInProgress || (event.target && event.target.document._refreshInProgress)) {\n            return;\n        }\n        // Reset forward navigation stack if we are capturing a new event\n        jumpForwardStack = [];\n       _validateNavigationCmds();\n\n        // Ensure cursor activity has not happened because of arrow keys or edit\n        if (selectionObj.origin !== \"+move\" && (!window.event || window.event.type !== \"input\")) {\n            let _recordCurrentPos = function () {\n                // Check if we have reached MAX_NAV_FRAMES_COUNT\n                // If yes, control overflow\n                if (jumpBackwardStack.length === MAX_NAV_FRAMES_COUNT) {\n                    var navFrame = jumpBackwardStack.shift();\n                    navFrame._clearMarkers();\n                }\n\n                let currentEditPos = new NavigationFrame(event.target, selectionObj);\n                let lastBack = jumpBackwardStack.pop();\n                if(lastBack && lastBack!== currentEditPos){\n                    // make sure that we don't push in duplicates\n                    jumpBackwardStack.push(lastBack);\n                }\n                jumpBackwardStack.push(currentEditPos);\n                _validateNavigationCmds();\n            };\n            if(force || (event && event.type === 'mousedown') || (event && event.type === \"beforeSelectionChange\")){\n                // We should record nav history immediately is the user changes currently active doc by clicking files\n                _recordCurrentPos();\n            }\n        }\n    }\n\n    function _isRangerOverlap(prevStart, prevEnd, curStart, curEnd) {\n        if(prevStart>prevEnd){\n            let temp = prevStart;\n            prevStart = prevEnd;\n            prevEnd = temp;\n        }\n        if(curStart>curEnd){\n            let temp = curStart;\n            curStart = curEnd;\n            curEnd = temp;\n        }\n        return prevStart <= curEnd && curStart <= prevEnd;\n    }\n\n    function _isSimilarSelection(prev, current) {\n        if(_.isEqual(prev, current)){\n            return true;\n        }\n        if(prev.length === current.length && current.length === 1){\n            let startPrev = prev[0].anchor || prev[0].start,\n                endPrev = prev[0].head || prev[0].end,\n                startCur = current[0].anchor || current[0].start,\n                endCur = current[0].head || current[0].end;\n            let psc= startPrev.ch, psl= startPrev.line,\n                pec= endPrev.ch, pel= endPrev.line,\n                csc= startCur.ch, csl= startCur.line,\n                cec= endCur.ch, cel= endCur.line;\n            if(_isRangerOverlap(psl, pel, csl, cel)\n                && _isRangerOverlap(psc, pec, csc, cec)){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isSimilarBookmarks(prev, current) {\n        if(current.length === 0 && prev.length >= 1){\n            // on the same file, if there is no present book mark, then its as good as no book mark\n            return true;\n        }\n        return prev.length === current.length;\n    }\n\n    function _getCurrentEditNavFrame() {\n        const currentFullEditor = EditorManager.getCurrentFullEditor();\n        const currentlyViewedFile = MainViewManager.getCurrentlyViewedFile();\n        let currentEditNavFrame = null;\n        if(currentFullEditor){\n            currentEditNavFrame = new NavigationFrame(EditorManager.getCurrentFullEditor(),\n                {ranges: EditorManager.getCurrentFullEditor()._codeMirror.listSelections()});\n        } else if(currentlyViewedFile){\n            currentEditNavFrame = new NavigationFrame(null, null,\n                currentlyViewedFile, MainViewManager.getActivePaneId());\n        }\n        return currentEditNavFrame;\n    }\n\n   /**\n    * Command handler to navigate backward\n    */\n    function _navigateBack(skipCurrentFile) {\n        let deferred = new $.Deferred();\n        let navFrame = jumpBackwardStack.pop();\n        let currentEditNavFrame = _getCurrentEditNavFrame();\n\n        // Check if the poped frame is the current active frame or doesn't have any valid marker information\n        // if true, jump again\n        while (navFrame && navFrame === currentEditNavFrame\n        ||(navFrame && currentEditNavFrame && navFrame.filePath === currentEditNavFrame.filePath\n            && _isSimilarSelection(navFrame.selections, currentEditNavFrame.selections)\n            && _isSimilarBookmarks(navFrame.bookMarkIds, currentEditNavFrame.bookMarkIds))\n        ||(skipCurrentFile && navFrame && currentEditNavFrame && navFrame.filePath === currentEditNavFrame.filePath)) {\n            navFrame = jumpBackwardStack.pop();\n        }\n\n        if (navFrame) {\n            // We will check for the file existence now, if it doesn't exist we will jump back again\n            // but discard the popped frame as invalid.\n            _validateFrame(navFrame).done(function () {\n                if(currentEditNavFrame) {\n                    jumpForwardStack.push(currentEditNavFrame);\n                }\n                navFrame.goTo();\n            }).fail(function () {\n                CommandManager.execute(NAVIGATION_JUMP_BACK);\n            }).always(function () {\n                _validateNavigationCmds();\n                deferred.resolve();\n            });\n        } else {\n            if(currentEditNavFrame){\n                jumpBackwardStack.push(currentEditNavFrame);\n            }\n            deferred.resolve();\n        }\n        return deferred.promise();\n    }\n\n   /**\n    * Command handler to navigate forward\n    */\n    function _navigateForward(skipCurrentFile) {\n        let deferred = new $.Deferred();\n        let navFrame = jumpForwardStack.pop();\n        let currentEditNavFrame = _getCurrentEditNavFrame();\n\n        if (!navFrame) {\n            return new $.Deferred().resolve().promise();\n        }\n\n        // Check if the poped frame is the current active frame or doesn't have any valid marker information\n        // if true, jump again\n        while (navFrame === currentEditNavFrame\n        ||(navFrame && currentEditNavFrame && navFrame.filePath === currentEditNavFrame.filePath\n            && _isSimilarSelection(navFrame.selections ,currentEditNavFrame.selections)\n            && _isSimilarBookmarks(navFrame.bookMarkIds, currentEditNavFrame.bookMarkIds))\n        ||(skipCurrentFile && navFrame && currentEditNavFrame && navFrame.filePath === currentEditNavFrame.filePath)) {\n            navFrame = jumpForwardStack.pop();\n        }\n\n        if(navFrame){\n            // We will check for the file existence now, if it doesn't exist we will jump back again\n            // but discard the popped frame as invalid.\n            _validateFrame(navFrame).done(function () {\n                if(currentEditNavFrame){\n                    jumpBackwardStack.push(currentEditNavFrame);\n                }\n                navFrame.goTo();\n            }).fail(function () {\n                _validateNavigationCmds();\n                CommandManager.execute(NAVIGATION_JUMP_FWD);\n            }).always(function () {\n                _validateNavigationCmds();\n                deferred.resolve();\n            });\n        } else {\n            deferred.resolve();\n        }\n       return deferred.promise();\n    }\n\n   /**\n    * Function to initialize navigation menu items.\n    * @private\n    */\n    function _initNavigationMenuItems() {\n        var menu = Menus.getMenu(Menus.AppMenuBar.NAVIGATE_MENU);\n        menu.addMenuItem(NAVIGATION_JUMP_BACK, \"\", Menus.AFTER, Commands.NAVIGATE_PREV_DOC);\n        menu.addMenuItem(NAVIGATION_JUMP_FWD, \"\", Menus.AFTER, NAVIGATION_JUMP_BACK);\n    }\n\n   /**\n    * Function to initialize navigation commands and it's keyboard shortcuts.\n    * @private\n    */\n    function _initNavigationCommands() {\n        CommandManager.register(Strings.CMD_NAVIGATE_BACKWARD, NAVIGATION_JUMP_BACK, _navigateBack);\n        CommandManager.register(Strings.CMD_NAVIGATE_FORWARD, NAVIGATION_JUMP_FWD, _navigateForward);\n        if(Phoenix.isTestWindow){\n            CommandManager.register(\"reset nav forward and back for tests\", _NAVIGATION_RESET_FOR_TESTS, _clearStacks);\n        }\n        commandJumpBack = CommandManager.get(NAVIGATION_JUMP_BACK);\n        commandJumpFwd = CommandManager.get(NAVIGATION_JUMP_FWD);\n        commandJumpBack.setEnabled(false);\n        commandJumpFwd.setEnabled(false);\n        KeyBindingManager.addBinding(NAVIGATION_JUMP_BACK, KeyboardPrefs[NAVIGATION_JUMP_BACK]);\n        KeyBindingManager.addBinding(NAVIGATION_JUMP_FWD, KeyboardPrefs[NAVIGATION_JUMP_FWD]);\n        _initNavigationMenuItems();\n    }\n\n    /**\n    * Create snapshot of last known live markers.\n    * @private\n    */\n    function _backupLiveMarkers(frames, editor) {\n        var index, frame;\n        for (index in frames) {\n            frame = frames[index];\n            if (frame.cm === editor._codeMirror) {\n                frame._handleEditorDestroy();\n            }\n        }\n    }\n\n    /**\n    * Handle Editor destruction to create backup of live marker positions\n    * @private\n    */\n    function _handleEditorCleanup(event, editor) {\n        _backupLiveMarkers(jumpBackwardStack, editor);\n        _backupLiveMarkers(jumpForwardStack, editor);\n    }\n\n    /**\n    * Removes all frames from backward navigation stack for the given file only if the file is changed on disk.\n    * @private\n    */\n    function _removeBackwardFramesForFile(file) {\n        jumpBackwardStack = jumpBackwardStack.filter(function (frame) {\n            return frame._validateFileHash(file);\n        });\n    }\n\n    /**\n    * Removes all frames from forward navigation stack for the given file only if the file is changed on disk.\n    * @private\n    */\n    function _removeForwardFramesForFile(file) {\n        jumpForwardStack = jumpForwardStack.filter(function (frame) {\n            return frame._validateFileHash(file);\n        });\n    }\n\n    /**\n    * Handles explicit content reset for a document caused by external changes\n    * @private\n    */\n    function _removeFileFromStack(file) {\n        if (file) {\n            _removeBackwardFramesForFile(file);\n            _removeForwardFramesForFile(file);\n            _validateNavigationCmds();\n        }\n    }\n\n    function _clearStacks() {\n        jumpBackwardStack = [];\n        jumpForwardStack = [];\n        _validateNavigationCmds();\n    }\n\n    /**\n     * Required to make offline markers alive again to track document mutation\n     * @private\n     */\n    function _reinstateMarkers(editor, frames) {\n        var index, frame;\n        for (index in frames) {\n            frame = frames[index];\n            if (!frame.cm && frame.filePath === editor.document.file._path) {\n                frame._reinstateMarkers(editor);\n            }\n        }\n    }\n\n    /**\n     * Function to request a navigation frame creation explicitly. Resets forward stack\n     * @private\n     */\n    function _captureBackFrame(editor) {\n        _recordJumpDef({target: editor},\n            {ranges: editor._codeMirror.listSelections()},\n            true);\n    }\n\n    /**\n     * Handle Active Editor change to update navigation information\n     * @private\n     */\n    function _handleActiveEditorChange(event, current, previous) {\n        if (previous && previous._paneId) { // Handle only full editors\n            previous.off(\"beforeSelectionChange\", _recordJumpDef);\n            _captureBackFrame(previous);\n            _validateNavigationCmds();\n        }\n\n        if (current && current._paneId) { // Handle only full editors\n            current.off(\"beforeSelectionChange\", _recordJumpDef);\n            current.on(\"beforeSelectionChange\", _recordJumpDef);\n            current.off(\"beforeDestroy\", _handleEditorCleanup);\n            current.on(\"beforeDestroy\", _handleEditorCleanup);\n        }\n    }\n\n    function _currentFileChanged(_evt) {\n        if(jumpInProgress) {\n            return;\n        }\n        // We may not always have an active editor to navigate, For Eg: image/video or other custom views\n        // have its onw non-editor views. This section is to handle those cases.\n        const activeFullEditor = EditorManager.getCurrentFullEditor();\n        if(activeFullEditor){\n            return; // this is a text file with codemirror editor, this is handled by _handleActiveEditorChange\n        }\n        const currentEditNavFrame = _getCurrentEditNavFrame();\n        let lastBack = jumpBackwardStack.pop();\n        if(lastBack && lastBack!== currentEditNavFrame){\n            // make sure that we don't push in duplicates\n            jumpBackwardStack.push(lastBack);\n        }\n        if(currentEditNavFrame) {\n            jumpBackwardStack.push(currentEditNavFrame);\n        }\n        jumpForwardStack = [];\n        _validateNavigationCmds();\n    }\n\n    function _initHandlers() {\n        EditorManager.on(\"activeEditorChange\", _handleActiveEditorChange);\n        MainViewManager.on(\"currentFileChange\", _currentFileChanged);\n        ProjectManager.on(\"projectOpen\", _clearStacks);\n        EditorManager.on(\"_fullEditorCreatedForDocument\", function (event, document, editor) {\n            _reinstateMarkers(editor, jumpBackwardStack);\n            _reinstateMarkers(editor, jumpForwardStack);\n        });\n        FileSystem.on(\"change\", function (event, entry) {\n            if (entry) {\n                _removeFileFromStack(entry);\n            }\n        });\n    }\n\n    function _navigateBackClicked(evt) {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI, \"fileNavBar\", \"back\");\n        if(_hasNavBackFrames()){\n            _navigateBack(evt.shiftKey || (evt.type === \"contextmenu\"));\n        }\n        _validateNavigationCmds();\n        MainViewManager.focusActivePane();\n    }\n\n    function _navigateForwardClicked(evt) {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI, \"fileNavBar\", \"forward\");\n        if(_hasNavForwardFrames()){\n            _navigateForward(evt.shiftKey || (evt.type === \"contextmenu\"));\n        }\n        _validateNavigationCmds();\n        MainViewManager.focusActivePane();\n    }\n\n    function _showInFileTreeClicked() {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI, \"fileNavBar\", \"showInFileTree\");\n        CommandManager.execute(Commands.NAVIGATE_SHOW_IN_FILE_TREE);\n    }\n\n    function _findInFiles() {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI, \"fileNavBar\", \"search\");\n        CommandManager.execute(Commands.CMD_FIND_IN_FILES);\n    }\n\n    function _newProjectClicked() {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI, \"fileNavBar\", \"newProject\");\n        CommandManager.execute(Commands.FILE_NEW_PROJECT);\n    }\n\n    function _getShortcutDisplay(baseStr, commandID) {\n        let shortCut = KeyBindingManager.getKeyBindingsDisplay(commandID);\n        if(shortCut) {\n            return `${baseStr} (${shortCut})`;\n        }\n        return baseStr;\n    }\n\n    function updateTooltips() {\n        $navback.attr(\"title\", _getShortcutDisplay(Strings.CMD_NAVIGATE_BACKWARD, NAVIGATION_JUMP_BACK));\n        $navForward.attr(\"title\", _getShortcutDisplay(Strings.CMD_NAVIGATE_FORWARD, NAVIGATION_JUMP_FWD));\n        $showInTree.attr(\"title\", _getShortcutDisplay(Strings.CMD_SHOW_IN_TREE, Commands.NAVIGATE_SHOW_IN_FILE_TREE));\n        $searchNav.attr(\"title\", _getShortcutDisplay(Strings.CMD_FIND_IN_FILES, Commands.CMD_FIND_IN_FILES));\n        // new project extension is not yet loaded, so we cant show keyboard shortcut here.\n        $newProject.attr(\"title\", Strings.CMD_PROJECT_NEW);\n    }\n\n    function _setupNavigationButtons() {\n        let $mainNavBarRight = $(\"#mainNavBarRight\");\n        let $mainNavBarLeft = $(\"#mainNavBarLeft\");\n        $showInTree = $mainNavBarRight.find(\"#showInfileTree\");\n        $navback = $mainNavBarRight.find(\"#navBackButton\");\n        $navForward = $mainNavBarRight.find(\"#navForwardButton\");\n        $searchNav = $mainNavBarRight.find(\"#searchNav\");\n\n        $newProject = $mainNavBarLeft.find(\"#newProject\");\n        updateTooltips();\n        CommandManager.get(NAVIGATION_JUMP_BACK).on(KeyBindingManager.EVENT_KEY_BINDING_ADDED, updateTooltips);\n        CommandManager.get(NAVIGATION_JUMP_FWD).on(KeyBindingManager.EVENT_KEY_BINDING_ADDED, updateTooltips);\n        CommandManager.get(Commands.NAVIGATE_SHOW_IN_FILE_TREE).on(KeyBindingManager.EVENT_KEY_BINDING_ADDED, updateTooltips);\n        CommandManager.get(Commands.CMD_FIND_IN_FILES).on(KeyBindingManager.EVENT_KEY_BINDING_ADDED, updateTooltips);\n\n        $navback.on(\"click\", _navigateBackClicked);\n        $navForward.on(\"click\", _navigateForwardClicked);\n        $(\"#navBackButton\").contextmenu(_navigateBackClicked);\n        $(\"#navForwardButton\").contextmenu(_navigateForwardClicked);\n        $showInTree.on(\"click\", _showInFileTreeClicked);\n        $searchNav.on(\"click\", _findInFiles);\n        $newProject.on(\"click\", _newProjectClicked);\n    }\n\n\n    function init() {\n        _initNavigationCommands();\n        _initHandlers();\n        _setupNavigationButtons();\n    }\n\n    exports.init = init;\n});\n"],"file":"NavigationProvider.js"}
{"version":3,"sources":["extensionsIntegrated/HtmlTagSyncEdit/main.js"],"names":["define","require","exports","module","AppInit","Editor","LanguageManager","CodeMirror","Commands","PreferencesManager","WorkspaceManager","Strings","Menus","CommandManager","EditorManager","CMD_AUTO_RENAME_TAGS","HTML_TAG_SYNC","MARK_TYPE_TAG_RENAME_START","MARK_TYPE_TAG_RENAME_END","MARK_TYPE_TAG_RENAME_ESCAPED","PREFERENCES_AUTO_RENAME_TAGS","definePreference","description","DESCRIPTION_AUTO_RENAME_TAGS","syncEditEnabled","get","MARK_STYLE","className","clearWhenEmpty","inclusiveLeft","inclusiveRight","MARK_STYLE_ESCAPE","activeEditor","marksPresent","tagPosition","langType","clearRenameMarkers","off","EVENT_CHANGE","clearAllMarks","_getTagToken","cursor","curChar","getCharacterAtPosition","token","getToken","string","type","ch","previousChar","line","clearMarks","_replaceMarkText","markType","text","editOrigin","markToReplace","getAllMarks","length","find","replaceRange","from","to","_repositionCursor","offset","mark","setCursorPos","ignoreChanges","_changeHandler","_evt","_editor","changes","origin","getCursorPos","escapeMarks","findMarksAt","markedText","getTextBetween","_isEditingEmptyTag","undo","operation","includes","cursorOffsetInMark","tag","trim","markedReplaceText","updateRenameMarkers","matchingTags","tagName","open","openPos","closePos","close","at","openPosStart","openPosEnd","markText","closePosStart","closePosEnd","on","cursorActivity","hasMultipleCursors","startMark","endMark","escapeMark","findMatchingTag","_codeMirror","toggleAutoRenameTags","set","enableIfNeeded","init","tagSyncFileModes","Set","_isTagSyncEditable","editor","language","getLanguageForPath","document","file","fullPath","getId","has","EVENT_CURSOR_ACTIVITY","Phoenix","isTestWindow","window","___syncEditEnabledForTests","getActiveEditor","_handleEscapeKeyEvent","_event","activeMark","clear","appReady","EVENT_ACTIVE_EDITOR_CHANGED","setTimeout","toggleCmd","register","setChecked","getMenu","AppMenuBar","EDIT_MENU","addMenuItem","AFTER","TOGGLE_CLOSE_BRACKETS","addEscapeKeyEventHandler"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global*/\n\n// This file handles synchronous tag edit for html files. ie, if we edit <div> then the </div> part is also updated.\n// this is a state machine over an abstract syntax tree and is a bit complex. apologies to the reader.\n\ndefine(function (require, exports, module) {\n    const AppInit = require(\"utils/AppInit\"),\n        Editor = require(\"editor/Editor\").Editor,\n        LanguageManager     = require(\"language/LanguageManager\"),\n        CodeMirror = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        Commands            = require(\"command/Commands\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        WorkspaceManager      = require(\"view/WorkspaceManager\"),\n        Strings             = require(\"strings\"),\n        Menus = require(\"command/Menus\"),\n        CommandManager     = require(\"command/CommandManager\"),\n        EditorManager = require(\"editor/EditorManager\");\n\n    const CMD_AUTO_RENAME_TAGS = \"edit.autoRenameTags\";\n\n    const HTML_TAG_SYNC = \".htmlTagSync\",\n        MARK_TYPE_TAG_RENAME_START = \"startTagSyncEdit\",\n        MARK_TYPE_TAG_RENAME_END = \"endTagSyncEdit\",\n        MARK_TYPE_TAG_RENAME_ESCAPED = \"escapeTagSyncEdit\";\n\n    const PREFERENCES_AUTO_RENAME_TAGS = \"autoRenameTags\";\n    PreferencesManager.definePreference(PREFERENCES_AUTO_RENAME_TAGS, \"boolean\", true, {\n        description: Strings.DESCRIPTION_AUTO_RENAME_TAGS\n    });\n\n    let syncEditEnabled = PreferencesManager.get(PREFERENCES_AUTO_RENAME_TAGS);\n\n    const MARK_STYLE = {\n            className: \"editor-text-tag-sync-underline\",\n            clearWhenEmpty: false,\n            inclusiveLeft: true,\n            inclusiveRight: true\n        }, MARK_STYLE_ESCAPE = {\n            className: \"editor-text-tag-sync-escape\",\n            clearWhenEmpty: false,\n            inclusiveLeft: true,\n            inclusiveRight: true\n        };\n    let activeEditor, marksPresent, tagPosition, langType;\n\n    function clearRenameMarkers() {\n        if(!marksPresent || !activeEditor){\n            return;\n        }\n        marksPresent = false;\n        activeEditor.off(Editor.EVENT_CHANGE + HTML_TAG_SYNC);\n        activeEditor.clearAllMarks(MARK_TYPE_TAG_RENAME_START);\n        activeEditor.clearAllMarks(MARK_TYPE_TAG_RENAME_END);\n        activeEditor.clearAllMarks(MARK_TYPE_TAG_RENAME_ESCAPED);\n    }\n\n    function _getTagToken(cursor) {\n        let curChar = activeEditor.getCharacterAtPosition(cursor);\n        if(curChar === \"<\"){ // <|<  or <div>|</div> is not a valid tag edit point\n            return {};\n        }\n        let token = activeEditor.getToken(cursor);\n        if(token && token.string === \"<>\"){\n            // empty tags are not syncable if they are not being edited\n            return {};\n        }\n        if(token && token.type === \"tag bracket\" && token.string !== \">\") {\n            // the cursosr is just before the tag like: <|tag or </|tag or <|/tag ; but not <tag|>\n            // move one step to <t|ag or </t|ag or </|tag ; position </|tag is still invalid tough\n            cursor.ch++;\n            token = activeEditor.getToken(cursor);\n        } else if(langType === \"xml\" && token && curChar === \" \" && cursor.ch >= 1){\n            const previousChar = activeEditor.getCharacterAtPosition({line: cursor.line, ch: cursor.ch - 1});\n            // in xml, thers AST behaves differently where if there is a space after `<tag>| ` or `</tag>| `, then at\n            // the end cursor location shown, get token will still return the \"tag\" token, though its outside the tag.\n            // so we consider the case differently.\n            if(previousChar === \">\") {\n                return {clearMarks: true};\n            }\n        }\n        if(!token || !(token.type === \"tag\" || token.type === \"tag error\")) {\n            return {};\n        }\n        return {token};\n    }\n\n    function _replaceMarkText(markType, text, editOrigin) {\n        let markToReplace = activeEditor.getAllMarks(markType);\n        if(!markToReplace.length) {\n            return;\n        }\n        markToReplace = markToReplace[0].find();\n        activeEditor.replaceRange(text, markToReplace.from, markToReplace.to, editOrigin);\n    }\n\n    function _repositionCursor(offset) {\n        let mark = (tagPosition === \"open\") ?\n            activeEditor.getAllMarks(MARK_TYPE_TAG_RENAME_START):\n            activeEditor.getAllMarks(MARK_TYPE_TAG_RENAME_END);\n        if(!mark.length) {\n            // there is no mark here, don't do anything.\n            return;\n        }\n        mark = mark[0].find();\n        activeEditor.setCursorPos(mark.from.line, mark.from.ch+offset);\n    }\n\n    let ignoreChanges = false;\n    function _changeHandler(_evt, _editor, changes) {\n        if(!changes || !activeEditor || !changes.length || ignoreChanges || changes[0].origin === \"undo\"){\n            return;\n        }\n        if(!marksPresent) {\n            clearRenameMarkers();\n            return;\n        }\n        const cursor = activeEditor.getCursorPos();\n        const escapeMarks = activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_ESCAPED);\n        if(escapeMarks.length){\n            // so if the user pressed escape key while on a rename marker, we disable tag sync the rename temporarily\n            // till user moves to a different tag\n            return;\n        }\n        let mark = tagPosition === \"open\" ?\n            activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_START):\n            activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_END);\n        if(!mark.length) {\n            // there is no mark here, don't do anything.\n            return;\n        }\n        mark = mark[0].find();\n        const markedText = activeEditor.getTextBetween(mark.from, mark.to);\n        if(!markedText && marksPresent && _isEditingEmptyTag()) {\n            ignoreChanges = true;\n            activeEditor.undo();\n            activeEditor.operation(()=>{\n                _replaceMarkText(MARK_TYPE_TAG_RENAME_START, \"\", \"syncTagPaste\");\n                _replaceMarkText(MARK_TYPE_TAG_RENAME_END, \"\", \"syncTagPaste\");\n            });\n            ignoreChanges = false;\n            return;\n        }\n        if(!markedText || markedText.includes(\" \")){\n            clearRenameMarkers();\n            return;\n        }\n        const cursorOffsetInMark = cursor.ch - mark.from.ch;\n        const tag = markedText.trim();\n        let markToReplace = activeEditor.getAllMarks(MARK_TYPE_TAG_RENAME_END);\n        if(tagPosition === \"close\"){\n            markToReplace = activeEditor.getAllMarks(MARK_TYPE_TAG_RENAME_START);\n        }\n        if(!markToReplace.length) {\n            return;\n        }\n        markToReplace = markToReplace[0].find();\n        const markedReplaceText = activeEditor.getTextBetween(markToReplace.from, markToReplace.to);\n        if(markedReplaceText === tag){\n            return;\n        }\n        ignoreChanges = true;\n        let editOrigin = changes[0].origin;\n        if(changes[0].origin === \"paste\"){\n            editOrigin = \"syncTagPaste\";\n        }\n        activeEditor.undo();\n        activeEditor.operation(()=>{\n            _replaceMarkText(MARK_TYPE_TAG_RENAME_START, tag, editOrigin);\n            _replaceMarkText(MARK_TYPE_TAG_RENAME_END, tag, editOrigin);\n            _repositionCursor(cursorOffsetInMark);\n        });\n        ignoreChanges = false;\n    }\n\n    function updateRenameMarkers(matchingTags, cursor) {\n        const tagName = matchingTags.open.tag;\n        let openPos = matchingTags.open.from,\n            closePos = matchingTags.close.from;\n        clearRenameMarkers();\n        marksPresent = true;\n        tagPosition = matchingTags.at;\n        // we have to mark only the tag in an open tag of form <|tag| attr=\"...>\n        const openPosStart = {line: openPos.line, ch: openPos.ch +1};\n        const openPosEnd = {line: openPos.line, ch: openPos.ch + 1 + tagName.length};\n        activeEditor.markText(MARK_TYPE_TAG_RENAME_START, openPosStart, openPosEnd, MARK_STYLE);\n        // we have to mark only the tag in an open tag of form </|tag| attr=\"...>\n        const closePosStart = {line: closePos.line, ch: closePos.ch +2};\n        const closePosEnd = {line: closePos.line, ch: closePos.ch + 2 + tagName.length};\n        activeEditor.markText(MARK_TYPE_TAG_RENAME_END, closePosStart, closePosEnd, MARK_STYLE);\n        activeEditor.on(Editor.EVENT_CHANGE + HTML_TAG_SYNC, _changeHandler);\n    }\n\n    /**\n     * we are editing an empty tag if cursor is something like <|> or <| > or <| class=\"\"> or </|> or </| >\n     * @param cursor\n     * @returns {*|null|boolean}\n     * @private\n     */\n    function _isEditingEmptyTag() {\n        if(!marksPresent){\n            return false;\n        }\n        const cursor = activeEditor.getCursorPos();\n        let token = activeEditor.getToken(cursor);\n        let curChar = activeEditor.getCharacterAtPosition(cursor);\n        if(!token || token.type === \"tag\") {\n            return false;\n        }\n        // <| > or </| > or <|> or </|> or </|\\n but not >|\\n\n        if((token.type === \"tag bracket\" || token.string === \"</\") && (curChar === \" \" || curChar === \">\" ||\n            (token.string !== \">\" && !curChar))) {\n            // if curChar is null, it means that its the last charecter\n            return true;\n        }\n        return false;\n    }\n\n    function cursorActivity() {\n        const cursor = activeEditor.getCursorPos();\n        if(activeEditor.hasMultipleCursors()){\n            clearRenameMarkers();\n            return;\n        }\n        const startMark = activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_START);\n        const endMark = activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_END);\n        const escapeMark = activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_ESCAPED);\n        if(startMark.length || endMark.length || escapeMark.length) {\n            // there is already a mark here, don't do anything. This will come in play when the user is editing a start\n            // or end tag and we need to sync update in change handler.\n            return;\n        }\n        let {token, clearMarks} = _getTagToken(cursor);\n        if(!token) {\n            if(!_isEditingEmptyTag() || clearMarks){\n                clearRenameMarkers();\n            }\n            return;\n        }\n        const matchingTags = CodeMirror.findMatchingTag(activeEditor._codeMirror, cursor);\n        if(!matchingTags) {\n            clearRenameMarkers();\n            return;\n        }\n        if(!matchingTags.close){\n            clearRenameMarkers();\n            return;\n        }\n        updateRenameMarkers(matchingTags, cursor);\n    }\n\n    function toggleAutoRenameTags() {\n        PreferencesManager.set(PREFERENCES_AUTO_RENAME_TAGS, !PreferencesManager.get(PREFERENCES_AUTO_RENAME_TAGS));\n    }\n\n    function enableIfNeeded() {\n        syncEditEnabled = PreferencesManager.get(PREFERENCES_AUTO_RENAME_TAGS);\n        init();\n    }\n\n    const tagSyncFileModes = new Set([\"htm\", \"html\", \"xhtml\", \"xml\", \"svg\", \"php\"]);\n    function _isTagSyncEditable(editor) {\n        // ideally we can just listen to html sections within non-html files too instead of only accepting html file\n        // types. This was the original impl but found that html text in markdown sync edit worked as a disaster\n        // mostly due to codemirror issues in AST out of our scope. So we just do this full file switch now.\n        const language = LanguageManager.getLanguageForPath(editor.document.file.fullPath);\n        if(!language || !language.getId()){\n            return false;\n        }\n        langType = language.getId();\n        return tagSyncFileModes.has(language.getId());\n    }\n\n    function init() {\n        if(activeEditor) {\n            activeEditor.off(Editor.EVENT_CURSOR_ACTIVITY + HTML_TAG_SYNC);\n            clearRenameMarkers();\n        }\n        if(!syncEditEnabled || (Phoenix.isTestWindow && !window.___syncEditEnabledForTests)){\n            return;\n        }\n        activeEditor = EditorManager.getActiveEditor();\n        langType = null;\n        if(!activeEditor || !_isTagSyncEditable(activeEditor)) {\n            return;\n        }\n        activeEditor.on(Editor.EVENT_CURSOR_ACTIVITY + HTML_TAG_SYNC, cursorActivity);\n        cursorActivity();\n    }\n\n    function _handleEscapeKeyEvent(_event) {\n        if(!marksPresent || !activeEditor){\n            return false;\n        }\n        const cursor = activeEditor.getCursorPos();\n        const startMark = activeEditor.getAllMarks(MARK_TYPE_TAG_RENAME_START);\n        const endMark = activeEditor.getAllMarks(MARK_TYPE_TAG_RENAME_END);\n        let activeMark = (tagPosition === \"open\") ?\n            activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_START):\n            activeEditor.findMarksAt(cursor, MARK_TYPE_TAG_RENAME_END);\n        if(activeMark.length){\n            const mark = activeMark[0].find();\n            activeEditor.markText(MARK_TYPE_TAG_RENAME_ESCAPED, mark.from, mark.to, MARK_STYLE_ESCAPE);\n            startMark.length && startMark[0].clear();\n            endMark.length && endMark[0].clear();\n            return true;\n        }\n        return false;\n    }\n\n    AppInit.appReady(function () {\n        EditorManager.on(EditorManager.EVENT_ACTIVE_EDITOR_CHANGED + HTML_TAG_SYNC, init);\n        setTimeout(init, 1000);\n        const toggleCmd = CommandManager.register(Strings.CMD_AUTO_RENAME_TAGS, CMD_AUTO_RENAME_TAGS,\n            toggleAutoRenameTags);\n        toggleCmd.setChecked(PreferencesManager.get(PREFERENCES_AUTO_RENAME_TAGS));\n        Menus.getMenu(Menus.AppMenuBar.EDIT_MENU).addMenuItem(CMD_AUTO_RENAME_TAGS,\n            \"\", Menus.AFTER, Commands.TOGGLE_CLOSE_BRACKETS);\n        PreferencesManager.on(\"change\", PREFERENCES_AUTO_RENAME_TAGS, ()=>{\n            toggleCmd.setChecked(PreferencesManager.get(PREFERENCES_AUTO_RENAME_TAGS));\n            enableIfNeeded();\n        });\n        enableIfNeeded();\n        WorkspaceManager.addEscapeKeyEventHandler(\"tagSyncEdit\", _handleEscapeKeyEvent);\n    });\n});\n"],"file":"main.js"}
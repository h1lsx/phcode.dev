{"version":3,"sources":["storage.js"],"names":["set","entries","createStore","setupGlobalStorage","window","PhStore","console","error","EVENT_CHANGED","FIRST_BOOT_TIME","storageNodeConnector","_testKey","nodeStoragePhoenixApis","isBrowser","Phoenix","isNativeApp","isDesktop","PHSTORE_DB","PHSTORE_STORE_NAME","idbStore","_getIDBStorage","PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME","EXTERNAL_CHANGE_BROADCAST_INTERVAL","CHANGE_TYPE_EXTERNAL","CHANGE_TYPE_INTERNAL","MGS_CHANGE","cache","pendingBroadcastKV","watchExternalKeys","commitExternalChanges","changedKV","key","Object","keys","externalChange","t","trigger","STORAGE_NODE_CONNECTOR_ID","PhNodeEngine","createNodeConnector","_tauriBootVarsPromise","then","execPeer","_tauriBootVars","appLocalDir","isTestWindow","on","_evt","storageChannel","BroadcastChannel","setInterval","postMessage","type","onmessage","event","message","data","getItem","cachedResult","v","JSON","parse","MINUTES_10","errorCountReported","sendOnceMore","noFurtherReporting","_reportPutItemError","err","debugMode","logger","reportError","setTimeout","setItem","value","valueToStore","Date","now","stringify","catch","__TAURI__","invoke","removeItem","watchExternalChanges","unwatchExternalChanges","setupFirstBoot","firstBootTime","firstBoot","legacyKey","localStorage","e","storageReadyPromise","Promise","resolve","async","mergeTauriInMemoryStorage","map","_tauriStorageRestorePromise","jsonData","finally","kvArrayAll","kvArray","_PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY","flushDB","persistDBForReboot","zoomFactor","tauri","scaleFactor","_storageBootstrapTime","startTime","_setTestKey","testKey","EventDispatcher","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/** The main persistent storage apis used to store preferences, setting etc. This is synced across all running phoenix\n * tabs in the browser and processes in the desktop app.\n * Data is eventually consistent with sync delays up to a few seconds.\n *\n * Storage API that seamlessly works in both web browsers and Tauri. In web browsers, the API utilizes local storage,\n * providing a consistent and reliable key-value store for small configuration data with persistence guarantees and\n * efficient read-write performance. It's important to note that this storage API is not suitable for storing\n * large data, such as file content or debug-related information.\n *\n * Features:\n * - Synchronous reads with in-memory caching for optimized performance.\n * - Read-after-write consistency within a single instance.\n * - Eventual consistency (within approximately 3 seconds) when used across multiple processes or tabs.\n *\n * The motivation behind implementing this unified storage API is to address the limitations and potential data loss\n * issues associated with using local storage and IndexedDB in our desktop builds. Specifically, certain scenarios,\n * like WebKit's data clearing in Linux and macOS Tauri builds as part of Intelligent Tracking Prevention (ITP),\n * could lead to data loss.\n *\n * The main aim is to have data durability guarantees in desktop builds.\n * In bowser, we can only overcome this if we have cloud login. Eventually we can have a cloud backend that will sync\n * with this storage implementation.\n */\n\n/*global EventDispatcher*/\n\nimport {set, entries, createStore} from './thirdparty/idb-keyval.js';\n\n(function setupGlobalStorage() {\n    if(window.PhStore){\n        console.error(`window.PhStore already setup. Ignoring.`);\n        return;\n    }\n    const EVENT_CHANGED = \"change\";\n    const FIRST_BOOT_TIME = \"firstBootTime\";\n    let storageNodeConnector;\n    let _testKey;\n    let nodeStoragePhoenixApis = {};\n    const isBrowser = !Phoenix.isNativeApp;\n    const isDesktop = Phoenix.isNativeApp;\n    const PHSTORE_DB = \"PhStore\";\n    const PHSTORE_STORE_NAME = \"KVStore\";\n    let idbStore;\n\n    function _getIDBStorage() {\n        if(!idbStore){\n            idbStore = createStore(PHSTORE_DB, PHSTORE_STORE_NAME);\n        }\n        return idbStore;\n    }\n\n    const PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME = \"ph-storage\";\n    const EXTERNAL_CHANGE_BROADCAST_INTERVAL = 500;\n    // Since this is a sync API, performance is critical. So we use a memory map in cache. This limits the size\n    // of what can be stored in this storage as if fully in memory.\n    const CHANGE_TYPE_EXTERNAL = \"External\",\n        CHANGE_TYPE_INTERNAL = \"Internal\";\n    const MGS_CHANGE = 'change';\n    let cache = {};\n    // map from watched keys that was set in this instance to\n    // modified time and value - key->{t,v}\n    let pendingBroadcastKV = {},\n        watchExternalKeys = {}; // boolean map\n\n    function commitExternalChanges(changedKV) {\n        for(let key of Object.keys(changedKV)){\n            // we only update the key and trigger if the key is being watched here.\n            // If unwatched keys are updated from another window, for eg, theme change pulled in from a new\n            // theme installed in another window cannot be applied in this window. So the code has to\n            // explicitly support external changes by calling watchExternalChanges API.\n            if(watchExternalKeys[key]) {\n                const externalChange = changedKV[key]; // {t,v} in new value, t = changed time\n                // if the change time of the external event we got is more recent than what we have,\n                // only then accept the change. else we have more recent data.\n                if(!cache[key] || (externalChange.t > cache[key].t)) {\n                    cache[key] = externalChange;\n                    PhStore.trigger(key, CHANGE_TYPE_EXTERNAL);\n                }\n            }\n        }\n    }\n\n    if(isDesktop){\n        const STORAGE_NODE_CONNECTOR_ID = \"ph_storage\";\n        storageNodeConnector = window.PhNodeEngine.createNodeConnector(\n            STORAGE_NODE_CONNECTOR_ID, nodeStoragePhoenixApis);\n        window._tauriBootVarsPromise.then(()=>{\n            storageNodeConnector.execPeer(\"openDB\", window._tauriBootVars.appLocalDir);\n        });\n        if(Phoenix.isTestWindow) {\n            window.storageNodeConnector = storageNodeConnector;\n        }\n        storageNodeConnector.on(EVENT_CHANGED, (_evt, changedKV)=>{\n            commitExternalChanges(changedKV);\n        });\n    }\n\n    if(isBrowser) {\n        const storageChannel = new BroadcastChannel(PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME);\n        setInterval(()=>{\n            // broadcast all changes made to watched keys in this instance to others\n            storageChannel.postMessage({type: MGS_CHANGE, keys: pendingBroadcastKV});\n            pendingBroadcastKV = {};\n\n        }, EXTERNAL_CHANGE_BROADCAST_INTERVAL);\n        // Listen for messages on the channel\n        storageChannel.onmessage = (event) => {\n            const message = event.data;\n            if(message.type === MGS_CHANGE){\n                commitExternalChanges(message.keys);\n            }\n        };\n    }\n\n    /**\n     * Retrieves the value associated with the specified key from the browser's local storage.\n     *\n     * @param {string} key - The key to retrieve the value for.\n     * @returns {string|number|boolean|object|null} - The value associated with the specified key. Returns null if the key does not exist.\n     */\n    function getItem(key) {\n        let cachedResult = cache[key];\n        if(cachedResult && cachedResult.v){\n            return JSON.parse(cachedResult.v);\n        }\n        // once we load the db dump from file, we dont ever touch the storage apis again for\n        // get operations. This is because in, the get operation is async (via node or indexedDB). in future,\n        // we can write a async refresh key api to update values that has been cached if the need arises.\n        // but rn, there is no need for the same as every phoenix instance will use its own cached storage\n        // that guarantees read after write constancy within an instance, and for external changes, use watch.\n        return null;\n    }\n\n    const MINUTES_10 = 10*1000;\n    let errorCountReported = 0, sendOnceMore = false, noFurtherReporting = false;\n    function _reportPutItemError(err) {\n        // in bugsnag, we get errors from a few users(line 2-3 users), who might likely have crashed\n        // phnode and dont know how to kill the process and the window is still open in back for several\n        // days(send 22+days). This was being caught every minute and reported in bugsnag which\n        // generates like 20K+ reports per user per month. So we only report error once in an hour.\n        if(window.debugMode){\n            console.error(err);\n        }\n        const logger = window.logger;\n        if(!logger || noFurtherReporting){\n            return;\n        }\n        // we only report 1 error once to prevent too many Bugsnag reports. We seen in bugsnag that like 2-3\n        // users triggers thousands of this error in bugsnag report per day as they send continuous error reports\n        // every minute due to this error. We throttle to send only 2 errors to bugsnag any minute at app level,\n        // so this will starve other genuine errors as well if not captured here.\n        errorCountReported ++;\n        if(sendOnceMore){\n            // we send the crash stack once and then another report 10 minutes later. After that, this is likely\n            // to fail always.\n            noFurtherReporting = true;\n            logger.reportError(err,\n                `${errorCountReported} tauri:storage:setItem failures in ${MINUTES_10/1000} minutes`);\n        }\n        if(errorCountReported !== 1){\n            return;\n        }\n        logger.reportError(err);\n        setTimeout(()=>{\n            sendOnceMore = true;\n        }, MINUTES_10);\n    }\n\n    /**\n     * Sets the value of a specified key in the localStorage.\n     *\n     * @param {string} key - The key to set the value for.\n     * @param {string|number|boolean|object} value - The value to be stored. Can be any valid JSON serializable data type.\n     *\n     */\n    function setItem(key, value) {\n        const valueToStore = {\n            t: Date.now(), // modified time\n            // we store value as string here as during get operation, we can use json.parse to clone instead of\n            // using slower structured object clone.\n            v: JSON.stringify(value)\n        };\n        if(!Phoenix.isTestWindow || key === _testKey) {\n            if(isDesktop) {\n                storageNodeConnector\n                    .execPeer(\"putItem\", {key, value: valueToStore})\n                    .catch(_reportPutItemError);\n                // this is an in-memory tauri store that takes care of multi window case, since we have a single\n                // instance, all windows share this and can reconstruct the full view from the dumb file + this map\n                // when the editor boots up instead of having to write the dump file frequently.\n                window.__TAURI__.invoke('put_item', { key, value: JSON.stringify(valueToStore) });\n            }\n            if(window.debugMode || isBrowser) {\n                // in debug mode, we write to browser storage in tauri and browser builds for eazy debug of storage.\n                set(key, valueToStore, _getIDBStorage());\n            }\n        }\n        cache[key] = valueToStore;\n        if(watchExternalKeys[key] && isBrowser){\n            // Broadcast channel is only used in browser, in tauri with multiple tauri process windows,\n            // BroadcastChnnel wont work. So we poll LMDB for changes in tauri.\n            pendingBroadcastKV[key] = valueToStore;\n        }\n        PhStore.trigger(key, CHANGE_TYPE_INTERNAL);\n    }\n\n    /**\n     * Removes an item from storage. This will trigger a change notification on removal if watchers are attached.\n     * Watchers are unaffected on removal, you will still get notifications if the key gets created in the future.\n     *\n     * @param {string} key - The key to remove\n     */\n    function removeItem(key) {\n        setItem(key, null);\n    }\n\n    /**\n     * Enables best effort monitoring of external changes to the specified key when there are multiple Phoenix\n     * windows/instances. By default, PhStore.on(<key name>, fn) only triggers for key value changes within\n     * the current instance. Calling this function will activate change events when changes occur in other\n     * instances as well. Note that this is a best effort service, there may be eventual consistent delays of\n     * up to 1 second or the event may not be received at all.\n     *\n     * @param {string} key - The key to observe changes for.\n     */\n\n    function watchExternalChanges(key) {\n        watchExternalKeys[key] = true;\n        if(isDesktop && (!Phoenix.isTestWindow || key === _testKey)) {\n            const t = (cache[key] && cache[key].t ) || 0;\n            storageNodeConnector.execPeer(\"watchExternalChanges\", {key, t});\n        }\n    }\n\n    /**\n     * If there are multiple phoenix windows/instances, This function will stop watching changes\n     * made by other phoenix instances for this key.\n     *\n     * @param {string} key - The key for which changes are being observed.\n     */\n    function unwatchExternalChanges(key) {\n        delete watchExternalKeys[key];\n        if(isDesktop && (!Phoenix.isTestWindow || key === _testKey)) {\n            storageNodeConnector.execPeer(\"unwatchExternalChanges\", key);\n        }\n    }\n\n    function setupFirstBoot() {\n        try{\n            const firstBootTime = getItem(FIRST_BOOT_TIME);\n            if(!firstBootTime){\n                window.Phoenix.firstBoot = true;\n                setItem(FIRST_BOOT_TIME, Date.now());\n            }\n            // legacy first boot. can be removed after sep 2024\n            // this was the original thing we used before we migrated to phStore.\n            let legacyKey = \"healthData.firstUseDay\";\n            if(localStorage.getItem(legacyKey)){\n                window.Phoenix.firstBoot = false;\n            }\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    const storageReadyPromise = new Promise((resolve) => {\n        if(Phoenix.isTestWindow){\n            // in test window, we will always use blank storage to init.\n            resolve();\n            return;\n        }\n        if(isDesktop){\n            async function mergeTauriInMemoryStorage() {\n                // The tauri storeage is mainly used in multi window case, where if there are 2+ windows, each window\n                // is till live and has not commited the dump file to disc(they only do that on exit or 30 every secs).\n                // so the dump file may be stale after window._tauriStorageRestorePromise in the case.\n                // we merge the local memory cache maintained at tauri rust side to address this.\n                try {\n                    const map = await window.__TAURI__.invoke('get_all_items') || {};\n                    for(const key of Object.keys(map)){\n                        cache[key] = JSON.parse(map[key]);\n                    }\n                } catch (e) {\n                    console.error(e);\n                }\n                // we never fail, boot with blank storage\n                setupFirstBoot();\n                resolve();\n            }\n            // In tauri, we have to read it from app local data dump(which is usually written at app close time. This\n            // will help the storage to quick start from a json dump instead of waiting for node to boot up and init lmdb)\n            window._tauriStorageRestorePromise\n                .then((jsonData)=>{\n                    if(jsonData){\n                        cache = JSON.parse(jsonData);\n                    }\n                })\n                .catch(console.error)\n                .finally(mergeTauriInMemoryStorage);\n            return;\n        }\n        // Use browser default storage- IndexedDB\n        entries(_getIDBStorage())\n            .then(kvArrayAll=>{\n                for(let kvArray of kvArrayAll) {\n                    // Get all entries in the store. Each entry is an array of [key, value].\n                    // Eg: [[123, 456], ['hello', 'world']]\n                    cache[kvArray[0]] = kvArray[1];\n                }\n            })\n            .catch(console.error)\n            .finally(()=>{\n                setupFirstBoot();\n                resolve();\n            }); // we never fail, boot with blank storage\n    });\n    const _PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY = \"desktopZoomScale\";\n\n    storageReadyPromise\n        .then(()=>{\n            // do things to do that are critical to user experience here\n            // We try to set window zoom as early as possible to prevent zoom flicker\n            const zoomFactor = PhStore.getItem(_PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY) || 1;\n            if(Phoenix.isNativeApp){\n                window.__TAURI__.tauri.invoke(\"zoom_window\", {scaleFactor: zoomFactor});\n            }\n        });\n    /**\n     * Waits till all pending changes are written to disk. This will not trigger a flush operation, but just waits\n     * on db to flush all operations to disk that has happened till this call.\n     * @returns {Promise<void>|Promise|*}\n     */\n    async function flushDB() {\n        if(isDesktop) {\n            // since node connector web socket messages are queued, sending this message will only execute after all\n            // outstanding messages are sent to node with web socket.\n            await storageNodeConnector.execPeer(\"flushDB\");\n        }\n    }\n\n    /**\n     * Very expensive call!!! Ensures that on next reboot, the database will be in the state when this function\n     * was executed. `flushDB` API only works in the case of proper exit, ie, if phoenix crashes in between, the db\n     * contents may not be written to disc. This call will guarentee write to disk at this instant.\n     * @returns {Promise<void>}\n     */\n    async function persistDBForReboot() {\n        if(isDesktop) {\n            // since node connector web socket messages are queued, sending this message will only execute after all\n            // outstanding messages are sent to node with web socket.\n            await storageNodeConnector.execPeer(\"dumpDBToFile\");\n        }\n    }\n\n    const PhStore = {\n        getItem,\n        setItem,\n        removeItem,\n        flushDB,\n        persistDBForReboot,\n        watchExternalChanges,\n        unwatchExternalChanges,\n        storageReadyPromise,\n        // private APIs\n        _storageBootstrapTime: Date.now() - Phoenix.startTime,\n        _PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY,\n        CHANGE_TYPE_INTERNAL,\n        CHANGE_TYPE_EXTERNAL\n    };\n    if(Phoenix.isTestWindow) {\n        PhStore._setTestKey = function (testKey) {\n            _testKey = testKey;\n        };\n    }\n    EventDispatcher.makeEventDispatcher(PhStore);\n    window.PhStore = PhStore;\n}());\n"],"file":"storage.js"}
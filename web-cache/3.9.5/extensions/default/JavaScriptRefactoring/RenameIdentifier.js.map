{"version":3,"sources":["extensions/default/JavaScriptRefactoring/RenameIdentifier.js"],"names":["define","require","exports","module","EditorManager","brackets","getModule","ScopeManager","Session","MessageIds","JSON","parse","TokenUtils","Strings","Keys","Editor","ProjectManager","session","keywords","MARK_TYPE_RENAME","initializeSession","editor","getRefs","fileInfo","offset","postMessage","type","TERN_REFS","addPendingRequest","name","requestFindRefs","document","path","file","fullPath","ternPromise","promise","TERN_FILE_INFO_TYPE_FULL","offsetLines","text","filterText","getJavascriptText","handleRename","getActiveEditor","token","getSelections","length","displayErrorMessageAtCursor","ERROR_RENAME_MULTICURSOR","getModeForSelection","getTokenAt","_codeMirror","posFromIndex","getOffset","indexOf","string","ERROR_RENAME_GENERAL","result","$","Deferred","isInSameFile","obj","refsResp","projectRoot","getProjectRoot","projectDir","fileName","slice","_multiFileRename","refs","_isCursorWithinMark","cursorPos","marker","pos","find","from","to","line","ch","_outlineText","currentEditor","selections","primary","getSelection","markText","start","end","getMarkOptionRenameOutline","off","EVENT_BEFORE_SELECTION_CHANGE","EVENT_CURSOR_ACTIVITY","EVENT_KEY_DOWN","on","_evt","newSelections","ranges","clearAllMarks","mainCursor","getCursorPos","primaryMark","getAllMarks","setCursorPos","_editor","keyboardEvent","key","KEY","RETURN","ENTER","preventDefault","stopPropagation","handleFindRefs","references","inlineWidget","getFocusedInlineWidget","isInTextRange","item","_startLine","_endLine","ERROR_RENAME_QUICKEDIT","currentPosition","refsArray","primaryRef","filter","element","setSelections","requestFindReferences","response","hasOwnProperty","done","fail","errorMsg","reject","_MARK_TYPE_RENAME"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    const EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        ScopeManager         = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session              = brackets.getModule(\"JSUtils/Session\"),\n        MessageIds           = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        Strings              = brackets.getModule(\"strings\"),\n        Keys                 = brackets.getModule(\"command/Keys\"),\n        Editor               = brackets.getModule(\"editor/Editor\").Editor,\n        ProjectManager       = brackets.getModule(\"project/ProjectManager\");\n\n    let session             = null,  // object that encapsulates the current session state\n        keywords = [\"define\", \"alert\", \"exports\", \"require\", \"module\", \"arguments\"];\n\n    const MARK_TYPE_RENAME = \"renameVar\";\n\n    //Create new session\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    //Post message to tern node domain that will request tern server to find refs\n    function getRefs(fileInfo, offset) {\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_REFS,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_REFS);\n    }\n\n    //Create info required to find reference\n    function requestFindRefs(session, document, offset) {\n        if (!document || !session) {\n            return;\n        }\n        let path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n        let ternPromise = getRefs(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    //Do rename of identifier which is at cursor\n    function handleRename() {\n        let editor = EditorManager.getActiveEditor(),\n            offset, token;\n\n        if (!editor) {\n            return;\n        }\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_MULTICURSOR);\n            return;\n        }\n        initializeSession(editor);\n\n\n        if (!editor || editor.getModeForSelection() !== \"javascript\") {\n            return;\n        }\n\n        token = TokenUtils.getTokenAt(editor._codeMirror, editor._codeMirror.posFromIndex(session.getOffset()));\n\n        if (keywords.indexOf(token.string) >= 0) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_GENERAL);\n            return;\n        }\n\n        let result = new $.Deferred();\n\n        function isInSameFile(obj, refsResp) {\n            let projectRoot = ProjectManager.getProjectRoot(),\n                projectDir,\n                fileName = \"\";\n            if (projectRoot) {\n                projectDir = projectRoot.fullPath;\n            }\n\n            // get the relative path of File as Tern can also return\n            // references with file name as a relative path wrt projectRoot\n            // so refernce file name will be compared with both relative and absolute path to check if it is same file\n            if (projectDir && refsResp && refsResp.file && refsResp.file.indexOf(projectDir) === 0) {\n                fileName = refsResp.file.slice(projectDir.length);\n            }\n            // In case of unsaved files, After renameing once Tern is returning filename without forward slash\n            return (obj && (obj.file === refsResp.file || obj.file === fileName\n                            || obj.file === refsResp.file.slice(1, refsResp.file.length)));\n        }\n\n        function _multiFileRename(refs) {\n            // TODO: Multi file rename here\n            // note that before we enable this, we should load tern with the full code base to identify all\n            // references properly. This sadly needs refactoring the current tern integration heavily\n        }\n\n        function _isCursorWithinMark(cursorPos, marker) {\n            if(!marker){\n                return false;\n            }\n            // Get the position of the marker\n            var pos = marker.find();\n            if (!pos) {return false;} // The marker doesn't cover any range\n\n            // Check if the cursor is within the mark's range\n            var from = pos.from, to = pos.to;\n            // Check if cursor line is between the start and end lines\n            if (cursorPos.line < from.line || cursorPos.line > to.line) {\n                return false;\n            }\n            // If cursor is on the same line as the start or end, check the character position\n            if (cursorPos.line === from.line && cursorPos.ch < from.ch) {\n                return false;\n            }\n            if (cursorPos.line === to.line && cursorPos.ch > to.ch) {\n                return false;\n            }\n\n            return true; // The cursor is within the mark\n        }\n\n\n        function _outlineText(currentEditor) {\n            let selections = currentEditor.getSelections();\n            if(selections.length > 1 ){\n                let primary = currentEditor.getSelection();\n                currentEditor.markText(MARK_TYPE_RENAME, primary.start, primary.end, Editor.getMarkOptionRenameOutline());\n                currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                currentEditor.off(Editor.EVENT_CURSOR_ACTIVITY + \".renameVar\");\n                currentEditor.off(Editor.EVENT_KEY_DOWN + \".renameVar\");\n                currentEditor.on(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\", function (_evt, newSelections) {\n                    if(newSelections.ranges && newSelections.ranges.length === 1) {\n                        currentEditor.clearAllMarks(MARK_TYPE_RENAME);\n                        currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                    }\n                });\n                currentEditor.on(Editor.EVENT_CURSOR_ACTIVITY + \".renameVar\", function (_evt, newSelections) {\n                    const mainCursor = currentEditor.getCursorPos();\n                    let primaryMark = currentEditor.getAllMarks(MARK_TYPE_RENAME);\n                    primaryMark = primaryMark && primaryMark[0];\n                    if(primaryMark && !_isCursorWithinMark(mainCursor, primaryMark)) {\n                        currentEditor.clearAllMarks(MARK_TYPE_RENAME);\n                        currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                        currentEditor.setCursorPos(mainCursor.line, mainCursor.ch);\n                    }\n                });\n                currentEditor.on(Editor.EVENT_KEY_DOWN + \".renameVar\", function (_evt, _editor, keyboardEvent) {\n                    const mainCursor = currentEditor.getCursorPos();\n                    let primaryMark = currentEditor.getAllMarks(MARK_TYPE_RENAME);\n                    primaryMark = primaryMark && primaryMark[0];\n                    if(primaryMark && (keyboardEvent.key === Keys.KEY.RETURN || keyboardEvent.key === Keys.KEY.ENTER)){\n                        currentEditor.clearAllMarks(MARK_TYPE_RENAME);\n                        currentEditor.off(Editor.EVENT_KEY_DOWN + \".renameVar\");\n                        currentEditor.setCursorPos(mainCursor.line, mainCursor.ch);\n                        keyboardEvent.preventDefault();\n                        keyboardEvent.stopPropagation();\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if references are in this file only\n         * If yes then select all references\n         */\n        function handleFindRefs (refsResp) {\n            if (!refsResp || !refsResp.references || !refsResp.references.refs) {\n                return;\n            }\n\n            let inlineWidget = EditorManager.getFocusedInlineWidget(),\n                editor = EditorManager.getActiveEditor(),\n                refs = refsResp.references.refs;\n\n            //In case of inline widget if some references are outside widget's text range then don't allow for rename\n            if (inlineWidget) {\n                let isInTextRange  = !refs.find(function(item) {\n                    return (item.start.line < inlineWidget._startLine || item.end.line > inlineWidget._endLine);\n                });\n\n                if (!isInTextRange) {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_QUICKEDIT);\n                    return;\n                }\n            }\n\n            let currentPosition = editor.posFromIndex(refsResp.offset),\n                refsArray;\n            refsArray = refs.filter(function (element) {\n                return isInSameFile(element, refsResp);\n            });\n            if (refsArray.length !== refs.length) {\n                // There are references across multiple files, we are not ready to handle this yet\n                _multiFileRename(refs);\n                return;\n            }\n\n            // Finding the Primary Reference in Array\n            let primaryRef = refsArray.find(function (element) {\n                return ((element.start.line === currentPosition.line || element.end.line === currentPosition.line)\n                        && currentPosition.ch <= element.end.ch && currentPosition.ch >= element.start.ch);\n            });\n            // Setting the primary flag of Primary Refence to true\n            primaryRef.primary = true;\n\n            editor.setSelections(refsArray);\n            _outlineText(editor);\n        }\n\n        /**\n         * Make a find ref request.\n         * @param {Session} session - the session\n         * @param {number} offset - the offset of where to jump from\n         */\n        function requestFindReferences(session, offset) {\n            let response = requestFindRefs(session, session.editor.document, offset);\n\n            if (response && response.hasOwnProperty(\"promise\")) {\n                response.promise.done(handleFindRefs).fail(function (errorMsg) {\n                    EditorManager.getActiveEditor().displayErrorMessageAtCursor(errorMsg);\n                    result.reject();\n                });\n            }\n        }\n\n        offset = session.getOffset();\n        requestFindReferences(session, offset);\n\n        return result.promise();\n    }\n\n    // for tests\n    exports._MARK_TYPE_RENAME = MARK_TYPE_RENAME;\n\n    // public api\n    exports.handleRename = handleRename;\n});\n"],"file":"RenameIdentifier.js"}
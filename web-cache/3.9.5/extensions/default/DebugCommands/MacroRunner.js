define(function(require,exports,module){const FileViewController=brackets.getModule("project/FileViewController"),CommandManager=brackets.getModule("command/CommandManager"),EditorManager=brackets.getModule("editor/EditorManager"),KeyEvent=brackets.getModule("utils/KeyEvent"),Commands=brackets.getModule("command/Commands"),PreferencesManager=brackets.getModule("preferences/PreferencesManager"),Editor=brackets.getModule("editor/Editor"),_=brackets.getModule("thirdparty/lodash"),ProjectManager=brackets.getModule("project/ProjectManager");function openFile(filePath){if(filePath.startsWith("/"))return jsPromise(FileViewController.openFileAndAddToWorkingSet(filePath));const projectFilePath=path.join(ProjectManager.getProjectRoot().fullPath,filePath);return jsPromise(FileViewController.openFileAndAddToWorkingSet(projectFilePath))}function setCursors(selections){const activeEditor=EditorManager.getActiveEditor();if(!activeEditor)throw new Error(`No active editor found to set cursor at: ${selections}`);const parsedSelections=selections.map(selection=>{const parts=selection.split("-");if(1===parts.length){const[line,ch]=parts[0].split(":").map(Number);if(isNaN(line)||isNaN(ch))throw new Error(`Invalid cursor format: ${parts[0]} for ${selections}`);return{start:{line:line-1,ch:ch-1},end:{line:line-1,ch:ch-1}}}if(2===parts.length){const[fromLine,fromCh]=parts[0].split(":").map(Number),[toLine,toCh]=parts[1].split(":").map(Number);if(isNaN(fromLine)||isNaN(fromCh)||isNaN(toLine)||isNaN(toCh))throw new Error(`Invalid selection range format: ${selection}`);return{start:{line:fromLine-1,ch:fromCh-1},end:{line:toLine-1,ch:toCh-1}}}throw new Error(`Invalid format: ${selection}`)});activeEditor.setSelections(parsedSelections)}function computeCursors(editor,addQuotes){const selections=editor.getSelections();return selections.map(selection=>{const start=selection.start,end=selection.end;let cursor;return cursor=start.line===end.line&&start.ch===end.ch?`${start.line+1}:${start.ch+1}`:`${start.line+1}:${start.ch+1}-${end.line+1}:${end.ch+1}`,addQuotes?`"${cursor}"`:cursor})}function expectCursorsToBe(expectedSelections){const activeEditor=EditorManager.getActiveEditor();if(!activeEditor)throw new Error(`No active editor found for expectCursorsToBe: ${expectedSelections}`);const currentSelections=computeCursors(activeEditor);if(currentSelections.length!==expectedSelections.length)throw new Error(`expectCursorsToBe: [${expectedSelections.join(", ")}] `+`but got [${currentSelections.join(", ")}]`);for(let i=0;i<currentSelections.length;i++)if(!currentSelections.includes(`${expectedSelections[i]}`)||!expectedSelections.includes(currentSelections[i]))throw new Error(`expectCursorsToBe: [${expectedSelections.join(", ")}] `+`but got [${currentSelections.join(", ")}]`)}function raiseKeyEvent(key,event,element,options){const doc=element.ownerDocument;void 0===options?options={view:doc.defaultView,bubbles:!0,cancelable:!0,keyIdentifer:key}:(options.view=doc.defaultView,options.bubbles=!0,options.cancelable=!0,options.keyIdentifier=key);const oEvent=new KeyboardEvent(event,options);"keydown"===event||"keyup"===event||"keypress"===event?(Object.defineProperty(oEvent,"keyCode",{get:function(){return this.keyCodeVal}}),Object.defineProperty(oEvent,"which",{get:function(){return this.keyCodeVal}}),Object.defineProperty(oEvent,"charCode",{get:function(){return this.keyCodeVal}}),oEvent.keyCodeVal=key,oEvent.keyCode!==key&&console.log("SpecRunnerUtils.simulateKeyEvent() - keyCode mismatch: "+oEvent.keyCode),element.dispatchEvent(oEvent)):console.log("SpecRunnerUtils.simulateKeyEvent() - unsupported keyevent: "+event)}function keydown(keysArray,modifiers){for(let key of keysArray){if("string"==typeof key&&(key.startsWith("DOM_VK_")||(key="DOM_VK_"+key),!(key=KeyEvent[key])))throw new Error(`Invalid key "${key}"`);raiseKeyEvent(key,"keydown",document.activeElement,modifiers)}}function typeAtCursor(text,origin){const activeEditor=EditorManager.getActiveEditor();if(!activeEditor)throw new Error(`No active editor found to typeAtCursor: ${text}`);const selections=activeEditor.getSelections();for(let selection of selections)activeEditor.replaceRange(text,selection.start,selection.end,origin)}function _toPos(posString){const pos=posString.split(":");return{line:Number(pos[0])-1,ch:Number(pos[1])-1}}function validateText(text,selection){const activeEditor=EditorManager.getActiveEditor();if(!activeEditor)throw new Error(`No active editor found to validateText: ${text} at selection ${selection}`);const from=selection.split("-")[0],to=selection.split("-")[1],selectedText=activeEditor.getTextBetween(_toPos(from),_toPos(to));if(selectedText!==text)throw new Error(`validateText: expected text at [${selection}] to be "${text}" but got "${selectedText}"`)}function _getMarkLocations(markType,whichAPI,selections){const activeEditor=EditorManager.getActiveEditor();if(!activeEditor)throw new Error(`No active editor found to ${whichAPI}: "${markType}" for selection "${selections}"`);const marks=activeEditor.getAllMarks(markType),marksLocations=[];for(let mark of marks){const loc=mark.find();marksLocations.push(`${loc.from.line+1}:${loc.from.ch+1}-${loc.to.line+1}:${loc.to.ch+1}`)}return marksLocations}function validateAllMarks(markType,selections){const marksLocations=_getMarkLocations(markType,"validateAllMarks",selections);if(!selections||marksLocations.length!==selections.length)throw new Error(`validateAllMarks expected marks "${markType}" at: [${selections&&selections.join(", ")}] `+`but got marked locations [${marksLocations.join(", ")}]`);for(let i=0;i<selections.length;i++)if(!selections.includes(`${marksLocations[i]}`)||!marksLocations.includes(selections[i]))throw new Error(`validateAllMarks expected marks "${markType}" at: [${selections.join(", ")}] `+`but got marked locations [${marksLocations.join(", ")}]`)}function validateEqual(obj1,obj2){if(!_.isEqual(obj1,obj2))throw new Error(`validateEqual: expected ${JSON.stringify(obj1)} to equal ${JSON.stringify(obj2)}`)}function validateMarks(markType,selections,totalMarkCount){const marksLocations=_getMarkLocations(markType,"validateMarks",selections);if(selections){if(void 0!==totalMarkCount&&marksLocations.length!==totalMarkCount)throw new Error(`validateMarks expected mark count for "${markType}" to be: ${totalMarkCount} `+`but got ${marksLocations.length}`);for(let selection of selections)if(!marksLocations.includes(selection))throw new Error(`validateMarks expected marks "${markType}" to be at: [${selections.join(", ")}] `+`but got marked locations [${marksLocations.join(", ")}]`)}}function closeFile(){return jsPromise(CommandManager.execute(Commands.FILE_CLOSE,{_forceClose:!0}))}function closeAll(){return jsPromise(CommandManager.execute(Commands.FILE_CLOSE_ALL,{_forceClose:!0}))}function execCommand(commandID,args){return jsPromise(CommandManager.execute(commandID,args))}function undo(){return execCommand(Commands.EDIT_UNDO)}function redo(){return execCommand(Commands.EDIT_REDO)}function setPreference(key,value){PreferencesManager.set(key,value)}function getPreference(key){return PreferencesManager.get(key)}const EDITING={setEditorSpacing:function(useTabs,spaceOrTabCount,isAutoMode){const activeEditor=EditorManager.getActiveEditor();if(!activeEditor)throw new Error("No active editor found to setEditorSpacing");const fullPath=activeEditor.document.file.fullPath;Editor.Editor.getAutoTabSpaces(fullPath)!==isAutoMode&&(Editor.Editor.setAutoTabSpaces(isAutoMode,fullPath),isAutoMode&&Editor.Editor._autoDetectTabSpaces(activeEditor,!0,!0)),Editor.Editor.setUseTabChar(useTabs,fullPath),useTabs?Editor.Editor.setTabSize(spaceOrTabCount,fullPath):Editor.Editor.setSpaceUnits(spaceOrTabCount,fullPath)}},__PR={openFile:openFile,setCursors:setCursors,expectCursorsToBe:expectCursorsToBe,keydown:keydown,typeAtCursor:typeAtCursor,validateText:validateText,validateAllMarks:validateAllMarks,validateMarks:validateMarks,closeFile:closeFile,closeAll:closeAll,undo:undo,redo:redo,setPreference:setPreference,getPreference:getPreference,validateEqual:validateEqual,EDITING:EDITING};async function runMacro(macroText){let errors=[];try{const AsyncFunction=async function(){}.constructor,macroAsync=new AsyncFunction("__PR","KeyEvent",macroText);await macroAsync(__PR,KeyEvent)}catch(e){console.error("Error executing macro: ",macroText,e),errors.push({lineNo:0,line:"",errorCode:"ERROR_EXEC",errorText:`${e}`})}return errors}Phoenix.isTestWindow&&(window.__PR=__PR),exports.computeCursors=computeCursors,exports.runMacro=runMacro});
//# sourceMappingURL=MacroRunner.js.map

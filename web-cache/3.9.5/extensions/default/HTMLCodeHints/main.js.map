{"version":3,"sources":["extensions/default/HTMLCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","HTMLUtils","PreferencesManager","Strings","NewFileContentManager","CSSUtils","StringMatch","LiveDevelopment","KeyEvent","Metrics","HTMLTags","HTMLAttributes","HTMLTemplate","XHTMLTemplate","tags","attributes","TagHints","this","exclusion","AttrHints","globalAttributes","readGlobalAttrHints","cachedHints","definePreference","description","DESCRIPTION_HTML_TAG_HINTS","DESCRIPTION_ATTR_HINTS","prototype","updateExclusion","textAfterCursor","tagInfo","tagName","substr","position","offset","hasValidExclusion","hasHints","editor","implicitChar","pos","getCursorPos","getTagInfo","tokenType","TAG_NAME","getHints","query","result","slice","hints","$","map","value","key","indexOf","sort","match","selectInitial","handleWideResults","insertHint","completion","start","line","ch","end","cursor","charCount","length","document","replaceRange","global","MAX_CLASS_HINTS","formatHints","basicMatchSort","splice","token","$hintObj","label","text","addClass","stringRanges","forEach","item","matched","append","attr","_getAllClassHints","queryStr","segments","split","deferred","Deferred","getAllCssSelectorsInProject","includeClasses","scanCurrentHtml","then","pvalue","includes","stringMatch","preferPrefixMatches","validHints","alreadyMatched","resolve","catch","console","error","_getValueHintsForAttr","attrName","tagPlusAttr","attrInfo","type","attribOption","attrNameOnly","ATTR_NAME","name","ATTR_VALUE","HISTORY_PREFIX","hintSessionId","isInLiveHighlightSession","NewDocContentProvider","CONTENT_PROVIDER_NAME","onClose","restoreHistoryPoint","onHighlight","$highlightedEl","_$descriptionElem","reason","currentLivePreviewDetails","getLivePreviewDetails","liveDocument","currentlyEditedFile","file","fullPath","livePreviewedFile","doc","source","SELECTION_REASON","SESSION_START","createHistoryRestorePoint","KEYBOARD_NAV","event","keyCode","DOM_VK_UP","DOM_VK_DOWN","DOM_VK_PAGE_UP","DOM_VK_PAGE_DOWN","countEvent","EVENT_TYPE","LIVE_PREVIEW","$hintItem","find","highligtedValue","data","is","_dontDismissPopupOnScroll","Array","i","foundPrefix","tag","usedAttr","getTagAttributes","filter","unfiltered","concat","grep","inArray","assert","Object","hasOwnProperty","done","asyncHints","resolveWith","isLiveHighlight","insertedName","replaceExistingOne","valueAssigned","endQuote","shouldReplace","positionWithinAttributeVal","textBeforeCursor","lastSegment","hasEndQuote","quoteChar","hasSelection","initialOffset","firstSegment","setSelection","replaceSelection","setCursorPos","getContent","fileName","Promise","reject","endsWith","appReady","JSON","parse","tagHints","attrHints","newDocContentProvider","registerHintProvider","registerContentProvider","tagHintProvider","attrHintProvider"],"mappings":"AAqBAA,OAAO,SAAUC,QAASC,QAASC,QAE/BF,QAAQ,iBAGR,MAAMG,QAAsBC,SAASC,UAAU,iBAC3CC,gBAAsBF,SAASC,UAAU,0BACzCE,UAAsBH,SAASC,UAAU,sBACzCG,mBAAsBJ,SAASC,UAAU,kCACzCI,QAAsBL,SAASC,UAAU,WACzCK,sBAAwBN,SAASC,UAAU,kCAC3CM,SAAsBP,SAASC,UAAU,qBACzCO,YAAsBR,SAASC,UAAU,qBACzCQ,gBAAsBT,SAASC,UAAU,wBACzCS,SAAsBV,SAASC,UAAU,kBACzCU,QAAsBX,SAASC,UAAU,iBACzCW,SAAsBhB,QAAQ,sBAC9BiB,eAAsBjB,QAAQ,4BAC9BkB,aAAsBlB,QAAQ,sBAC9BmB,cAAsBnB,QAAQ,uBAIlC,IAAIoB,KACAC,WAaJ,SAASC,WACLC,KAAKC,UAAY,KAsJrB,SAASC,YACLF,KAAKG,iBAAmBH,KAAKI,sBAC7BJ,KAAKK,YAAc,KACnBL,KAAKC,UAAY,GA1KrBxB,QAAQ,eAKRQ,mBAAmBqB,iBAAiB,oBAAqB,WAAW,EAAM,CACtEC,YAAarB,QAAQsB,6BAGzBvB,mBAAmBqB,iBAAiB,qBAAsB,WAAW,EAAM,CACvEC,YAAarB,QAAQuB,yBAczBV,SAASW,UAAUC,gBAAkB,WACjC,IAAIC,gBACAZ,KAAKC,WAAaD,KAAKa,UACvBD,gBAAkBZ,KAAKa,QAAQC,QAAQC,OAAOf,KAAKa,QAAQG,SAASC,QAC/DlC,gBAAgBmC,kBAAkBlB,KAAKC,UAAWW,mBACnDZ,KAAKC,UAAY,QAsB7BF,SAASW,UAAUS,SAAW,SAAUC,OAAQC,cAC5C,IAAIC,IAAMF,OAAOG,eAIjB,OAFAvB,KAAKa,QAAU7B,UAAUwC,WAAWJ,OAAQE,KAC5CtB,KAAKoB,OAASA,OACO,OAAjBC,aACIrB,KAAKa,QAAQG,SAASS,YAAczC,UAAU0C,UAC1C1B,KAAKa,QAAQG,SAASC,QAAU,IACK,IAAjCjB,KAAKa,QAAQG,SAASC,OACtBjB,KAAKC,UAAYD,KAAKa,QAAQC,QAE9Bd,KAAKW,mBAEF,GAKE,MAAjBU,eACArB,KAAKC,UAAYD,KAAKa,QAAQC,SACvB,IAyBff,SAASW,UAAUiB,SAAW,SAAUN,cACpC,IAAIO,MACAC,OAGJ,OADA7B,KAAKa,QAAU7B,UAAUwC,WAAWxB,KAAKoB,OAAQpB,KAAKoB,OAAOG,gBACzDvB,KAAKa,QAAQG,SAASS,YAAczC,UAAU0C,UAC1C1B,KAAKa,QAAQG,SAASC,QAAU,GAChCjB,KAAKW,kBACLiB,MAAQ5B,KAAKa,QAAQC,QAAQgB,MAAM,EAAG9B,KAAKa,QAAQG,SAASC,QAOrD,CACHc,MAPJF,OAASG,EAAEC,IAAIpC,KAAM,SAAUqC,MAAOC,KAClC,GAA2B,IAAvBA,IAAIC,QAAQR,OACZ,OAAOO,MAEZE,OAICC,MAAOV,MACPW,eAAe,EACfC,mBAAmB,IAKxB,MAaXzC,SAASW,UAAU+B,WAAa,SAAUC,YACtC,IAAIC,MAAQ,CAACC,MAAO,EAAGC,IAAK,GACxBC,IAAM,CAACF,MAAO,EAAGC,IAAK,GACtBE,OAAS/C,KAAKoB,OAAOG,eACrByB,UAAY,EAEhB,GAAIhD,KAAKa,QAAQG,SAASS,YAAczC,UAAU0C,SAAU,CACxD,IAAId,gBAAkBZ,KAAKa,QAAQC,QAAQC,OAAOf,KAAKa,QAAQG,SAASC,QAEpE+B,UADAjE,gBAAgBmC,kBAAkBlB,KAAKC,UAAWW,iBACtCZ,KAAKa,QAAQG,SAASC,OAEtBjB,KAAKa,QAAQC,QAAQmC,OAiBzC,OAbAH,IAAIF,KAAOD,MAAMC,KAAOG,OAAOH,KAC/BD,MAAME,GAAKE,OAAOF,GAAK7C,KAAKa,QAAQG,SAASC,OAC7C6B,IAAID,GAAKF,MAAME,GAAKG,WAEhBhD,KAAKC,WAAayC,aAAe1C,KAAKa,QAAQC,WAC1C6B,MAAME,KAAOC,IAAID,GACjB7C,KAAKoB,OAAO8B,SAASC,aAAaT,WAAYC,MAAOG,KAErD9C,KAAKoB,OAAO8B,SAASC,aAAaT,WAAYC,OAElD3C,KAAKC,UAAY,OAGd,GAiBXC,UAAUQ,UAAUN,oBAAsB,WACtC,OAAO4B,EAAEC,IAAInC,WAAY,SAAUoC,MAAOC,KACtC,GAAqB,SAAjBD,MAAMkB,OACN,OAAOjB,OAKnB,MAAMkB,gBAAkB,IACxB,SAASC,YAAYvB,OAKjB,OAJA1C,YAAYkE,eAAexB,OACxBA,MAAMkB,OAASI,kBACdtB,MAAQA,MAAMyB,OAAO,EAAGH,kBAErBtB,MAAME,IAAI,SAAUwB,OACvB,IAAIC,SAAW1B,qBAAqByB,MAAME,OAASF,MAAMvB,OAASuB,MAAMG,iBAAiBC,SAAS,sCAiBlG,OAdIJ,MAAMK,aACNL,MAAMK,aAAaC,QAAQ,SAAUC,MAC7BA,KAAKC,QACLP,SAASQ,OAAOlC,EAAE,UACb4B,KAAKI,KAAKJ,MACVC,SAAS,iBAEdH,SAASQ,OAAOF,KAAKJ,QAI7BF,SAASE,KAAKH,MAAME,OAExBD,SAASS,KAAK,WAAYV,MAAME,OACzBD,WAIf,SAASU,kBAAkBxC,OACvB,IAAIyC,SAAWzC,MAAMyC,SAErB,MAAMC,SAAWD,SAASE,MAAM,KAChCF,SAAWC,SAASA,SAASrB,OAAO,GACpC,MAAMuB,SAAWxC,EAAEyC,WAanB,OAZArF,SAASsF,4BAA4B,CAACC,gBAAgB,EAAMC,iBAAiB,IAAOC,KAAK9C,QACrF,MAAMF,OAASG,EAAEC,IAAIF,MAAO,SAAU+C,QAElC,QADAA,OAASA,OAAOhD,MAAM,KACRgD,OAAOC,SAAS,MAAQD,OAAOC,SAAS,OAASD,OAAOC,SAAS,KACpE,KAEH1F,YAAY2F,YAAYF,OAAQT,SAAU,CAAEY,qBAAqB,MAEvEC,WAAa5B,YAAYzB,QAC/BqD,WAAWC,gBAAiB,EAC5BX,SAASY,QAAQF,cAClBG,MAAMC,QAAQC,OACVf,SAkBXtE,UAAUQ,UAAU8E,sBAAwB,SAAU5D,MAAOd,QAAS2E,UAMlE,IAAI1D,MAAQ,GAEZ,GAAgB,UAAb0D,SACC,OAAOrB,kBAAkBxC,OAG7B,IAAI8D,YACAC,SAAW7F,WADGgB,QAAU,IAAM2E,WACQ3F,WAAW2F,UAUrD,OARIE,WACsB,YAAlBA,SAASC,KACT7D,MAAQ,CAAC,QAAS,QACX4D,SAASE,eAChB9D,MAAQ4D,SAASE,eAIlB9D,OAWX7B,UAAUQ,UAAUC,gBAAkB,SAAUmF,cAC5C,GAAI9F,KAAKC,WAAaD,KAAKa,QAAS,CAChC,IAAIY,UAAYzB,KAAKa,QAAQG,SAASS,UAClCR,OAASjB,KAAKa,QAAQG,SAASC,OAC/BL,gBAEAa,YAAczC,UAAU+G,UACxBnF,gBAAkBZ,KAAKa,QAAQsD,KAAK6B,KAAKjF,OAAOE,QACxC6E,cAAgBrE,YAAczC,UAAUiH,aAChDrF,gBAAkBZ,KAAKa,QAAQsD,KAAKjC,MAAMnB,OAAOE,SAEhDlC,gBAAgBmC,kBAAkBlB,KAAKC,UAAWW,mBACnDZ,KAAKC,UAAY,QAK7B,MAAMiG,eAAiB,gBACvB,IAAIC,cAAgB,EAAGC,0BAA2B,EAyXlD,SAASC,wBACLrG,KAAKsG,sBAAwB,gBAxXjCpG,UAAUQ,UAAU6F,QAAU,WACvBH,2BACCpG,KAAKoB,OAAOoF,oCAAwCL,iBACpDC,0BAA2B,GAE/BD,iBAGJjG,UAAUQ,UAAU+F,YAAc,SAAUC,eAAgBC,kBAAmBC,QAC3E,IAAIA,OAGA,OAFAtB,QAAQC,MAAM,gEACdY,gBAGJ,MAAM1E,UAAYzB,KAAKa,QAAQG,SAASS,UAClCoF,0BAA4BvH,gBAAgBwH,wBAClD,IAAKD,4BAA6BA,0BAA0BE,cACnDtF,YAAczC,UAAUiH,YAAyC,UAA3BjG,KAAKa,QAAQsD,KAAK6B,KAE7D,OAEJ,MAAMgB,oBAAsBhH,KAAKoB,OAAO8B,SAAS+D,KAAKC,SAChDC,kBAAoBN,0BAA0BE,aAAaK,IAAIH,KAAKC,SAC1E,GAAGF,sBAAwBG,kBAEvB,OAEJ,GAAGP,OAAOS,SAAWtI,gBAAgBuI,iBAAiBC,cAGlD,OAFApB,qBACAnG,KAAKoB,OAAOoG,0CAA8CrB,iBAG9D,GAAGS,OAAOS,SAAWtI,gBAAgBuI,iBAAiBG,aAClD,OAEJ,MAAMC,MAAQd,OAAOc,MACrB,GAAKA,MAAMC,UAAYpI,SAASqI,WAC5BF,MAAMC,UAAYpI,SAASsI,aAC3BH,MAAMC,UAAYpI,SAASuI,gBAC3BJ,MAAMC,UAAYpI,SAASwI,iBAC3B,OAEJvI,QAAQwI,WAAWxI,QAAQyI,WAAWC,aAAc,gBAAiB,WACrE,MAAMC,UAAYzB,eAAe0B,KAAK,wBAChCC,gBAAkB3B,eAAe0B,KAAK,wBAAwBE,KAAK,OACrED,iBAAoBF,UAAUI,GAAG,cAGrCnC,0BAA2B,EAC3BpG,KAAKoB,OAAOoH,4BACZxI,KAAKoB,OAAOoF,oCAAwCL,iBACpDnG,KAAKyC,WAAWiE,eAAe0B,KAAK,yBAAyB,KAoBjElI,UAAUQ,UAAUS,SAAW,SAAUC,OAAQC,cAC7C,IAAIC,IAAMF,OAAOG,eACbE,UACAR,OACAW,MAMJ,GAJA5B,KAAKoB,OAASA,OACdpB,KAAKa,QAAU7B,UAAUwC,WAAWJ,OAAQE,KAC5CG,UAAYzB,KAAKa,QAAQG,SAASS,UAClCR,OAASjB,KAAKa,QAAQG,SAASC,OACV,OAAjBI,aAAuB,CAGvB,GAFAO,MAAQ,KAEJH,YAAczC,UAAU+G,UACpB9E,QAAU,IACVW,MAAQ5B,KAAKa,QAAQsD,KAAK6B,KAAKlE,MAAM,EAAGb,cAEzC,GAAIQ,YAAczC,UAAUiH,WAAY,CAEvCrE,MADA5B,KAAKa,QAAQG,SAASC,QAAU,EACxBjB,KAAKa,QAAQsD,KAAKjC,MAAMJ,MAAM,EAAGb,QAKjC,GAIZ,MAAMwE,SAAWzF,KAAKa,QAAQsD,KAAK6B,KACnC,GAAIP,UAAyB,UAAbA,SAAsB,CAClC,IAAI1D,MAAQ/B,KAAKwF,sBAAsB,CAACnB,SAAUzC,OAC9C5B,KAAKa,QAAQC,QAAS2E,UAC1B,GAAI1D,iBAAiB0G,MAAO,CAExB,IAAIC,EAAGC,aAAc,EACrB,IAAKD,EAAI,EAAGA,EAAI3G,MAAMkB,OAAQyF,IAC1B,GAAgC,IAA5B3G,MAAM2G,GAAGtG,QAAQR,OAAc,CAC/B+G,aAAc,EACd,MAGHA,cACD/G,MAAQ,QAcxB,OARIX,QAAU,IACNQ,YAAczC,UAAU+G,WAAwB,IAAX9E,OACrCjB,KAAKC,UAAYD,KAAKa,QAAQsD,KAAK6B,KAEnChG,KAAKW,iBAAgB,IAIZ,OAAViB,MAEX,OAAqB,MAAjBP,cAAyC,MAAjBA,cACC,MAAjBA,cAA0C,MAAjBA,gBAC7BI,YAAczC,UAAU+G,YACxB/F,KAAKC,UAAYD,KAAKa,QAAQsD,KAAK6B,OAEhC,IAyBf9F,UAAUQ,UAAUiB,SAAW,SAAUN,cACrC,IAAI0B,OAAS/C,KAAKoB,OAAOG,eACrBK,MAAQ,CAACyC,SAAU,MACnB5C,UACAR,OACAY,OAAS,GA2Bb,GAzBA7B,KAAKa,QAAU7B,UAAUwC,WAAWxB,KAAKoB,OAAQ2B,QACjDtB,UAAYzB,KAAKa,QAAQG,SAASS,UAClCR,OAASjB,KAAKa,QAAQG,SAASC,OAC3BQ,YAAczC,UAAU+G,WAAatE,YAAczC,UAAUiH,aAC7DrE,MAAMgH,IAAM5I,KAAKa,QAAQC,QAErBG,QAAU,GACNQ,YAAczC,UAAU+G,UACxBnE,MAAMyC,SAAWrE,KAAKa,QAAQsD,KAAK6B,KAAKlE,MAAM,EAAGb,SAEjDW,MAAMyC,SAAWrE,KAAKa,QAAQsD,KAAKjC,MAAMJ,MAAM,EAAGb,QAClDW,MAAM6D,SAAWzF,KAAKa,QAAQsD,KAAK6B,MAEvChG,KAAKW,iBAAgB,IACdc,YAAczC,UAAUiH,aAI/BrE,MAAMyC,SAAW,GACjBzC,MAAM6D,SAAWzF,KAAKa,QAAQsD,KAAK6B,MAGvCpE,MAAMiH,SAAW7J,UAAU8J,iBAAiB9I,KAAKoB,OAAQ2B,SAGzDnB,MAAMgH,KAA0B,OAAnBhH,MAAMyC,SAAmB,CACtC,IAAIvD,QAAUc,MAAMgH,IAChBnD,SAAW7D,MAAM6D,SACjBsD,OAASnH,MAAMyC,SACf2E,WAAa,GACbjH,MAWJ,GATI0D,SACA1D,MAAQ/B,KAAKwF,sBAAsB5D,MAAOd,QAAS2E,UAC5C5F,MAAQA,KAAKiB,UAAYjB,KAAKiB,SAAShB,aAC9CkJ,WAAanJ,KAAKiB,SAAShB,WAAWmJ,OAAOjJ,KAAKG,kBAClD4B,MAAQC,EAAEkH,KAAKF,WAAY,SAAU7E,KAAMuE,GACvC,OAAO1G,EAAEmH,QAAQhF,KAAMvC,MAAMiH,UAAY,KAI7C9G,iBAAiB0G,OAAS1G,MAAMkB,OAOhC,OANAqC,QAAQ8D,QAAQvH,OAAOoB,QAMhB,CACHlB,MANJF,OAASG,EAAEC,IAAIF,MAAO,SAAUiC,MAC5B,GAA6B,IAAzBA,KAAK5B,QAAQ2G,QACb,OAAO/E,OAEZ3B,OAGCC,MAAOV,MAAMyC,SACb9B,eAAe,EACfC,mBAAmB,GAEpB,GAAIT,iBAAiBsH,QAAUtH,MAAMuH,eAAe,QAAS,CAChE,IAAI9E,SAAWxC,EAAEyC,WASjB,OARA1C,MAAMwH,KAAK,SAAUC,YACjBhF,SAASiF,YAAYzJ,KAAM,CAAC,CACxB+B,MAAOyH,WACPlH,MAAOkH,WAAWrE,eAAgB,KAAMvD,MAAMyC,SAC9C9B,eAAe,EACfC,mBAAmB,OAGpBgC,SAEX,OAAO,OAiBftE,UAAUQ,UAAU+B,WAAa,SAAUC,WAAYgH,iBACnD,IAAI3G,OAAS/C,KAAKoB,OAAOG,eACrBoB,MAAQ,CAACC,MAAO,EAAGC,IAAK,GACxBC,IAAM,CAACF,MAAO,EAAGC,IAAK,GACtBpB,UAAYzB,KAAKa,QAAQG,SAASS,UAClCR,OAASjB,KAAKa,QAAQG,SAASC,OAC/B+B,UAAY,EACZ2G,cAAe,EACfC,mBAAqB5J,KAAKa,QAAQsD,KAAK0F,cACvCC,SAAW,GACXC,eAAgB,EAChBC,4BAA6B,EAC7BpJ,gBAEJ,GAAIa,YAAczC,UAAU+G,UACxBnF,gBAAkBZ,KAAKa,QAAQsD,KAAK6B,KAAKjF,OAAOE,QAC5ClC,gBAAgBmC,kBAAkBlB,KAAKC,UAAWW,kBAClDoC,UAAY/B,OACZ2I,oBAAqB,GAErB5G,UAAYhD,KAAKa,QAAQsD,KAAK6B,KAAK/C,QAIlC2G,oBAAsB9J,YAAcA,WAAW4C,aACZ,SAAhC5C,WAAW4C,YAAYkD,MAC3BlD,YAAc,MACdiH,cAAe,GACRjH,aAAe1C,KAAKa,QAAQsD,KAAK6B,OACxC+D,eAAgB,QAEjB,GAAItI,YAAczC,UAAUiH,WAAY,CAY3C,GAXArF,gBAAkBZ,KAAKa,QAAQsD,KAAKjC,MAAMnB,OAAOE,QAC7ClC,gBAAgBmC,kBAAkBlB,KAAKC,UAAWW,kBAClDoC,UAAY/B,OAIZjB,KAAKC,UAAY,MAEjB+C,UAAYhD,KAAKa,QAAQsD,KAAKjC,MAAMe,OAGV,UAA3BjD,KAAKa,QAAQsD,KAAK6B,KAAkB,CAEnCtD,WAAaA,WAAW4F,KAAK,OAE7B,MAAM2B,iBAAmBjK,KAAKa,QAAQsD,KAAKjC,MAAMJ,MAAM,EAAGb,QAC1D,IAAIiJ,YAAcD,iBAAiB1F,MAAM,KAGzCvB,UADA/B,QADAiJ,YAAcA,YAAYA,YAAYjH,OAAO,IACxBA,OAErB+G,4BAA6B,EAG5BhK,KAAKa,QAAQsD,KAAKgG,YAOZzH,aAAe1C,KAAKa,QAAQsD,KAAKjC,QACxC6H,eAAgB,IAPhBD,SAAW9J,KAAKa,QAAQsD,KAAKiG,WAEzB1H,YAAcoH,SACI,IAAX7I,SACPyB,WAAa,IAAOA,WAAa,KAW7C,GAJAI,IAAIF,KAAOD,MAAMC,KAAOG,OAAOH,KAC/BD,MAAME,GAAKE,OAAOF,GAAK5B,OACvB6B,IAAID,GAAKF,MAAME,GAAKG,UAEjB0G,gBAAiB,CAEhB,IAAI1J,KAAKoB,OAAOiJ,eAAe,CAC3B,MAAMC,cAAgBtK,KAAKa,QAAQG,SAASC,OAE5C,IAAIsJ,cADJ3J,gBAAkBZ,KAAKa,QAAQsD,KAAKjC,MAAMnB,OAAOuJ,gBACd/F,MAAM,KACzCgG,aAAeA,aAAa,GAC5BzH,IAAID,GAAKC,IAAID,GAAK0H,aAAatH,OAC/BjD,KAAKoB,OAAOoJ,aAAa7H,MAAOG,KAGpC,OADA9C,KAAKoB,OAAOqJ,iBAAiB/H,WAAY,SAAU,cAC5C,EAUX,GANG0D,2BAECA,0BAA2B,EAC3BD,iBAGDnG,KAAKoB,OAAOiJ,eAGX,OADArK,KAAKoB,OAAOqJ,iBAAiB/H,WAAY,QAClC,EAWX,GARIqH,gBACIpH,MAAME,KAAOC,IAAID,GACjB7C,KAAKoB,OAAO8B,SAASC,aAAaT,WAAYC,MAAOG,KAErD9C,KAAKoB,OAAO8B,SAASC,aAAaT,WAAYC,QAInDqH,2BACChK,KAAKoB,OAAOsJ,aAAa/H,MAAMC,KAAMD,MAAME,GAAKH,WAAWO,YAExD,CAAA,GAAI0G,aAKP,OAJA3J,KAAKoB,OAAOsJ,aAAa/H,MAAMC,KAAMD,MAAME,GAAKH,WAAWO,OAAS,IAI7D,EACAxB,YAAczC,UAAUiH,YAAcjG,KAAKa,QAAQsD,KAAKgG,aAE/DnK,KAAKoB,OAAOsJ,aAAa/H,MAAMC,KAAMD,MAAME,GAAKH,WAAWO,OAAS,GAGxE,OAAO,GAUXoD,sBAAsB3F,UAAUiK,WAAa,SAASC,UAClD,OAAO,IAAIC,QAAQ,CAACzF,QAAS0F,UACtBF,SAASG,SAAS,UACjB3F,QAAQxF,eAGZwF,QAAQzF,iBAIhBf,QAAQoM,SAAS,WAEbnL,KAAOoL,KAAKC,MAAMzL,UAClBK,WAAamL,KAAKC,MAAMxL,gBAGxB,IAAIyL,SAAW,IAAIpL,SACfqL,UAAY,IAAIlL,UAChBmL,sBAAwB,IAAIhF,sBAChCtH,gBAAgBuM,qBAAqBH,SAAU,CAAC,QAAS,GACzDpM,gBAAgBuM,qBAAqBF,UAAW,CAAC,QAAS,GAC1DjM,sBAAsBoM,wBAAwBF,sBAAuB,CAAC,QAAS,GAG/E3M,QAAQ8M,gBAAkBL,SAC1BzM,QAAQ+M,iBAAmBL","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n    require(\"HTMLJumpToDef\");\n\n    // Load dependent modules\n    const AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        HTMLUtils           = brackets.getModule(\"language/HTMLUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings             = brackets.getModule(\"strings\"),\n        NewFileContentManager = brackets.getModule(\"features/NewFileContentManager\"),\n        CSSUtils            = brackets.getModule(\"language/CSSUtils\"),\n        StringMatch         = brackets.getModule(\"utils/StringMatch\"),\n        LiveDevelopment     = brackets.getModule(\"LiveDevelopment/main\"),\n        KeyEvent            = brackets.getModule(\"utils/KeyEvent\"),\n        Metrics             = brackets.getModule(\"utils/Metrics\"),\n        HTMLTags            = require(\"text!HtmlTags.json\"),\n        HTMLAttributes      = require(\"text!HtmlAttributes.json\"),\n        HTMLTemplate        = require(\"text!template.html\"),\n        XHTMLTemplate       = require(\"text!template.xhtml\");\n\n    require(\"./html-lint\");\n\n    let tags,\n        attributes;\n\n    PreferencesManager.definePreference(\"codehint.TagHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_HTML_TAG_HINTS\n    });\n\n    PreferencesManager.definePreference(\"codehint.AttrHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_ATTR_HINTS\n    });\n\n    /**\n     * @constructor\n     */\n    function TagHints() {\n        this.exclusion = null;\n    }\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     */\n    TagHints.prototype.updateExclusion = function () {\n        var textAfterCursor;\n        if (this.exclusion && this.tagInfo) {\n            textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML tag hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    TagHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos();\n\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        this.editor = editor;\n        if (implicitChar === null) {\n            if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n                if (this.tagInfo.position.offset >= 0) {\n                    if (this.tagInfo.position.offset === 0) {\n                        this.exclusion = this.tagInfo.tagName;\n                    } else {\n                        this.updateExclusion();\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (implicitChar === \"<\") {\n            this.exclusion = this.tagInfo.tagName;\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML tag hints if possible for the current\n     * editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    TagHints.prototype.getHints = function (implicitChar) {\n        var query,\n            result;\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, this.editor.getCursorPos());\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            if (this.tagInfo.position.offset >= 0) {\n                this.updateExclusion();\n                query = this.tagInfo.tagName.slice(0, this.tagInfo.position.offset);\n                result = $.map(tags, function (value, key) {\n                    if (key.indexOf(query) === 0) {\n                        return key;\n                    }\n                }).sort();\n\n                return {\n                    hints: result,\n                    match: query,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Inserts a given HTML tag hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    TagHints.prototype.insertHint = function (completion) {\n        var start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            cursor = this.editor.getCursorPos(),\n            charCount = 0;\n\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            var textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = this.tagInfo.position.offset;\n            } else {\n                charCount = this.tagInfo.tagName.length;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - this.tagInfo.position.offset;\n        end.ch = start.ch + charCount;\n\n        if (this.exclusion || completion !== this.tagInfo.tagName) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n            this.exclusion = null;\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function AttrHints() {\n        this.globalAttributes = this.readGlobalAttrHints();\n        this.cachedHints = null;\n        this.exclusion = \"\";\n    }\n\n    /**\n     * @private\n     * Parse the code hints from JSON data and extract all hints from property names.\n     * @return {!Array.<string>} An array of code hints read from the JSON data source.\n     */\n    AttrHints.prototype.readGlobalAttrHints = function () {\n        return $.map(attributes, function (value, key) {\n            if (value.global === \"true\") {\n                return key;\n            }\n        });\n    };\n\n    const MAX_CLASS_HINTS = 250;\n    function formatHints(hints) {\n        StringMatch.basicMatchSort(hints);\n        if(hints.length > MAX_CLASS_HINTS) {\n            hints = hints.splice(0, MAX_CLASS_HINTS);\n        }\n        return hints.map(function (token) {\n            let $hintObj = $(`<span data-val='${token.label || token.value || token.text}'></span>`).addClass(\"brackets-html-hints brackets-hints\");\n\n            // highlight the matched portion of each hint\n            if (token.stringRanges) {\n                token.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hintObj.append($(\"<span>\")\n                            .text(item.text)\n                            .addClass(\"matched-hint\"));\n                    } else {\n                        $hintObj.append(item.text);\n                    }\n                });\n            } else {\n                $hintObj.text(token.label);\n            }\n            $hintObj.attr(\"data-val\", token.label);\n            return $hintObj;\n        });\n    }\n\n    function _getAllClassHints(query) {\n        let queryStr = query.queryStr;\n        // \"class1 class2\" have multiple classes. the last part is the query to hint\n        const segments = queryStr.split(\" \");\n        queryStr = segments[segments.length-1];\n        const deferred = $.Deferred();\n        CSSUtils.getAllCssSelectorsInProject({includeClasses: true, scanCurrentHtml: true}).then(hints=>{\n            const result = $.map(hints, function (pvalue) {\n                pvalue = pvalue.slice(1); // remove.\n                if(!pvalue || pvalue.includes(\"#\") || pvalue.includes(\"\\\\\") || pvalue.includes(\"/\")){\n                    return null;\n                }\n                return  StringMatch.stringMatch(pvalue, queryStr, { preferPrefixMatches: true });\n            });\n            const validHints = formatHints(result);\n            validHints.alreadyMatched = true;\n            deferred.resolve(validHints);\n        }).catch(console.error);\n        return deferred;\n    }\n\n    /**\n     * Helper function that determines the possible value hints for a given html tag/attribute name pair\n     *\n     * @param {{queryStr: string}} query\n     * The current query\n     *\n     * @param {string} tagName\n     * HTML tag name\n     *\n     * @param {string} attrName\n     * HTML attribute name\n     *\n     * @return {!Array.<string>|$.Deferred}\n     * The (possibly deferred) hints.\n     */\n    AttrHints.prototype._getValueHintsForAttr = function (query, tagName, attrName) {\n        // We look up attribute values with tagName plus a slash and attrName first.\n        // If the lookup fails, then we fall back to look up with attrName only. Most\n        // of the attributes in JSON are using attribute name only as their properties,\n        // but in some cases like \"type\" attribute, we have different properties like\n        // \"script/type\", \"link/type\" and \"button/type\".\n        var hints = [];\n\n        if(attrName === \"class\") {\n            return _getAllClassHints(query);\n        }\n\n        var tagPlusAttr = tagName + \"/\" + attrName,\n            attrInfo = attributes[tagPlusAttr] || attributes[attrName];\n\n        if (attrInfo) {\n            if (attrInfo.type === \"boolean\") {\n                hints = [\"false\", \"true\"];\n            } else if (attrInfo.attribOption) {\n                hints = attrInfo.attribOption;\n            }\n        }\n\n        return hints;\n    };\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} attrNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside an attribute name context.\n     * Otherwise, we also update exclusion for attribute value context.\n     */\n    AttrHints.prototype.updateExclusion = function (attrNameOnly) {\n        if (this.exclusion && this.tagInfo) {\n            var tokenType = this.tagInfo.position.tokenType,\n                offset = this.tagInfo.position.offset,\n                textAfterCursor;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            } else if (!attrNameOnly && tokenType === HTMLUtils.ATTR_VALUE) {\n                textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    const HISTORY_PREFIX = \"Live_hint_CSS\";\n    let hintSessionId = 0, isInLiveHighlightSession = false;\n\n    AttrHints.prototype.onClose = function () {\n        if(isInLiveHighlightSession) {\n            this.editor.restoreHistoryPoint(`${HISTORY_PREFIX}${hintSessionId}`);\n            isInLiveHighlightSession = false;\n        }\n        hintSessionId++;\n    };\n\n    AttrHints.prototype.onHighlight = function ($highlightedEl, _$descriptionElem, reason) {\n        if(!reason){\n            console.error(\"OnHighlight called without reason, should never happen!\");\n            hintSessionId++;\n            return;\n        }\n        const tokenType = this.tagInfo.position.tokenType;\n        const currentLivePreviewDetails = LiveDevelopment.getLivePreviewDetails();\n        if(!(currentLivePreviewDetails && currentLivePreviewDetails.liveDocument)\n            || !(tokenType === HTMLUtils.ATTR_VALUE && this.tagInfo.attr.name === \"class\")) {\n            // live hints only for live previewed page on class attribute values\n            return;\n        }\n        const currentlyEditedFile = this.editor.document.file.fullPath;\n        const livePreviewedFile = currentLivePreviewDetails.liveDocument.doc.file.fullPath;\n        if(currentlyEditedFile !== livePreviewedFile) {\n            // file is not current html file being live previewed. we dont show hints in the case\n            return;\n        }\n        if(reason.source === CodeHintManager.SELECTION_REASON.SESSION_START){\n            hintSessionId++;\n            this.editor.createHistoryRestorePoint(`${HISTORY_PREFIX}${hintSessionId}`);\n            return;\n        }\n        if(reason.source !== CodeHintManager.SELECTION_REASON.KEYBOARD_NAV){\n            return;\n        }\n        const event = reason.event;\n        if(!(event.keyCode === KeyEvent.DOM_VK_UP ||\n            event.keyCode === KeyEvent.DOM_VK_DOWN ||\n            event.keyCode === KeyEvent.DOM_VK_PAGE_UP ||\n            event.keyCode === KeyEvent.DOM_VK_PAGE_DOWN)){\n            return;\n        }\n        Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"htmlClassHint\", \"preview\");\n        const $hintItem = $highlightedEl.find(\".brackets-html-hints\");\n        const highligtedValue = $highlightedEl.find(\".brackets-html-hints\").data(\"val\");\n        if(!highligtedValue || !$hintItem.is(\":visible\")){\n            return;\n        }\n        isInLiveHighlightSession = true;\n        this.editor._dontDismissPopupOnScroll();\n        this.editor.restoreHistoryPoint(`${HISTORY_PREFIX}${hintSessionId}`);\n        this.insertHint($highlightedEl.find(\".brackets-html-hints\"), true);\n    };\n\n    /**\n     * Determines whether HTML attribute hints are available in the current\n     * editor context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    AttrHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos(),\n            tokenType,\n            offset,\n            query;\n\n        this.editor = editor;\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (implicitChar === null) {\n            query = null;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                if (offset >= 0) {\n                    query = this.tagInfo.attr.name.slice(0, offset);\n                }\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                if (this.tagInfo.position.offset >= 0) {\n                    query = this.tagInfo.attr.value.slice(0, offset);\n                } else {\n                    // We get negative offset for a quoted attribute value with some leading whitespaces\n                    // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                    // So just set the queryStr to an empty string.\n                    query = \"\";\n                }\n\n                // If we're at an attribute value, check if it's an attribute name that has hintable values.\n                const attrName = this.tagInfo.attr.name;\n                if (attrName && attrName !== \"class\") { // class hints are always computed later\n                    let hints = this._getValueHintsForAttr({queryStr: query},\n                        this.tagInfo.tagName, attrName);\n                    if (hints instanceof Array) {\n                        // If we got synchronous hints, check if we have something we'll actually use\n                        var i, foundPrefix = false;\n                        for (i = 0; i < hints.length; i++) {\n                            if (hints[i].indexOf(query) === 0) {\n                                foundPrefix = true;\n                                break;\n                            }\n                        }\n                        if (!foundPrefix) {\n                            query = null;\n                        }\n                    }\n                }\n            }\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME && offset === 0) {\n                    this.exclusion = this.tagInfo.attr.name;\n                } else {\n                    this.updateExclusion(false);\n                }\n            }\n\n            return query !== null;\n        }\n        if (implicitChar === \" \" || implicitChar === \"'\" ||\n                    implicitChar === \"\\\"\" || implicitChar === \"=\") {\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                this.exclusion = this.tagInfo.attr.name;\n            }\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML attribute hints if possible for the\n     * current editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    AttrHints.prototype.getHints = function (implicitChar) {\n        var cursor = this.editor.getCursorPos(),\n            query = {queryStr: null},\n            tokenType,\n            offset,\n            result = [];\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, cursor);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (tokenType === HTMLUtils.ATTR_NAME || tokenType === HTMLUtils.ATTR_VALUE) {\n            query.tag = this.tagInfo.tagName;\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME) {\n                    query.queryStr = this.tagInfo.attr.name.slice(0, offset);\n                } else {\n                    query.queryStr = this.tagInfo.attr.value.slice(0, offset);\n                    query.attrName = this.tagInfo.attr.name;\n                }\n                this.updateExclusion(false);\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                // We get negative offset for a quoted attribute value with some leading whitespaces\n                // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                // So just set the queryStr to an empty string.\n                query.queryStr = \"\";\n                query.attrName = this.tagInfo.attr.name;\n            }\n\n            query.usedAttr = HTMLUtils.getTagAttributes(this.editor, cursor);\n        }\n\n        if (query.tag && query.queryStr !== null) {\n            var tagName = query.tag,\n                attrName = query.attrName,\n                filter = query.queryStr,\n                unfiltered = [],\n                hints;\n\n            if (attrName) {\n                hints = this._getValueHintsForAttr(query, tagName, attrName);\n            } else if (tags && tags[tagName] && tags[tagName].attributes) {\n                unfiltered = tags[tagName].attributes.concat(this.globalAttributes);\n                hints = $.grep(unfiltered, function (attr, i) {\n                    return $.inArray(attr, query.usedAttr) < 0;\n                });\n            }\n\n            if (hints instanceof Array && hints.length) {\n                console.assert(!result.length);\n                result = $.map(hints, function (item) {\n                    if (item.indexOf(filter) === 0) {\n                        return item;\n                    }\n                }).sort();\n                return {\n                    hints: result,\n                    match: query.queryStr,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            } else if (hints instanceof Object && hints.hasOwnProperty(\"done\")) { // Deferred hints\n                var deferred = $.Deferred();\n                hints.done(function (asyncHints) {\n                    deferred.resolveWith(this, [{\n                        hints: asyncHints,\n                        match: asyncHints.alreadyMatched? null: query.queryStr,\n                        selectInitial: true,\n                        handleWideResults: false\n                    }]);\n                });\n                return deferred;\n            }\n            return null;\n\n        }\n\n\n    };\n\n    /**\n     * Inserts a given HTML attribute hint into the current editor context.\n     *\n     * @param {string} completion\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    AttrHints.prototype.insertHint = function (completion, isLiveHighlight) {\n        var cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            tokenType = this.tagInfo.position.tokenType,\n            offset = this.tagInfo.position.offset,\n            charCount = 0,\n            insertedName = false,\n            replaceExistingOne = this.tagInfo.attr.valueAssigned,\n            endQuote = \"\",\n            shouldReplace = true,\n            positionWithinAttributeVal = false,\n            textAfterCursor;\n\n        if (tokenType === HTMLUtils.ATTR_NAME) {\n            textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                replaceExistingOne = false;\n            } else {\n                charCount = this.tagInfo.attr.name.length;\n            }\n            // Append an equal sign and two double quotes if the current attr is not an empty attr\n            // and then adjust cursor location before the last quote that we just inserted.\n            if (!replaceExistingOne && attributes && attributes[completion] &&\n                    attributes[completion].type !== \"flag\") {\n                completion += \"=\\\"\\\"\";\n                insertedName = true;\n            } else if (completion === this.tagInfo.attr.name) {\n                shouldReplace = false;\n            }\n        } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n            textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                // Set exclusion to null only after attribute value insertion,\n                // not after attribute name insertion since we need to keep it\n                // for attribute value insertion.\n                this.exclusion = null;\n            } else {\n                charCount = this.tagInfo.attr.value.length;\n            }\n\n            if(this.tagInfo.attr.name === \"class\") {\n                // css class hints\n                completion = completion.data(\"val\");\n                // \"anotherClass class<cursor>name\" . completion = classics , we have to match a prefix after space\n                const textBeforeCursor = this.tagInfo.attr.value.slice(0, offset);\n                let lastSegment = textBeforeCursor.split(\" \");\n                lastSegment = lastSegment[lastSegment.length-1];\n                offset = lastSegment.length;\n                charCount = offset;\n                positionWithinAttributeVal = true;\n            }\n\n            if (!this.tagInfo.attr.hasEndQuote) {\n                endQuote = this.tagInfo.attr.quoteChar;\n                if (endQuote) {\n                    completion += endQuote;\n                } else if (offset === 0) {\n                    completion = \"\\\"\" + completion + \"\\\"\";\n                }\n            } else if (completion === this.tagInfo.attr.value) {\n                shouldReplace = false;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - offset;\n        end.ch = start.ch + charCount;\n\n        if(isLiveHighlight) {\n            // this is via user press up and down arrows when code hints is visible\n            if(!this.editor.hasSelection()){\n                const initialOffset = this.tagInfo.position.offset;\n                textAfterCursor = this.tagInfo.attr.value.substr(initialOffset);\n                let firstSegment = textAfterCursor.split(\" \");\n                firstSegment = firstSegment[0]; // \"name\"\n                end.ch = end.ch + firstSegment.length;\n                this.editor.setSelection(start, end);\n            }\n            this.editor.replaceSelection(completion, 'around', \"liveHints\");\n            return true;\n        }\n\n        // this is commit flow\n        if(isInLiveHighlightSession) {\n            // end previous highlight session.\n            isInLiveHighlightSession = false;\n            hintSessionId++;\n        }\n\n        if(this.editor.hasSelection()){\n            // this is when user commits in a live selection\n            this.editor.replaceSelection(completion, 'end');\n            return true;\n        }\n\n        if (shouldReplace) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n        }\n\n        if(positionWithinAttributeVal){\n            this.editor.setCursorPos(start.line, start.ch + completion.length);\n            // we're now inside the double-quotes we just inserted\n        } else if (insertedName) {\n            this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\n\n            // Since we're now inside the double-quotes we just inserted,\n            // immediately pop up the attribute value hint.\n            return true;\n        } else if (tokenType === HTMLUtils.ATTR_VALUE && this.tagInfo.attr.hasEndQuote) {\n            // Move the cursor to the right of the existing end quote after value insertion.\n            this.editor.setCursorPos(start.line, start.ch + completion.length + 1);\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function NewDocContentProvider() {\n        this.CONTENT_PROVIDER_NAME = \"HTMLCodeHints\";\n    }\n\n    NewDocContentProvider.prototype.getContent = function(fileName) {\n        return new Promise((resolve, reject)=>{\n            if(fileName.endsWith(\".xhtml\")){\n                resolve(XHTMLTemplate);\n                return;\n            }\n            resolve(HTMLTemplate);\n        });\n    };\n\n    AppInit.appReady(function () {\n        // Parse JSON files\n        tags = JSON.parse(HTMLTags);\n        attributes = JSON.parse(HTMLAttributes);\n\n        // Register code hint providers\n        let tagHints = new TagHints();\n        let attrHints = new AttrHints();\n        let newDocContentProvider = new NewDocContentProvider();\n        CodeHintManager.registerHintProvider(tagHints, [\"html\"], 0);\n        CodeHintManager.registerHintProvider(attrHints, [\"html\"], 0);\n        NewFileContentManager.registerContentProvider(newDocContentProvider, [\"html\"], 0);\n\n        // For unit testing\n        exports.tagHintProvider = tagHints;\n        exports.attrHintProvider = attrHints;\n    });\n});\n"],"file":"main.js"}
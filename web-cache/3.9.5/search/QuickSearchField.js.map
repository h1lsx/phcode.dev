{"version":3,"sources":["search/QuickSearchField.js"],"names":["define","require","exports","module","KeyEvent","PopUpManager","QuickSearchField","$input","options","this","$positionEl","maxResults","_handleInput","bind","_handleKeyDown","undefined","highlightZeroResults","_highlightZeroResults","on","_firstHighlightIndex","firstHighlightIndex","_dropdownTop","offset","top","height","verticalAdjust","prototype","_pending","_commitPending","_displayedQuery","_displayedResults","_highlightIndex","_$dropdown","valueAtEvent","val","self","setTimeout","updateResults","event","popupVisible","is","keyCode","DOM_VK_RETURN","stopPropagation","preventDefault","_doCommit","DOM_VK_DELETE","onDelete","DOM_VK_DOWN","length","_updateHighlight","DOM_VK_UP","index","item","onCommit","explicit","$items","find","removeClass","eq","addClass","onHighlight","query","results","resultProvider","done","fail","realResults","_render","_closeDropdown","remove","focusLastActiveElementOnClose","_$currentlyFocusedElement","focus","_openDropdown","htmlContent","$","document","activeElement","$positioningElement","appendTo","css","position","left","width","outerWidth","click","$item","target","closest","html","addPopUp","destroy","onDismiss","popupManagesFocus","error","hasOwnProperty","createdJqObj","count","Math","min","i","result","formatter","push","get","console","setText","value","off"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*\n * Text field with attached dropdown list that is updated (based on a provider) whenever the text changes.\n *\n * For styling, the DOM structure of the popup is as follows:\n *  body\n *      ol.quick-search-container\n *          li\n *          li.highlight\n *          li\n * And the text field is:\n *      input\n *      input.no-results\n */\ndefine(function (require, exports, module) {\n\n\n    const KeyEvent = require(\"utils/KeyEvent\"),\n        PopUpManager      = require(\"widgets/PopUpManager\");\n\n\n    /**\n     * Attaches to an existing <input> tag\n     *\n     * @constructor\n     *\n     * @param {!jQueryObject} $input\n     * @param {!function(string):($.Promise|Array.<*>|{error:?string}} options.resultProvider\n     *          Given the current search text, returns an an array of result objects, an error object, or a\n     *          Promise that yields one of those. If the Promise is still outstanding when the query next\n     *          changes, resultProvider() will be called again (without waiting for the earlier Promise), and\n     *          the Promise's result will be ignored.\n     *          If the provider yields [], or a non-null error string, input is decorated with \".no-results\"; if\n     *          the provider yields a null error string, input is not decorated.\n     *\n     * @param {!function(*, string):string} options.formatter\n     *          Converts one result object to a string of HTML text. Passed the item and the current query. The\n     *          outermost element must be <li>. The \".highlight\" class can be ignored as it is applied automatically.\n     * @param {!function(?*, string, number):void} options.onCommit\n     *          Called when an item is selected by clicking or pressing Enter. Passed the committed item and the current\n     *          query and its index. If the current result list is not up to date with the query text at the time Enter is\n     *          pressed, waits until it is before running this callback. If Enter pressed with no results, passed\n     *          null. The popup remains open after this event.\n     * @param {!function(*, string, boolean):void} options.onHighlight\n     *          Called when an item is highlighted in the list. Passed the item, the current query, and a flag that is\n     *          true if the item was highlighted explicitly (arrow keys), not simply due to a results list update. Since\n     *          the top item in the list is always initially highlighted, every time the list is updated onHighlight()\n     *          is called with the top item and with the explicit flag set to false.\n     * @param {!function(*):void} options.onDelete\n     *          Called when delete key is pressed on a selected item in the list. Passed the item.\n     * @param {!function():void} options.onDismiss\n     *          Called when popup is dismissed with escape key press. Popup is not usable after this point.\n     * @param {?number} options.maxResults\n     *          Maximum number of items from resultProvider() to display in the popup.\n     * @param {?number} options.verticalAdjust\n     *          Number of pixels to position the popup below where $input is when constructor is called. Useful\n     *          if UI is going to animate position after construction, but QuickSearchField may receive input\n     *          before the animation is done.\n     * @param {jQueryObject} options.$positionEl if provided, the popup will be positioned based on this\n     * @param {?number} options.firstHighlightIndex\n     *          Index of the result that is highlighted by default. null to not highlight any result.\n     * @param {?number} options.focusLastActiveElementOnClose if set to true, focuses the last active element on close.\n     *          By default, the editor is always focused.\n     *\n     */\n    function QuickSearchField($input, options) {\n        this.$input = $input;\n        this.options = options || {};\n        this.$positionEl = options.$positionEl;\n\n        options.maxResults = options.maxResults || 10;\n\n        this._handleInput   = this._handleInput.bind(this);\n        this._handleKeyDown = this._handleKeyDown.bind(this);\n\n        if (options.highlightZeroResults !== undefined) {\n            this._highlightZeroResults = options.highlightZeroResults;\n        } else {\n            this._highlightZeroResults = true;\n        }\n\n        $input.on(\"input\", this._handleInput);\n        $input.on(\"keydown\", this._handleKeyDown);\n\n        // For search History this value is set to null\n        this._firstHighlightIndex = options.firstHighlightIndex;\n\n        this._dropdownTop = $input.offset().top + $input.height() + (options.verticalAdjust || 0);\n    }\n\n    /** @type {!Object} */\n    QuickSearchField.prototype.options = null;\n\n    /** @type {?$.Promise} Promise corresponding to latest resultProvider call. Any earlier promises ignored */\n    QuickSearchField.prototype._pending = null;\n\n    /** @type {boolean} True if Enter already pressed & just waiting for results to arrive before committing */\n    QuickSearchField.prototype._commitPending = false;\n\n    /** @type {?string} Value of $input corresponding to the _displayedResults list */\n    QuickSearchField.prototype._displayedQuery = null;\n\n    /** @type {?Array.<*>}  Latest resultProvider result */\n    QuickSearchField.prototype._displayedResults = null;\n\n    /** @type {?number} */\n    QuickSearchField.prototype._highlightIndex = null;\n\n    /** @type {?jQueryObject} Dropdown's <ol>, while open; null while closed */\n    QuickSearchField.prototype._$dropdown = null;\n\n    /** @type {!jQueryObject} */\n    QuickSearchField.prototype.$input = null;\n\n    /** @type {!jQueryObject} */\n    QuickSearchField.prototype.$positionEl = null;\n\n\n    /** When text field changes, update results list */\n    QuickSearchField.prototype._handleInput = function () {\n        this._pending = null;  // immediately invalidate any previous Promise\n\n        var valueAtEvent = this.$input.val();\n        var self = this;\n        // The timeout lets us skip over a backlog of multiple keyboard events when the provider is responding\n        // so slowly that JS execution can't keep up. All the remaining input events are serviced before the\n        // first timeout runs; then all the queued-up timeouts run in a row. All except the last one can no-op.\n        setTimeout(function () {\n            if (self.$input && self.$input.val() === valueAtEvent) {\n                self.updateResults();\n            }\n        }, 0);\n    };\n\n    /** Handle special keys: Enter, Up/Down */\n    QuickSearchField.prototype._handleKeyDown = function (event) {\n        let popupVisible = false;\n        if(this._$dropdown && this._$dropdown.is(\":visible\")){\n            popupVisible = true;\n        }\n        if (event.keyCode === KeyEvent.DOM_VK_RETURN) {\n            // Enter should always act on the latest results. If input has changed and we're still waiting for\n            // new results, just flag the 'commit' for later\n            if (this._displayedQuery === this.$input.val()) {\n                event.stopPropagation();\n                event.preventDefault();  // prevents keyup from going to someone else after we close\n                this._doCommit();\n            } else {\n                // Once the current wait resolves, _render() will run the commit\n                this._commitPending = true;\n            }\n        } else if (event.keyCode === KeyEvent.DOM_VK_DELETE && popupVisible) {\n            if (this.options.onDelete && this._$dropdown && this._highlightIndex !== null) {\n                this.options.onDelete(this._highlightIndex);\n                this.updateResults();\n                event.stopPropagation();\n                event.preventDefault();\n            }\n            // if there is nothing selected, we should not preventDefault the delete key event as it\n            // will make delete key not work in the search text box text! Eg. Ctrl-shift-o, type text,\n            // press delete key to remove text chars will fail is we prevent default here without\n            // a valid selection.\n        } else if (event.keyCode === KeyEvent.DOM_VK_DOWN && popupVisible) {\n            // Highlight changes are always done synchronously on the currently shown result list. If the list\n            // later changes, the highlight is reset to the top\n            if (this._displayedResults && this._displayedResults.length) {\n                if (this._highlightIndex === null || this._highlightIndex === this._displayedResults.length - 1) {\n                    this._highlightIndex = 0;\n                } else {\n                    this._highlightIndex++;\n                }\n                this._updateHighlight(true);\n            }\n            event.stopPropagation();\n            event.preventDefault(); // treated as Home key otherwise\n\n        } else if (event.keyCode === KeyEvent.DOM_VK_UP && popupVisible) {\n            if (this._displayedResults && this._displayedResults.length) {\n                if (this._highlightIndex === null || this._highlightIndex === 0) {\n                    this._highlightIndex = this._displayedResults.length - 1;\n                } else {\n                    this._highlightIndex--;\n                }\n                this._updateHighlight(true);\n            }\n            event.preventDefault(); // treated as End key otherwise\n            event.stopPropagation();\n        }\n    };\n\n    /** Call onCommit() immediately */\n    QuickSearchField.prototype._doCommit = function (index) {\n        var item;\n        if (this._displayedResults && this._displayedResults.length) {\n            if (index >= 0) {\n                item = this._displayedResults[index];\n            } else if (this._highlightIndex >= 0) {\n                item = this._displayedResults[this._highlightIndex];\n            }\n        }\n        this.options.onCommit(item, this._displayedQuery, this._highlightIndex);\n    };\n\n    /** Update display to reflect value of _highlightIndex, & call onHighlight() */\n    QuickSearchField.prototype._updateHighlight = function (explicit) {\n        if (this._$dropdown) {\n            var $items = this._$dropdown.find(\"li\");\n            $items.removeClass(\"highlight\");\n            if (this._highlightIndex !== null) {\n                $items.eq(this._highlightIndex).addClass(\"highlight\");\n\n                this.options.onHighlight(this._displayedResults[this._highlightIndex], this.$input.val(), explicit);\n            }\n        }\n    };\n\n    /**\n     * Refresh the results dropdown, as if the user had changed the search text. Useful for providers that\n     * want to show cached data initially, then update the results with fresher data once available.\n     */\n    QuickSearchField.prototype.updateResults = function () {\n        this._pending = null;  // immediately invalidate any previous Promise\n\n        var query = this.$input.val();\n        var results = this.options.resultProvider(query);\n        if (results.done && results.fail) {\n            // Provider returned an async result - mark it as the latest Promise and if it's still latest when\n            // it resolves, render the results then\n            this._pending = results;\n            var self = this;\n            this._pending.done(function (realResults) {\n                if (self._pending === results) {\n                    self._render(realResults, query);\n                    this._pending = null;\n                }\n            });\n            if (this._pending) {\n                this._pending.fail(function () {\n                    if (self._pending === results) {\n                        self._render([], query);\n                        this._pending = null;\n                    }\n                });\n            }\n        } else {\n            // Synchronous result - render immediately\n            this._render(results, query);\n        }\n    };\n\n\n    /** Close dropdown result list if visible */\n    QuickSearchField.prototype._closeDropdown = function () {\n        if (this._$dropdown) {\n            this._$dropdown.remove();\n            this._$dropdown = null;\n        }\n        if(this.options.focusLastActiveElementOnClose && this._$currentlyFocusedElement\n         && this._$currentlyFocusedElement.is(\":visible\")) {\n            this._$currentlyFocusedElement.focus();\n        }\n    };\n\n    /**\n     * Open dropdown result list & populate with the given content\n     * @param {!string|jQueryObject} htmlContent\n     */\n    QuickSearchField.prototype._openDropdown = function (htmlContent) {\n        const self = this;\n        this._$currentlyFocusedElement = $(document.activeElement);\n        if (!this._$dropdown) {\n            let $positioningElement = this.$positionEl ? this.$positionEl : this.$input;\n            this._$dropdown = $(\"<ol class='quick-search-container'/>\").appendTo(\"body\")\n                .css({\n                    position: \"absolute\",\n                    top: this._dropdownTop,\n                    left: $positioningElement.offset().left,\n                    width: $positioningElement.outerWidth()\n                })\n                .click(function (event) {\n                    // Unlike the Enter key, where we wait to catch up with typing, clicking commits immediately\n                    var $item = $(event.target).closest(\"li\");\n                    if ($item.length) {\n                        self._doCommit($item.index());\n                    }\n                });\n        }\n        this._$dropdown.html(htmlContent);\n        PopUpManager.addPopUp(this._$dropdown, ()=>{\n            self.destroy();\n            if(self.options.onDismiss){\n                self.options.onDismiss();\n            }\n        }, true, {\n            popupManagesFocus: this.options.focusLastActiveElementOnClose\n        });\n    };\n\n    /**\n     * Given finished provider result, format it into HTML and show in dropdown, and update \"no-results\" style.\n     * If an Enter key commit was pending from earlier, process it now.\n     * @param {!Array.<*>} results\n     * @param {!string} query\n     */\n    QuickSearchField.prototype._render = function (results, query) {\n        this._displayedQuery = query;\n        this._displayedResults = results;\n        if (this._highlightIndex) {\n            if(this._highlightIndex >= results.length){\n                this._highlightIndex = results.length - 1;\n            }\n        } else if (this._firstHighlightIndex >= 0) {\n            this._highlightIndex = this._firstHighlightIndex;\n        } else {\n            this._highlightIndex = null;\n        }\n\n        if (results.error || results.length === 0) {\n            this._closeDropdown();\n            if (this._highlightZeroResults) {\n                this.$input.addClass(\"no-results\");\n            }\n        } else if (results.hasOwnProperty(\"error\")) {\n            // Error present but falsy - no results to show, but don't decorate with error style\n            this._closeDropdown();\n            if (this._highlightZeroResults) {\n                this.$input.removeClass(\"no-results\");\n            }\n        } else {\n            if (this._highlightZeroResults) {\n                this.$input.removeClass(\"no-results\");\n            }\n\n            const createdJqObj = $();\n            let count = Math.min(results.length, this.options.maxResults),\n                i;\n            for (i = 0; i < count; i++) {\n                const result = this.options.formatter(results[i], query);\n                if (typeof result === 'string') {\n                    createdJqObj.push($(result).get(0));\n                } else if (result instanceof $) {\n                    createdJqObj.push(result.get(0));\n                } else {\n                    console.error(\"QuickSearchFiled formatter should return a string html/jquery object; but got\",\n                        result);\n                }\n            }\n            this._openDropdown(createdJqObj);\n\n            this._updateHighlight(false);\n        }\n\n        // If Enter key was pressed earlier, handle it now that we've gotten results back\n        if (this._commitPending) {\n            this._commitPending = false;\n            this._doCommit();\n        }\n    };\n\n\n    /**\n     * Programmatically changes the search text and updates the results.\n     * @param {!string} value\n     */\n    QuickSearchField.prototype.setText = function (value) {\n        this.$input.val(value);\n        this.updateResults();  // programmatic changes don't trigger \"input\" event\n    };\n\n    /**\n     * Closes the dropdown, and discards any pending Promises.\n     */\n    QuickSearchField.prototype.destroy = function () {\n        this._pending = null;  // immediately invalidate any pending Promise\n        this._closeDropdown();\n        if(this.$input){\n            this.$input.off(\"input\", this._handleInput);\n            this.$input.off(\"keydown\", this._handleKeyDown);\n            this.$input = null;\n        }\n    };\n\n\n    exports.QuickSearchField = QuickSearchField;\n});\n"],"file":"QuickSearchField.js"}
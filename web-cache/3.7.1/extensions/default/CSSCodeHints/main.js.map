{"version":3,"sources":["extensions/default/CSSCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","CSSUtils","PreferencesManager","TokenUtils","StringMatch","ColorUtils","Strings","CSSProperties","properties","JSON","parse","cssWideKeywords","definePreference","description","DESCRIPTION_CSS_PROP_HINTS","lastContext","stringMatcherOptions","preferPrefixMatches","CssPropHints","this","primaryTriggerKeys","secondaryTriggerKeys","exclusion","vendorPrefixesAndGenericToEnd","hints","nonDashHints","dashHints","forEach","hint","label","startsWith","includes","push","concat","formatHints","hasColorSwatch","some","token","color","basicMatchSort","map","$hintObj","$","value","addClass","stringRanges","item","matched","append","text","formatColorHint","MDN_URL","$mdn","DOCS_MORE_LINK_MDN_TITLE","attr","uniqueMerge","arr1","arr2","prototype","updateExclusion","propNameOnly","textAfterCursor","info","context","PROP_NAME","name","substr","offset","PROP_VALUE","hasValidExclusion","hasHints","editor","implicitChar","cursor","getCursorPos","getInfoAtPos","indexOf","getHints","needle","valueNeedle","valueArray","type","result","selectInitial","isNewItem","index","values","trim","injectedCSSDefaults","COLOR_NAMES","pvalue","stringMatch","match","pvalues","pname","handleWideResults","insertHint","start","line","ch","end","keepHints","adjustCursor","newCursor","ctx","jquery","data","length","getInitialContext","_codeMirror","string","test","moveNextToken","moveSkippingWhitespace","parenMatch","replaceRange","setCursorPos","appReady","cssPropHints","registerHintProvider","cssPropHintProvider"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\ndefine(function (require, exports, module) {\n\n\n    var AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        CSSUtils            = brackets.getModule(\"language/CSSUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        TokenUtils          = brackets.getModule(\"utils/TokenUtils\"),\n        StringMatch         = brackets.getModule(\"utils/StringMatch\"),\n        ColorUtils          = brackets.getModule(\"utils/ColorUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        CSSProperties       = require(\"text!CSSProperties.json\"),\n        properties          = JSON.parse(CSSProperties);\n\n    require(\"./css-lint\");\n\n    const cssWideKeywords = ['initial', 'inherit', 'unset', 'var()', 'calc()'];\n\n    PreferencesManager.definePreference(\"codehint.CssPropHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_CSS_PROP_HINTS\n    });\n\n    // Context of the last request for hints: either CSSUtils.PROP_NAME,\n    // CSSUtils.PROP_VALUE or null.\n    var lastContext,\n        stringMatcherOptions = { preferPrefixMatches: true };\n\n    /**\n     * @constructor\n     */\n    function CssPropHints() {\n        this.primaryTriggerKeys = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-()\";\n        this.secondaryTriggerKeys = \":\";\n        this.exclusion = null;\n    }\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} propNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside property name context.\n     * Otherwise, we also update exclusion for property value context.\n     */\n    CssPropHints.prototype.updateExclusion = function (propNameOnly) {\n        var textAfterCursor;\n        if (this.exclusion && this.info) {\n            if (this.info.context === CSSUtils.PROP_NAME) {\n                textAfterCursor = this.info.name.substr(this.info.offset);\n            } else if (!propNameOnly && this.info.context === CSSUtils.PROP_VALUE) {\n                textAfterCursor = this.info.value.substr(this.info.offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether CSS propertyname or -name hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {String} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {Boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    CssPropHints.prototype.hasHints = function (editor, implicitChar) {\n        this.editor = editor;\n        var cursor = this.editor.getCursorPos();\n\n        lastContext = null;\n        this.info = CSSUtils.getInfoAtPos(editor, cursor);\n\n        if (this.info.context !== CSSUtils.PROP_NAME && this.info.context !== CSSUtils.PROP_VALUE) {\n            return false;\n        }\n\n        if (implicitChar) {\n            this.updateExclusion(false);\n            if (this.info.context === CSSUtils.PROP_NAME) {\n                // Check if implicitChar is the first character typed before an existing property name.\n                if (!this.exclusion && this.info.offset === 1 && implicitChar === this.info.name[0]) {\n                    this.exclusion = this.info.name.substr(this.info.offset);\n                }\n            }\n\n            return (this.primaryTriggerKeys.indexOf(implicitChar) !== -1) ||\n                   (this.secondaryTriggerKeys.indexOf(implicitChar) !== -1);\n        } else if (this.info.context === CSSUtils.PROP_NAME) {\n            if (this.info.offset === 0) {\n                this.exclusion = this.info.name;\n            } else {\n                this.updateExclusion(true);\n            }\n        }\n\n        return true;\n    };\n\n    function vendorPrefixesAndGenericToEnd(hints) {\n        // Two arrays to hold strings: one for non-dash strings, one for dash-starting strings\n        const nonDashHints = [];\n        const dashHints = [];\n\n        // Iterate through the array and partition the strings into the two arrays based on the starting character\n        hints.forEach(hint => {\n            if (hint.label.startsWith('-') || cssWideKeywords.includes(hint.label)) {\n                dashHints.push(hint);\n            } else {\n                nonDashHints.push(hint);\n            }\n        });\n\n        // Concatenate the non-dash array with the dash array to form the final sorted array\n        return nonDashHints.concat(dashHints);\n    }\n\n\n    /**\n     * Returns a sorted and formatted list of hints with the query substring\n     * highlighted.\n     *\n     * @param {Array.<Object>} hints - the list of hints to format\n     * @return {Array.jQuery} sorted Array of jQuery DOM elements to insert\n     */\n    function formatHints(hints) {\n        var hasColorSwatch = hints.some(function (token) {\n            return token.color;\n        });\n\n        StringMatch.basicMatchSort(hints);\n        hints = vendorPrefixesAndGenericToEnd(hints);\n        return hints.map(function (token) {\n            var $hintObj = $(`<span data-val='${token.label || token.value}'></span>`).addClass(\"brackets-css-hints brackets-hints\");\n\n            // highlight the matched portion of each hint\n            if (token.stringRanges) {\n                token.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hintObj.append($(`<span>`)\n                            .text(item.text)\n                            .addClass(\"matched-hint\"));\n                    } else {\n                        $hintObj.append(item.text);\n                    }\n                });\n            } else {\n                $hintObj.text(token.value);\n            }\n\n            if (hasColorSwatch) {\n                $hintObj = ColorUtils.formatColorHint($hintObj, token.color);\n            }\n            if(token.MDN_URL) {\n                const $mdn = $(`<a class=\"css-code-hint-info\" style=\"text-decoration: none;\"\n                href=\"${token.MDN_URL}\" title=\"${Strings.DOCS_MORE_LINK_MDN_TITLE}\">\n                <i class=\"fa-solid fa-circle-info\"></i></a>`);\n                $hintObj = $(`<span data-val='${token.label || token.value}'></span>`).append($hintObj).append($mdn);\n            }\n\n            $hintObj.attr(\"data-val\", token.value);\n\n            return $hintObj;\n        });\n    }\n\n    function uniqueMerge(arr1, arr2) {\n        arr2.forEach(item => {\n            if (!arr1.includes(item)) {\n                arr1.push(item);\n            }\n        });\n        return arr1;\n    }\n\n    /**\n     * Returns a list of availble CSS propertyname or -value hints if possible for the current\n     * editor context.\n     *\n     * @param {Editor} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    CssPropHints.prototype.getHints = function (implicitChar) {\n        this.cursor = this.editor.getCursorPos();\n        this.info = CSSUtils.getInfoAtPos(this.editor, this.cursor);\n\n        let needle = this.info.name,\n            valueNeedle = \"\",\n            context = this.info.context,\n            valueArray,\n            type,\n            result,\n            selectInitial = false;\n\n        // Clear the exclusion if the user moves the cursor with left/right arrow key.\n        this.updateExclusion(true);\n\n        if (context === CSSUtils.PROP_VALUE) {\n\n            // Always select initial value\n            selectInitial = true;\n\n            // We need to end the session and begin a new session if the ( char is typed to\n            // get arguments into the list when typing too fast\n            if (implicitChar === \"(\") {\n                return true;\n            }\n\n            // When switching from a NAME to a VALUE context, restart the session\n            // to give other more specialized providers a chance to intervene.\n            if (lastContext === CSSUtils.PROP_NAME) {\n                return true;\n            }\n            lastContext = CSSUtils.PROP_VALUE;\n\n\n            if (!properties[needle]) {\n                return null;\n            }\n\n            // Cursor is in an existing property value or partially typed value\n            if (!this.info.isNewItem && this.info.index !== -1) {\n                valueNeedle = this.info.values[this.info.index].trim();\n                valueNeedle = valueNeedle.substr(0, this.info.offset);\n            }\n\n            if(!properties[needle].injectedCSSDefaults){\n                uniqueMerge(properties[needle].values, cssWideKeywords);\n                properties[needle].injectedCSSDefaults = true;\n            }\n            valueArray = properties[needle].values;\n            type = properties[needle].type;\n            if (type === \"color\") {\n                valueArray = valueArray.concat(ColorUtils.COLOR_NAMES.map(function (color) {\n                    return { text: color, color: color };\n                }));\n                valueArray.push(\"transparent\", \"currentColor\");\n            }\n\n            result = $.map(valueArray, function (pvalue) {\n                var result = StringMatch.stringMatch(pvalue.text || pvalue, valueNeedle, stringMatcherOptions);\n                if (result) {\n                    if (pvalue.color) {\n                        result.color = pvalue.color;\n                    }\n\n                    return result;\n                }\n            });\n\n            return {\n                hints: formatHints(result),\n                match: null, // the CodeHintManager should not format the results\n                selectInitial: selectInitial\n            };\n        } else if (context === CSSUtils.PROP_NAME) {\n\n            // Select initial property if anything has been typed\n            if (this.primaryTriggerKeys.indexOf(implicitChar) !== -1 || needle !== \"\") {\n                selectInitial = true;\n            }\n\n            if (lastContext === CSSUtils.PROP_VALUE) {\n                // close the session if we're coming from a property value\n                // see https://github.com/adobe/brackets/issues/9496\n                return null;\n            }\n\n            lastContext = CSSUtils.PROP_NAME;\n            needle = needle.substr(0, this.info.offset);\n\n            result = $.map(properties, function (pvalues, pname) {\n                var result = StringMatch.stringMatch(pname, needle, stringMatcherOptions);\n                if (result) {\n                    if(properties[pname].MDN_URL){\n                        result.MDN_URL = properties[pname].MDN_URL;\n                    }\n                    return result;\n                }\n            });\n\n            return {\n                hints: formatHints(result),\n                match: null, // the CodeHintManager should not format the results\n                selectInitial: selectInitial,\n                handleWideResults: false\n            };\n        }\n        return null;\n    };\n\n    /**\n     * Inserts a given CSS protertyname or -value hint into the current editor context.\n     *\n     * @param {String} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {Boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    CssPropHints.prototype.insertHint = function (hint) {\n        var offset = this.info.offset,\n            cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            keepHints = false,\n            adjustCursor = false,\n            newCursor,\n            ctx;\n\n        if (hint.jquery) {\n            hint = hint.data(\"val\");\n        }\n\n        if (this.info.context !== CSSUtils.PROP_NAME && this.info.context !== CSSUtils.PROP_VALUE) {\n            return false;\n        }\n\n        start.line = end.line = cursor.line;\n        start.ch = cursor.ch - offset;\n\n        if (this.info.context === CSSUtils.PROP_NAME) {\n            keepHints = true;\n            var textAfterCursor = this.info.name.substr(this.info.offset);\n            if (this.info.name.length === 0 || CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                // It's a new insertion, so append a colon and set keepHints\n                // to show property value hints.\n                hint += \": \";\n                end.ch = start.ch;\n                end.ch += offset;\n\n                if (this.exclusion) {\n                    // Append a space to the end of hint to insert and then adjust\n                    // the cursor before that space.\n                    hint += \" \";\n                    adjustCursor = true;\n                    newCursor = { line: cursor.line,\n                        ch: start.ch + hint.length - 1 };\n                    this.exclusion = null;\n                }\n            } else {\n                // It's a replacement of an existing one or just typed in property.\n                // So we need to check whether there is an existing colon following\n                // the current property name. If a colon already exists, then we also\n                // adjust the cursor position and show code hints for property values.\n                end.ch = start.ch + this.info.name.length;\n                ctx = TokenUtils.getInitialContext(this.editor._codeMirror, cursor);\n                if (ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\n                    // We're at the very beginning of a property name. So skip it\n                    // before we locate the colon following it.\n                    TokenUtils.moveNextToken(ctx);\n                }\n                if (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) && ctx.token.string === \":\") {\n                    adjustCursor = true;\n                    newCursor = { line: cursor.line,\n                        ch: cursor.ch + (hint.length - this.info.name.length) };\n                    // Adjust cursor to the position after any whitespace that follows the colon, if there is any.\n                    if (TokenUtils.moveNextToken(ctx) && ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\n                        newCursor.ch += ctx.token.string.length;\n                    }\n                } else {\n                    hint += \": \";\n                }\n            }\n        } else {\n            if (!this.info.isNewItem && this.info.index !== -1) {\n                // Replacing an existing property value or partially typed value\n                end.ch = start.ch + this.info.values[this.info.index].length;\n            } else {\n                // Inserting a new property value\n                end.ch = start.ch;\n            }\n\n            var parenMatch = hint.match(/\\(.*?\\)/);\n            if (parenMatch) {\n                // value has (...), so place cursor inside opening paren\n                // and keep hints open\n                adjustCursor = true;\n                newCursor = { line: cursor.line,\n                    ch: start.ch + parenMatch.index + 1 };\n                keepHints = true;\n            }\n        }\n\n        // HACK (tracking adobe/brackets#1688): We talk to the private CodeMirror instance\n        // directly to replace the range instead of using the Document, as we should. The\n        // reason is due to a flaw in our current document synchronization architecture when\n        // inline editors are open.\n        this.editor._codeMirror.replaceRange(hint, start, end);\n\n        if (adjustCursor) {\n            this.editor.setCursorPos(newCursor);\n        }\n\n        return keepHints;\n    };\n\n    AppInit.appReady(function () {\n        var cssPropHints = new CssPropHints();\n        CodeHintManager.registerHintProvider(cssPropHints, [\"css\", \"scss\", \"less\"], 1);\n\n        // For unit testing\n        exports.cssPropHintProvider = cssPropHints;\n    });\n});\n"],"file":"main.js"}
{"version":3,"sources":["extensionsIntegrated/appUpdater/main.js"],"names":["define","require","exports","module","AppInit","Metrics","FileSystem","FileUtils","Commands","CommandManager","Menus","Dialogs","NodeUtils","DefaultDialogs","Strings","marked","semver","TaskManager","StringUtils","NativeApp","PreferencesManager","updaterWindow","updateTask","updatePendingRestart","updateFailed","TAURI_UPDATER_WINDOW_LABEL","KEY_LAST_UPDATE_CHECK_TIME","KEY_UPDATE_AVAILABLE","PREFS_AUTO_UPDATE","showOrHideUpdateIcon","updateAvailable","window","__TAURI__","WebviewWindow","getByLabel","addNewTask","UPDATING_APP","UPDATING_APP_MESSAGE","onSelect","showInfoDialog","UPDATE_READY_RESTART_TITLE","UPDATE_READY_RESTART_MESSAGE","UPDATE_FAILED_TITLE","UPDATE_FAILED_MESSAGE","UPDATING_APP_DIALOG_MESSAGE","show","getViewState","$","removeClass","addClass","fetchJSON","url","fetch","then","response","ok","json","createTauriUpdateWindow","downloadURL","countEvent","EVENT_TYPE","UPDATES","Phoenix","platform","config","environment","encodeURIComponent","title","fullscreen","resizable","height","minHeight","width","minWidth","acceptFirstMouse","visible","async","doUpdate","getUpdatePlatformKey","platformArch","app","getPlatformArch","os","brackets","getUpdateDetails","updatePlatformKey","updateDetails","shouldUpdate","currentVersion","metadata","apiVersion","updateVersion","releaseNotesMarkdown","updatePlatform","updateMetadata","app_update_url","phoenixBinaryVersion","getPhoenixBinaryVersion","phoenixLoadedAppVersion","gt","version","console","log","setViewState","notes","platforms","eq","e","error","isUpgradableLocation","homeDir","path","endsWith","phoenixInstallDir","cliArgs","invoke","phoenixBinLoadedPath","startsWith","logger","reportError","_getButtons","isUpgradableLoc","updateLater","className","DIALOG_BTN_CLASS_NORMAL","id","DIALOG_BTN_CANCEL","text","UPDATE_LATER","getItNow","DIALOG_BTN_CLASS_PRIMARY","DIALOG_BTN_OK","GET_IT_NOW","updateOnExit","UPDATE_ON_EXIT","checkForUpdates","isAutoUpdate","click","UPDATE_NOT_AVAILABLE_TITLE","UPDATE_UP_TO_DATE","autoUpdateEnabled","get","buttons","markdownHtml","parse","showModalDialog","DIALOG_ID_INFO","UPDATE_AVAILABLE_TITLE","done","option","downloadPage","homepage_url","openURLInDefaultBrowser","UPDATE_COMMANDS","GET_STATUS","GET_DOWNLOAD_PROGRESS","GET_INSTALLER_LOCATION","UPDATE_EVENT","UPDATE_STATUS","_sendUpdateCommand","command","data","event","emit","_refreshUpdateStatus","launchWindowsInstaller","Promise","resolve","reject","appdataDir","_tauriBootVars","appLocalDir","resolveResource","argsArray","nodeSrcPath","shell","Command","sidecar","on","code","signal","stdout","line","stderr","spawn","launchLinuxUpdater","stageValue","execCommand","runCommand","result","execute","Error","getCurrentMacAppPath","fullPath","normalizedPath","normalize","parts","split","sep","appIndex","findIndex","part","appPathParts","slice","join","_extractMacInstaller","extractPlatformPath","extractCommand","installerLocation","removeAttrCommand","extractedVirtualPath","fs","getTauriVirtualPath","directory","getDirectoryForPath","entries","getContentsAsync","length","includes","stripTrailingSlash","getTauriPlatformPath","_cleanExtractedFolderSilent","unlinkAsync","catch","finally","doMacUpdate","currentAppPath","removeCommand","copyCommand","quitTimeAppUpdateHandler","forceUseNodeWSEndpoint","dialog","failUpdateDialogAndExit","err","close","UPDATE_FAILED_VISIT_SITE_MESSAGE","update_download_page","UPDATE_INSTALLING","UPDATE_INSTALLING_MESSAGE","OK","updateInstalledDialogShown","updateFailedDialogShown","appReady","isNativeApp","isTestWindow","listen","receivedEvent","eventName","payload","setSucceded","setTitle","UPDATE_DONE","setMessage","UPDATE_RESTART_INSTALL","UPDATE_READY_RESTART_INSTALL_MESSAGE","UPDATE_DOWNLOADING","UPDATE_RESTART","setFailed","progressPercent","fileSize","setProgressPercent","format","UPDATE_DOWNLOAD_PROGRESS","Math","floor","registerQuitTimeAppUpdateHandler","reportErrorMessage","register","CMD_CHECK_FOR_UPDATE","HELP_CHECK_UPDATES","CMD_AUTO_UPDATE","HELP_AUTO_UPDATE","set","helpMenu","getMenu","AppMenuBar","HELP_MENU","addMenuItem","AFTER","HELP_GET_INVOLVED","definePreference","description","DESCRIPTION_AUTO_UPDATE","lastUpdateCheckTime","currentTime","Date","now","oneDayInMilliseconds"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global logger, path*/\n\n// this file uses tauri APIs directly and is probably the only place where tauri apis are used outside of the\n// shell.js file. This is app updates are pretty core level even though we do it as an extension here.\n\ndefine(function (require, exports, module) {\n    const AppInit = require(\"utils/AppInit\"),\n        Metrics = require(\"utils/Metrics\"),\n        FileSystem    = require(\"filesystem/FileSystem\"),\n        FileUtils   = require(\"file/FileUtils\"),\n        Commands = require(\"command/Commands\"),\n        CommandManager  = require(\"command/CommandManager\"),\n        Menus = require(\"command/Menus\"),\n        Dialogs = require(\"widgets/Dialogs\"),\n        NodeUtils = require(\"utils/NodeUtils\"),\n        DefaultDialogs  = require(\"widgets/DefaultDialogs\"),\n        Strings     = require(\"strings\"),\n        marked = require('thirdparty/marked.min'),\n        semver = require(\"thirdparty/semver.browser\"),\n        TaskManager = require(\"features/TaskManager\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        NativeApp           = require(\"utils/NativeApp\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\");\n    let updaterWindow, updateTask, updatePendingRestart, updateFailed;\n\n    const TAURI_UPDATER_WINDOW_LABEL = \"updater\",\n        KEY_LAST_UPDATE_CHECK_TIME = \"PH_LAST_UPDATE_CHECK_TIME\",\n        KEY_UPDATE_AVAILABLE = \"PH_UPDATE_AVAILABLE\";\n\n    const PREFS_AUTO_UPDATE = \"autoUpdate\";\n\n    function showOrHideUpdateIcon() {\n        if(!updaterWindow){\n            updaterWindow = window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL);\n        }\n        if(updaterWindow && !updateTask) {\n            updateTask = TaskManager.addNewTask(Strings.UPDATING_APP, Strings.UPDATING_APP_MESSAGE,\n                `<i class=\"fa-solid fa-cogs\"></i>`, {\n                    onSelect: function () {\n                        if(updatePendingRestart){\n                            Dialogs.showInfoDialog(Strings.UPDATE_READY_RESTART_TITLE, Strings.UPDATE_READY_RESTART_MESSAGE);\n                        } else if(updateFailed){\n                            Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_MESSAGE);\n                        }else {\n                            Dialogs.showInfoDialog(Strings.UPDATING_APP, Strings.UPDATING_APP_DIALOG_MESSAGE);\n                        }\n                    }\n                });\n            updateTask.show();\n        }\n        let updateAvailable = PreferencesManager.getViewState(KEY_UPDATE_AVAILABLE);\n        if(updateAvailable){\n            $(\"#update-notification\").removeClass(\"forced-hidden\");\n        } else {\n            $(\"#update-notification\").addClass(\"forced-hidden\");\n        }\n    }\n\n    function fetchJSON(url) {\n        return fetch(url)\n            .then(response => {\n                if (!response.ok) {\n                    return null;\n                }\n                return response.json();\n            });\n    }\n\n    function createTauriUpdateWindow(downloadURL) {\n        if(updaterWindow){\n            return;\n        }\n        Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'window', \"create\"+Phoenix.platform);\n        // as we are a single instance app, and there can be multiple phoenix windows that comes in and goes out,\n        // the updater lives in its own independent hidden window.\n        const url = downloadURL ?\n            `tauri-updater.html?stage=${Phoenix.config.environment}&downloadURL=${encodeURIComponent(downloadURL)}` :\n            `tauri-updater.html?stage=${Phoenix.config.environment}`;\n        updaterWindow = new window.__TAURI__.window.WebviewWindow(TAURI_UPDATER_WINDOW_LABEL, {\n            url: url,\n            title: \"Desktop App Updater\",\n            fullscreen: false,\n            resizable: false,\n            height: 320,\n            minHeight: 320,\n            width: 240,\n            minWidth: 240,\n            acceptFirstMouse: false,\n            visible: false\n        });\n        if(window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL)){\n            Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'window', \"okCreate\"+Phoenix.platform);\n        }\n    }\n\n    async function doUpdate(downloadURL) {\n        createTauriUpdateWindow(downloadURL);\n        showOrHideUpdateIcon();\n    }\n\n    async function getUpdatePlatformKey() {\n        const platformArch = await Phoenix.app.getPlatformArch();\n        let os = 'windows';\n        if (brackets.platform === \"mac\") {\n            os = \"darwin\";\n        } else if (brackets.platform === \"linux\") {\n            os = \"linux\";\n        }\n        return `${os}-${platformArch}`;\n    }\n\n    async function getUpdateDetails() {\n        const updatePlatformKey = await getUpdatePlatformKey();\n        const updateDetails = {\n            shouldUpdate: false,\n            updatePendingRestart: false,\n            downloadURL: null,\n            currentVersion: Phoenix.metadata.apiVersion,\n            updateVersion: null,\n            releaseNotesMarkdown: null,\n            updatePlatform: updatePlatformKey\n        };\n        try{\n            if(!updaterWindow){\n                updaterWindow = window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL);\n            }\n            const updateMetadata = await fetchJSON(brackets.config.app_update_url);\n            const phoenixBinaryVersion = await NodeUtils.getPhoenixBinaryVersion();\n            const phoenixLoadedAppVersion = Phoenix.metadata.apiVersion;\n            if(semver.gt(updateMetadata.version, phoenixBinaryVersion)){\n                console.log(\"Update available: \", updateMetadata, \"Detected platform: \", updatePlatformKey);\n                PreferencesManager.setViewState(KEY_UPDATE_AVAILABLE, true);\n                updateDetails.shouldUpdate = true;\n                updateDetails.updateVersion = updateMetadata.version;\n                updateDetails.releaseNotesMarkdown = updateMetadata.notes;\n                if(updateMetadata.platforms && updateMetadata.platforms[updatePlatformKey]){\n                    updateDetails.downloadURL = updateMetadata.platforms[updatePlatformKey].url;\n                }\n            } else if(semver.eq(updateMetadata.version, phoenixBinaryVersion) &&\n                !semver.eq(phoenixLoadedAppVersion, phoenixBinaryVersion) && updaterWindow){\n                // the updaterWindow check is here so that it only makes sense to show restart dialog if the update\n                // was actually done. We have a version number mismatch of 0.0.1 between phoenix-desktop and phoenix\n                // repo, and that means that this can get triggered on statup on development builds. Wont happen in\n                // actual pipeline generated build tho.\n                console.log(\"Updates applied, waiting for app restart: \", phoenixBinaryVersion, phoenixLoadedAppVersion);\n                updateDetails.updatePendingRestart = true;\n                PreferencesManager.setViewState(KEY_UPDATE_AVAILABLE, true);\n            } else {\n                console.log(\"no updates available for platform: \", updateDetails.updatePlatform);\n                PreferencesManager.setViewState(KEY_UPDATE_AVAILABLE, false);\n            }\n            showOrHideUpdateIcon();\n        } catch (e) {\n            console.error(\"Error getting update metadata\", e);\n            updateFailed = true;\n            Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'fail', \"Unknown\"+Phoenix.platform);\n        }\n        return updateDetails;\n    }\n\n    /**\n     * We should only upgrade if the current binary is at an installed location.\n     */\n    async function isUpgradableLocation() {\n        try {\n            if (brackets.platform === \"linux\") {\n                let homeDir = await window.__TAURI__.path.homeDir(); // Eg. \"/home/home/\"\n                if(!homeDir.endsWith(\"/\")){\n                   homeDir = homeDir + \"/\";\n                }\n                const phoenixInstallDir = `${homeDir}.phoenix-code/`;\n                const cliArgs = await window.__TAURI__.invoke('_get_commandline_args');\n                const phoenixBinLoadedPath = cliArgs[0];\n                // we only upgrade if the install location is created by the installer\n                return phoenixBinLoadedPath.startsWith(phoenixInstallDir);\n            }\n        } catch (e) {\n            logger.reportError(e);\n            console.error(e);\n            return false;\n        }\n        // for mac, this is handled by tauri APIs, so we always say yes.\n        // for win, this is handled by windows installer nsis exe, so we always say yes.\n        return true;\n    }\n\n    function _getButtons(isUpgradableLoc) {\n        const updateLater =\n            {className: Dialogs .DIALOG_BTN_CLASS_NORMAL, id: Dialogs .DIALOG_BTN_CANCEL, text: Strings.UPDATE_LATER };\n        const getItNow =\n            { className: Dialogs .DIALOG_BTN_CLASS_PRIMARY, id: Dialogs .DIALOG_BTN_OK, text: Strings.GET_IT_NOW };\n        const updateOnExit =\n            { className: Dialogs .DIALOG_BTN_CLASS_PRIMARY, id: Dialogs .DIALOG_BTN_OK, text: Strings.UPDATE_ON_EXIT };\n        if(!isUpgradableLoc) {\n            return [updateLater, getItNow];\n        }\n        return [updateLater, updateOnExit];\n    }\n\n    async function checkForUpdates(isAutoUpdate) {\n        showOrHideUpdateIcon();\n        if(updateTask){\n            $(\"#status-tasks .btn-dropdown\").click();\n            return;\n        }\n        const updateDetails = await getUpdateDetails(); // this will also show update icon if update present\n        if(updateFailed) {\n            Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_MESSAGE);\n            return;\n        }\n        if(updatePendingRestart || updateDetails.updatePendingRestart){\n            if(!isAutoUpdate){\n                Dialogs.showInfoDialog(Strings.UPDATE_READY_RESTART_TITLE, Strings.UPDATE_READY_RESTART_MESSAGE);\n                // the dialog will only be shown in explicit check for updates, else its annoying that this comes\n                // up at every new window create from app.\n            }\n            return;\n        }\n        if(!updateDetails.shouldUpdate){\n            (!isAutoUpdate) && Dialogs.showInfoDialog(Strings.UPDATE_NOT_AVAILABLE_TITLE, Strings.UPDATE_UP_TO_DATE);\n            return;\n        }\n        const autoUpdateEnabled = PreferencesManager.get(PREFS_AUTO_UPDATE);\n        if(isAutoUpdate && !autoUpdateEnabled){\n            // the update icon is lit at this time for the user to hint that an update is available\n            // but, we don't show the dialog if auto update is off.\n            return;\n        }\n\n        const isUpgradableLoc = await isUpgradableLocation();\n        const buttons = _getButtons(isUpgradableLoc);\n        let markdownHtml = marked.parse(updateDetails.releaseNotesMarkdown || \"\");\n        Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"shown\"+Phoenix.platform);\n        Dialogs.showModalDialog(DefaultDialogs.DIALOG_ID_INFO, Strings.UPDATE_AVAILABLE_TITLE, markdownHtml, buttons)\n            .done(option=>{\n                if(option === Dialogs.DIALOG_BTN_CANCEL){\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"cancel\"+Phoenix.platform);\n                    return;\n                }\n                if(!isUpgradableLoc) {\n                    // user installed linux as binary without installer, we just open phcode.io\n                    const downloadPage = brackets.config.homepage_url || \"https://phcode.io\";\n                    NativeApp.openURLInDefaultBrowser(downloadPage);\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"nonUpgradable\"+Phoenix.platform);\n                    return;\n                }\n                if(option === Dialogs.DIALOG_BTN_OK && !updaterWindow){\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"okUpdate\"+Phoenix.platform);\n                    doUpdate(updateDetails.downloadURL);\n                }\n            });\n    }\n\n    const UPDATE_COMMANDS = {\n        GET_STATUS: \"GET_STATUS\",\n        GET_DOWNLOAD_PROGRESS: \"GET_DOWNLOAD_PROGRESS\",\n        GET_INSTALLER_LOCATION: \"GET_INSTALLER_LOCATION\"\n    };\n    const UPDATE_EVENT = {\n        STATUS: \"STATUS\",\n        LOG_ERROR: \"LOG_ERROR\",\n        DOWNLOAD_PROGRESS: \"DOWNLOAD_PROGRESS\",\n        INSTALLER_LOCATION: \"INSTALLER_LOCATION\"\n    };\n    const UPDATE_STATUS = {\n        STARTED: \"STARTED\",\n        DOWNLOADING: \"DOWNLOADING\",\n        INSTALLER_DOWNLOADED: \"INSTALLER_DOWNLOADED\",\n        FAILED: \"FAILED\",\n        FAILED_UNKNOWN_OS: \"FAILED_UNKNOWN_OS\",\n        INSTALLED: \"INSTALLED\"\n    };\n\n    function _sendUpdateCommand(command, data) {\n        window.__TAURI__.event.emit('updateCommands', {command, data});\n    }\n\n    function _refreshUpdateStatus() {\n        _sendUpdateCommand(UPDATE_COMMANDS.GET_STATUS);\n    }\n\n    async function launchWindowsInstaller() {\n        return new Promise((resolve, reject)=>{\n            const appdataDir = window._tauriBootVars.appLocalDir;\n            window.__TAURI__.path.resolveResource(\"src-node/installer/launch-windows-installer.js\")\n                .then(async nodeSrcPath=>{\n                    // this is not supposed to work in linux.\n                    const argsArray = [nodeSrcPath, appdataDir];\n                    const command = window.__TAURI__.shell.Command.sidecar('phnode', argsArray);\n                    command.on('close', data => {\n                        console.log(`PhNode: command finished with code ${data.code} and signal ${data.signal}`);\n                        if(data.code !== 0) {\n                            console.error(\"Install failed\");\n                            reject();\n                            return;\n                        }\n                        resolve();\n                    });\n                    command.on('error', error => {\n                        console.error(`PhNode: command error: \"${error}\"`);\n                        reject();\n                    });\n                    command.stdout.on('data', line => {\n                        console.log(`PhNode: ${line}`);\n                    });\n                    command.stderr.on('data', line => console.error(`PhNode: ${line}`));\n                    command.spawn();\n                });\n        });\n    }\n\n    async function launchLinuxUpdater() {\n        const stageValue = Phoenix.config.environment;\n        console.log('Stage:', stageValue);\n        let execCommand = 'wget -qO- https://updates.phcode.io/linux/installer.sh | bash -s -- --upgrade';\n        let runCommand = 'run-update-linux-command';\n        if(stageValue === 'dev' || stageValue === 'stage'){\n            runCommand = 'run-update-linux-command-dev';\n            execCommand = \"wget -qO- https://updates.phcode.io/linux/installer-latest-experimental-build.sh | bash -s -- --upgrade\";\n        }\n        const command = new window.__TAURI__.shell\n            .Command(runCommand, ['-e', execCommand]);\n        const result = await command.execute();\n        if(result.code !== 0){\n            throw new Error(\"Update script exit with non-0 exit code: \" + result.code);\n        }\n    }\n\n    async function getCurrentMacAppPath() {\n        const cliArgs = await window.__TAURI__.invoke('_get_commandline_args');\n        let fullPath = cliArgs[0]; // something like /Applications/editor.app/contents/.../Phoenix code\n        const normalizedPath = path.normalize(fullPath);\n        const parts = normalizedPath.split(path.sep);\n        const appIndex = parts.findIndex(part => part.endsWith('.app'));\n\n        // Reconstruct the path up to the .app part\n        if (appIndex !== -1) {\n            const appPathParts = parts.slice(0, appIndex + 1);\n            return appPathParts.join(path.sep); // returns /Applications/editor.app\n        }\n        // .app part is found\n        return null;\n    }\n\n    async function _extractMacInstaller() {\n        const appdataDir = window._tauriBootVars.appLocalDir;\n        let extractPlatformPath = path.join(appdataDir, 'installer', \"extracted\");\n        // extract the .app file\n        const extractCommand = new window.__TAURI__.shell\n            .Command(`tar-unix`, ['-xzf', installerLocation, \"-C\", extractPlatformPath]);\n        let result = await extractCommand.execute();\n        if(result.code !== 0){\n            console.error(\"Could not extract installer at\", installerLocation, \"to\", extractPlatformPath);\n            throw new Error(\"Could not extract installer at \" + installerLocation + \" to \" + extractPlatformPath);\n        }\n        // remove the quarantine flag\n        const removeAttrCommand = new window.__TAURI__.shell\n            .Command(`mac-remove-quarantine`, [\"-rd\", \"com.apple.quarantine\", extractPlatformPath]);\n        result = await removeAttrCommand.execute();\n        if(result.code !== 0){\n            console.error(\"Could not remove quarantine attribute for\", extractPlatformPath, \"ignoring...\");\n            // we can ignore this failure as the user will be asked for permission by os on clicking anyway.\n        }\n        // now get the .app path from extracted path\n        const extractedVirtualPath = window.fs.getTauriVirtualPath(extractPlatformPath);\n        let directory = FileSystem.getDirectoryForPath(extractedVirtualPath);\n        const {entries} = await directory.getContentsAsync();\n        if(entries.length !== 1 || !entries[0].fullPath.includes(\".app\")){\n            throw new Error(\"Could not resolve .app to update from extracted folder\" + extractedVirtualPath);\n        }\n        installerLocation = FileUtils.stripTrailingSlash(\n            window.fs.getTauriPlatformPath(entries[0].fullPath));\n    }\n\n    function _cleanExtractedFolderSilent() {\n        return new Promise(resolve=>{\n            const appdataDir = window._tauriBootVars.appLocalDir;\n            let extractPlatformPath = path.join(appdataDir, 'installer', \"extracted\");\n            const extractedVirtualPath = window.fs.getTauriVirtualPath(extractPlatformPath);\n            let directory = FileSystem.getDirectoryForPath(extractedVirtualPath);\n            directory.unlinkAsync()\n                .catch(console.error)\n                .finally(resolve);\n        });\n    }\n\n    async function doMacUpdate() {\n        await _extractMacInstaller();\n        const currentAppPath = await getCurrentMacAppPath();\n        if(!currentAppPath || !installerLocation || !currentAppPath.endsWith(\".app\") ||\n            !installerLocation.endsWith(\".app\")){\n            throw new Error(\"Cannot resolve .app location to copy.\");\n        }\n        let removeCommand = new window.__TAURI__.shell\n            .Command(`recursive-rm-unix`, ['-r', currentAppPath]);\n        let result = await removeCommand.execute();\n        if(result.code !== 0){\n            console.error(\"Could not remove old app: \", currentAppPath);\n            throw new Error(\"Could not remove old app: \" + currentAppPath);\n        }\n        const copyCommand = new window.__TAURI__.shell\n            .Command(`recursive-copy-unix`, ['-r', installerLocation, currentAppPath]);\n        result = await copyCommand.execute();\n        if(result.code !== 0){\n            throw new Error(\"Update script exit with non-0 exit code: \" + result.code);\n        }\n        // now remove the original .app\n        await _cleanExtractedFolderSilent();\n    }\n\n    let installerLocation;\n    async function quitTimeAppUpdateHandler() {\n        if(!installerLocation){\n            return;\n        }\n        // at this time, the node process have exited and we need to force use tauri apis. This would\n        // normally happen as node responds as terminated, but for updates, this is at quit time and we\n        // cant wait any longer.\n        window.fs.forceUseNodeWSEndpoint(false);\n        console.log(\"Installing update from: \", installerLocation);\n        return new Promise(resolve=>{\n            // this should never reject as it happens in app quit. rejecting wont affect quit, but its unnecessary.\n            let dialog;\n            function failUpdateDialogAndExit(err) {\n                console.error(\"error updating: \", err);\n                dialog && dialog.close();\n                Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_VISIT_SITE_MESSAGE)\n                    .done(()=>{\n                        NativeApp.openURLInDefaultBrowser(Phoenix.config.update_download_page)\n                            .catch(console.error)\n                            .finally(resolve);\n                    });\n            }\n            if (brackets.platform === \"win\") {\n                launchWindowsInstaller()\n                    .then(resolve)\n                    .catch(failUpdateDialogAndExit);\n                return;\n            }\n            dialog = Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_INFO,\n                Strings.UPDATE_INSTALLING,\n                Strings.UPDATE_INSTALLING_MESSAGE,\n                [\n                    {\n                        className: \"forced-hidden\",\n                        id: Dialogs.DIALOG_BTN_OK,\n                        text: Strings.OK\n                    }\n                ],\n                false\n            );\n            if (brackets.platform === \"linux\") {\n                launchLinuxUpdater()\n                    .then(resolve)\n                    .catch(failUpdateDialogAndExit);\n            } else if (brackets.platform === \"mac\") {\n                doMacUpdate()\n                    .then(resolve)\n                    .catch(failUpdateDialogAndExit);\n            } else {\n                resolve();\n            }\n        });\n    }\n\n    let updateInstalledDialogShown = false, updateFailedDialogShown = false;\n    AppInit.appReady(function () {\n        if(!Phoenix.isNativeApp || Phoenix.isTestWindow) {\n            // app updates are only for desktop builds\n            return;\n        }\n        if (brackets.platform === \"mac\") {\n            // in mac, the `update.app.tar.gz` is downloaded, and only extracted on app quit.\n            // we do this only in mac as the `.app` file is extracted only at app quit and deleted\n            // and if we see the `extracted file` at app boot, it means the update was broken,and we clear\n            // the updated folder. if not, the extracted app may be corrupt, or mac will show that app\n            // too in the finder `open with` section.\n            // in windows, the `setup.exe.zip` is downloaded and extracted to `setup.exe`. The exe is executed\n            // only on app quit. so if we do this in windows, the extracted installer.exe will be\n            // deleted on new widow create and the final update will fail if other windows were opened\n            // after the installer was downloaded and extracted.\n            // in Linux, it is an online installer, nothing is downloaded.\n            _cleanExtractedFolderSilent();\n        }\n        updaterWindow = window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL);\n        window.__TAURI__.event.listen(\"updater-event\", (receivedEvent)=> {\n            console.log(\"received Event updater-event\", receivedEvent);\n            const {eventName, data} = receivedEvent.payload;\n            if(eventName === UPDATE_EVENT.STATUS) {\n                if(data === UPDATE_STATUS.FAILED_UNKNOWN_OS && !updateFailedDialogShown){\n                    updateFailedDialogShown = true;\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'fail', \"Unknown\"+Phoenix.platform);\n                    updateFailed = true;\n                    updateTask.setFailed();\n                    updateTask.setMessage(Strings.UPDATE_FAILED_TITLE);\n                } else if(data === UPDATE_STATUS.FAILED && !updateFailedDialogShown){\n                    updateFailedDialogShown = true;\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'fail', Phoenix.platform);\n                    updateFailed = true;\n                    updateTask.setFailed();\n                    updateTask.setMessage(Strings.UPDATE_FAILED_TITLE);\n                    Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_MESSAGE);\n                } else if(data === UPDATE_STATUS.INSTALLED && !updateInstalledDialogShown){\n                    updateInstalledDialogShown = true;\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'done', Phoenix.platform);\n                    updatePendingRestart = true;\n                    updateTask.setSucceded();\n                    updateTask.setTitle(Strings.UPDATE_DONE);\n                    updateTask.setMessage(Strings.UPDATE_RESTART);\n                    Dialogs.showInfoDialog(Strings.UPDATE_READY_RESTART_TITLE, Strings.UPDATE_READY_RESTART_MESSAGE);\n                } else if(data === UPDATE_STATUS.INSTALLER_DOWNLOADED){\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'downloaded', Phoenix.platform);\n                    updatePendingRestart = true;\n                    updateTask.setSucceded();\n                    updateTask.setTitle(Strings.UPDATE_DONE);\n                    updateTask.setMessage(Strings.UPDATE_RESTART_INSTALL);\n                    if(!updateInstalledDialogShown){\n                        Dialogs.showInfoDialog(Strings.UPDATE_READY_RESTART_TITLE, Strings.UPDATE_READY_RESTART_INSTALL_MESSAGE);\n                        updateInstalledDialogShown = true;\n                    }\n                    _sendUpdateCommand(UPDATE_COMMANDS.GET_INSTALLER_LOCATION);\n                } else if(data === UPDATE_STATUS.DOWNLOADING){\n                    updateTask.setMessage(Strings.UPDATE_DOWNLOADING);\n                    _sendUpdateCommand(UPDATE_COMMANDS.GET_DOWNLOAD_PROGRESS);\n                }\n                showOrHideUpdateIcon();\n            } else if(eventName === UPDATE_EVENT.DOWNLOAD_PROGRESS) {\n                const {progressPercent, fileSize} = data;\n                updateTask.setProgressPercent(progressPercent);\n                updateTask.setMessage(StringUtils.format(Strings.UPDATE_DOWNLOAD_PROGRESS,\n                    Math.floor(fileSize*progressPercent/100),\n                    fileSize));\n            } else if(eventName === UPDATE_EVENT.INSTALLER_LOCATION) {\n                installerLocation = data;\n                Phoenix.app.registerQuitTimeAppUpdateHandler(quitTimeAppUpdateHandler);\n            } else if(eventName === UPDATE_EVENT.LOG_ERROR) {\n                logger.reportErrorMessage(data);\n            }\n        });\n        $(\"#update-notification\").click(()=>{\n            checkForUpdates();\n        });\n        CommandManager.register(Strings.CMD_CHECK_FOR_UPDATE, Commands.HELP_CHECK_UPDATES, ()=>{\n            checkForUpdates();\n        });\n        CommandManager.register(Strings.CMD_AUTO_UPDATE, Commands.HELP_AUTO_UPDATE, ()=>{\n            PreferencesManager.set(PREFS_AUTO_UPDATE, !PreferencesManager.get(PREFS_AUTO_UPDATE));\n        });\n        const helpMenu = Menus.getMenu(Menus.AppMenuBar.HELP_MENU);\n        helpMenu.addMenuItem(Commands.HELP_CHECK_UPDATES, \"\", Menus.AFTER, Commands.HELP_GET_INVOLVED);\n        // auto update is not added to help menu toggle as it will lead to install base version\n        // fragmentation, and we don't want an android version fragment situation. By default, all platforms\n        // are supported at latest version. User still has option to edit preferences manually to disable the auto\n        // update option.\n        PreferencesManager.definePreference(PREFS_AUTO_UPDATE, \"boolean\", true, {\n            description: Strings.DESCRIPTION_AUTO_UPDATE\n        });\n        showOrHideUpdateIcon();\n        _refreshUpdateStatus();\n        // check for updates at boot\n        let lastUpdateCheckTime = PreferencesManager.getViewState(KEY_LAST_UPDATE_CHECK_TIME);\n        const currentTime = Date.now();\n        const oneDayInMilliseconds = 24 * 60 * 60 * 1000; // 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\n        if(lastUpdateCheckTime && ((currentTime - lastUpdateCheckTime) < oneDayInMilliseconds)){\n            console.log(\"Skipping update check: last update check was within one day\");\n            return;\n        }\n        PreferencesManager.setViewState(KEY_LAST_UPDATE_CHECK_TIME, currentTime);\n        checkForUpdates(true);\n    });\n});\n"],"file":"main.js"}
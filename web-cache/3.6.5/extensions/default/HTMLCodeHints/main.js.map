{"version":3,"sources":["extensions/default/HTMLCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","HTMLUtils","PreferencesManager","Strings","NewFileContentManager","CSSUtils","StringMatch","HTMLTags","HTMLAttributes","HTMLTemplate","XHTMLTemplate","tags","attributes","TagHints","this","exclusion","AttrHints","globalAttributes","readGlobalAttrHints","cachedHints","definePreference","description","DESCRIPTION_HTML_TAG_HINTS","DESCRIPTION_ATTR_HINTS","prototype","updateExclusion","textAfterCursor","tagInfo","tagName","substr","position","offset","hasValidExclusion","hasHints","editor","implicitChar","pos","getCursorPos","getTagInfo","tokenType","TAG_NAME","getHints","query","result","slice","hints","$","map","value","key","indexOf","sort","match","selectInitial","handleWideResults","insertHint","completion","start","line","ch","end","cursor","charCount","length","document","replaceRange","global","MAX_CLASS_HINTS","formatHints","basicMatchSort","splice","token","$hintObj","addClass","stringRanges","forEach","item","matched","append","text","label","attr","_getAllClassHints","queryStr","segments","split","deferred","Deferred","getAllCssSelectorsInProject","includeClasses","scanCurrentHtml","then","pvalue","includes","stringMatch","preferPrefixMatches","validHints","alreadyMatched","resolve","catch","console","error","NewDocContentProvider","CONTENT_PROVIDER_NAME","_getValueHintsForAttr","attrName","tagPlusAttr","attrInfo","type","attribOption","attrNameOnly","ATTR_NAME","name","ATTR_VALUE","Array","i","foundPrefix","tag","usedAttr","getTagAttributes","filter","unfiltered","concat","grep","inArray","assert","Object","hasOwnProperty","done","asyncHints","resolveWith","insertedName","replaceExistingOne","valueAssigned","endQuote","shouldReplace","positionWithinAttributeVal","data","textBeforeCursor","lastSegment","hasEndQuote","quoteChar","setCursorPos","getContent","fileName","Promise","reject","endsWith","appReady","JSON","parse","tagHints","attrHints","newDocContentProvider","registerHintProvider","registerContentProvider","tagHintProvider","attrHintProvider"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n    require(\"HTMLJumpToDef\");\n\n    // Load dependent modules\n    const AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        HTMLUtils           = brackets.getModule(\"language/HTMLUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings             = brackets.getModule(\"strings\"),\n        NewFileContentManager = brackets.getModule(\"features/NewFileContentManager\"),\n        CSSUtils            = brackets.getModule(\"language/CSSUtils\"),\n        StringMatch         = brackets.getModule(\"utils/StringMatch\"),\n        HTMLTags            = require(\"text!HtmlTags.json\"),\n        HTMLAttributes      = require(\"text!HtmlAttributes.json\"),\n        HTMLTemplate        = require(\"text!template.html\"),\n        XHTMLTemplate       = require(\"text!template.xhtml\");\n\n    let tags,\n        attributes;\n\n    PreferencesManager.definePreference(\"codehint.TagHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_HTML_TAG_HINTS\n    });\n\n    PreferencesManager.definePreference(\"codehint.AttrHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_ATTR_HINTS\n    });\n\n    /**\n     * @constructor\n     */\n    function TagHints() {\n        this.exclusion = null;\n    }\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     */\n    TagHints.prototype.updateExclusion = function () {\n        var textAfterCursor;\n        if (this.exclusion && this.tagInfo) {\n            textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML tag hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    TagHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos();\n\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        this.editor = editor;\n        if (implicitChar === null) {\n            if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n                if (this.tagInfo.position.offset >= 0) {\n                    if (this.tagInfo.position.offset === 0) {\n                        this.exclusion = this.tagInfo.tagName;\n                    } else {\n                        this.updateExclusion();\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (implicitChar === \"<\") {\n            this.exclusion = this.tagInfo.tagName;\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML tag hints if possible for the current\n     * editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    TagHints.prototype.getHints = function (implicitChar) {\n        var query,\n            result;\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, this.editor.getCursorPos());\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            if (this.tagInfo.position.offset >= 0) {\n                this.updateExclusion();\n                query = this.tagInfo.tagName.slice(0, this.tagInfo.position.offset);\n                result = $.map(tags, function (value, key) {\n                    if (key.indexOf(query) === 0) {\n                        return key;\n                    }\n                }).sort();\n\n                return {\n                    hints: result,\n                    match: query,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Inserts a given HTML tag hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    TagHints.prototype.insertHint = function (completion) {\n        var start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            cursor = this.editor.getCursorPos(),\n            charCount = 0;\n\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            var textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = this.tagInfo.position.offset;\n            } else {\n                charCount = this.tagInfo.tagName.length;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - this.tagInfo.position.offset;\n        end.ch = start.ch + charCount;\n\n        if (this.exclusion || completion !== this.tagInfo.tagName) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n            this.exclusion = null;\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function AttrHints() {\n        this.globalAttributes = this.readGlobalAttrHints();\n        this.cachedHints = null;\n        this.exclusion = \"\";\n    }\n\n    /**\n     * @private\n     * Parse the code hints from JSON data and extract all hints from property names.\n     * @return {!Array.<string>} An array of code hints read from the JSON data source.\n     */\n    AttrHints.prototype.readGlobalAttrHints = function () {\n        return $.map(attributes, function (value, key) {\n            if (value.global === \"true\") {\n                return key;\n            }\n        });\n    };\n\n    const MAX_CLASS_HINTS = 250;\n    function formatHints(hints) {\n        StringMatch.basicMatchSort(hints);\n        if(hints.length > MAX_CLASS_HINTS) {\n            hints = hints.splice(0, MAX_CLASS_HINTS);\n        }\n        return hints.map(function (token) {\n            let $hintObj = $(\"<span>\").addClass(\"brackets-html-hints brackets-hints\");\n\n            // highlight the matched portion of each hint\n            if (token.stringRanges) {\n                token.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hintObj.append($(\"<span>\")\n                            .text(item.text)\n                            .addClass(\"matched-hint\"));\n                    } else {\n                        $hintObj.append(item.text);\n                    }\n                });\n            } else {\n                $hintObj.text(token.label);\n            }\n            $hintObj.attr(\"data-val\", token.label);\n            return $hintObj;\n        });\n    }\n\n    function _getAllClassHints(query) {\n        let queryStr = query.queryStr;\n        // \"class1 class2\" have multiple classes. the last part is the query to hint\n        const segments = queryStr.split(\" \");\n        queryStr = segments[segments.length-1];\n        const deferred = $.Deferred();\n        CSSUtils.getAllCssSelectorsInProject({includeClasses: true, scanCurrentHtml: true}).then(hints=>{\n            const result = $.map(hints, function (pvalue) {\n                pvalue = pvalue.slice(1); // remove.\n                if(!pvalue || pvalue.includes(\"#\") || pvalue.includes(\"\\\\\") || pvalue.includes(\"/\")){\n                    return null;\n                }\n                return  StringMatch.stringMatch(pvalue, queryStr, { preferPrefixMatches: true });\n            });\n            const validHints = formatHints(result);\n            validHints.alreadyMatched = true;\n            deferred.resolve(validHints);\n        }).catch(console.error);\n        return deferred;\n    }\n\n    /**\n     * Helper function that determines the possible value hints for a given html tag/attribute name pair\n     *\n     * @param {{queryStr: string}} query\n     * The current query\n     *\n     * @param {string} tagName\n     * HTML tag name\n     *\n     * @param {string} attrName\n     * HTML attribute name\n     *\n     * @return {!Array.<string>|$.Deferred}\n     * The (possibly deferred) hints.\n     */\n    AttrHints.prototype._getValueHintsForAttr = function (query, tagName, attrName) {\n        // We look up attribute values with tagName plus a slash and attrName first.\n        // If the lookup fails, then we fall back to look up with attrName only. Most\n        // of the attributes in JSON are using attribute name only as their properties,\n        // but in some cases like \"type\" attribute, we have different properties like\n        // \"script/type\", \"link/type\" and \"button/type\".\n        var hints = [];\n\n        if(attrName === \"class\") {\n            return _getAllClassHints(query);\n        }\n\n        var tagPlusAttr = tagName + \"/\" + attrName,\n            attrInfo = attributes[tagPlusAttr] || attributes[attrName];\n\n        if (attrInfo) {\n            if (attrInfo.type === \"boolean\") {\n                hints = [\"false\", \"true\"];\n            } else if (attrInfo.attribOption) {\n                hints = attrInfo.attribOption;\n            }\n        }\n\n        return hints;\n    };\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} attrNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside an attribute name context.\n     * Otherwise, we also update exclusion for attribute value context.\n     */\n    AttrHints.prototype.updateExclusion = function (attrNameOnly) {\n        if (this.exclusion && this.tagInfo) {\n            var tokenType = this.tagInfo.position.tokenType,\n                offset = this.tagInfo.position.offset,\n                textAfterCursor;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            } else if (!attrNameOnly && tokenType === HTMLUtils.ATTR_VALUE) {\n                textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML attribute hints are available in the current\n     * editor context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    AttrHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos(),\n            tokenType,\n            offset,\n            query;\n\n        this.editor = editor;\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (implicitChar === null) {\n            query = null;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                if (offset >= 0) {\n                    query = this.tagInfo.attr.name.slice(0, offset);\n                }\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                if (this.tagInfo.position.offset >= 0) {\n                    query = this.tagInfo.attr.value.slice(0, offset);\n                } else {\n                    // We get negative offset for a quoted attribute value with some leading whitespaces\n                    // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                    // So just set the queryStr to an empty string.\n                    query = \"\";\n                }\n\n                // If we're at an attribute value, check if it's an attribute name that has hintable values.\n                const attrName = this.tagInfo.attr.name;\n                if (attrName && attrName !== \"class\") { // class hints are always computed later\n                    let hints = this._getValueHintsForAttr({queryStr: query},\n                        this.tagInfo.tagName, attrName);\n                    if (hints instanceof Array) {\n                        // If we got synchronous hints, check if we have something we'll actually use\n                        var i, foundPrefix = false;\n                        for (i = 0; i < hints.length; i++) {\n                            if (hints[i].indexOf(query) === 0) {\n                                foundPrefix = true;\n                                break;\n                            }\n                        }\n                        if (!foundPrefix) {\n                            query = null;\n                        }\n                    }\n                }\n            }\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME && offset === 0) {\n                    this.exclusion = this.tagInfo.attr.name;\n                } else {\n                    this.updateExclusion(false);\n                }\n            }\n\n            return query !== null;\n        }\n        if (implicitChar === \" \" || implicitChar === \"'\" ||\n                    implicitChar === \"\\\"\" || implicitChar === \"=\") {\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                this.exclusion = this.tagInfo.attr.name;\n            }\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML attribute hints if possible for the\n     * current editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    AttrHints.prototype.getHints = function (implicitChar) {\n        var cursor = this.editor.getCursorPos(),\n            query = {queryStr: null},\n            tokenType,\n            offset,\n            result = [];\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, cursor);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (tokenType === HTMLUtils.ATTR_NAME || tokenType === HTMLUtils.ATTR_VALUE) {\n            query.tag = this.tagInfo.tagName;\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME) {\n                    query.queryStr = this.tagInfo.attr.name.slice(0, offset);\n                } else {\n                    query.queryStr = this.tagInfo.attr.value.slice(0, offset);\n                    query.attrName = this.tagInfo.attr.name;\n                }\n                this.updateExclusion(false);\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                // We get negative offset for a quoted attribute value with some leading whitespaces\n                // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                // So just set the queryStr to an empty string.\n                query.queryStr = \"\";\n                query.attrName = this.tagInfo.attr.name;\n            }\n\n            query.usedAttr = HTMLUtils.getTagAttributes(this.editor, cursor);\n        }\n\n        if (query.tag && query.queryStr !== null) {\n            var tagName = query.tag,\n                attrName = query.attrName,\n                filter = query.queryStr,\n                unfiltered = [],\n                hints;\n\n            if (attrName) {\n                hints = this._getValueHintsForAttr(query, tagName, attrName);\n            } else if (tags && tags[tagName] && tags[tagName].attributes) {\n                unfiltered = tags[tagName].attributes.concat(this.globalAttributes);\n                hints = $.grep(unfiltered, function (attr, i) {\n                    return $.inArray(attr, query.usedAttr) < 0;\n                });\n            }\n\n            if (hints instanceof Array && hints.length) {\n                console.assert(!result.length);\n                result = $.map(hints, function (item) {\n                    if (item.indexOf(filter) === 0) {\n                        return item;\n                    }\n                }).sort();\n                return {\n                    hints: result,\n                    match: query.queryStr,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            } else if (hints instanceof Object && hints.hasOwnProperty(\"done\")) { // Deferred hints\n                var deferred = $.Deferred();\n                hints.done(function (asyncHints) {\n                    deferred.resolveWith(this, [{\n                        hints: asyncHints,\n                        match: asyncHints.alreadyMatched? null: query.queryStr,\n                        selectInitial: true,\n                        handleWideResults: false\n                    }]);\n                });\n                return deferred;\n            }\n            return null;\n\n        }\n\n\n    };\n\n    /**\n     * Inserts a given HTML attribute hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    AttrHints.prototype.insertHint = function (completion) {\n        var cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            tokenType = this.tagInfo.position.tokenType,\n            offset = this.tagInfo.position.offset,\n            charCount = 0,\n            insertedName = false,\n            replaceExistingOne = this.tagInfo.attr.valueAssigned,\n            endQuote = \"\",\n            shouldReplace = true,\n            positionWithinAttributeVal = false,\n            textAfterCursor;\n\n        if (tokenType === HTMLUtils.ATTR_NAME) {\n            textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                replaceExistingOne = false;\n            } else {\n                charCount = this.tagInfo.attr.name.length;\n            }\n            // Append an equal sign and two double quotes if the current attr is not an empty attr\n            // and then adjust cursor location before the last quote that we just inserted.\n            if (!replaceExistingOne && attributes && attributes[completion] &&\n                    attributes[completion].type !== \"flag\") {\n                completion += \"=\\\"\\\"\";\n                insertedName = true;\n            } else if (completion === this.tagInfo.attr.name) {\n                shouldReplace = false;\n            }\n        } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n            textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                // Set exclusion to null only after attribute value insertion,\n                // not after attribute name insertion since we need to keep it\n                // for attribute value insertion.\n                this.exclusion = null;\n            } else {\n                charCount = this.tagInfo.attr.value.length;\n            }\n\n            if(this.tagInfo.attr.name === \"class\") {\n                // css class hints\n                completion = completion.data(\"val\");\n                // \"anotherClass class<cursor>name\" . completion = classics , we have to match a prefix after space\n                const textBeforeCursor = this.tagInfo.attr.value.slice(0, offset);\n                let lastSegment = textBeforeCursor.split(\" \");\n                lastSegment = lastSegment[lastSegment.length-1];\n                offset = lastSegment.length;\n                charCount = offset;\n                positionWithinAttributeVal = true;\n            }\n\n            if (!this.tagInfo.attr.hasEndQuote) {\n                endQuote = this.tagInfo.attr.quoteChar;\n                if (endQuote) {\n                    completion += endQuote;\n                } else if (offset === 0) {\n                    completion = \"\\\"\" + completion + \"\\\"\";\n                }\n            } else if (completion === this.tagInfo.attr.value) {\n                shouldReplace = false;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - offset;\n        end.ch = start.ch + charCount;\n\n        if (shouldReplace) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n        }\n\n        if(positionWithinAttributeVal){\n            this.editor.setCursorPos(start.line, start.ch + completion.length);\n            // we're now inside the double-quotes we just inserted\n        } else if (insertedName) {\n            this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\n\n            // Since we're now inside the double-quotes we just inserted,\n            // immediately pop up the attribute value hint.\n            return true;\n        } else if (tokenType === HTMLUtils.ATTR_VALUE && this.tagInfo.attr.hasEndQuote) {\n            // Move the cursor to the right of the existing end quote after value insertion.\n            this.editor.setCursorPos(start.line, start.ch + completion.length + 1);\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function NewDocContentProvider() {\n        this.CONTENT_PROVIDER_NAME = \"HTMLCodeHints\";\n    }\n\n    NewDocContentProvider.prototype.getContent = function(fileName) {\n        return new Promise((resolve, reject)=>{\n            if(fileName.endsWith(\".xhtml\")){\n                resolve(XHTMLTemplate);\n                return;\n            }\n            resolve(HTMLTemplate);\n        });\n    };\n\n    AppInit.appReady(function () {\n        // Parse JSON files\n        tags = JSON.parse(HTMLTags);\n        attributes = JSON.parse(HTMLAttributes);\n\n        // Register code hint providers\n        let tagHints = new TagHints();\n        let attrHints = new AttrHints();\n        let newDocContentProvider = new NewDocContentProvider();\n        CodeHintManager.registerHintProvider(tagHints, [\"html\"], 0);\n        CodeHintManager.registerHintProvider(attrHints, [\"html\"], 0);\n        NewFileContentManager.registerContentProvider(newDocContentProvider, [\"html\"], 0);\n\n        // For unit testing\n        exports.tagHintProvider = tagHints;\n        exports.attrHintProvider = attrHints;\n    });\n});\n"],"file":"main.js"}
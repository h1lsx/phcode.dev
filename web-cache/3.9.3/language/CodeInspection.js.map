{"version":3,"sources":["language/CodeInspection.js"],"names":["define","require","exports","module","_","Commands","WorkspaceManager","CommandManager","DocumentManager","EditorManager","Dialogs","Editor","MainViewManager","LanguageManager","PreferencesManager","PerfUtils","Strings","StringUtils","AppInit","StatusBar","Async","PanelTemplate","ResultsTemplate","Mustache","QuickViewManager","Metrics","CODE_INSPECTION_GUTTER_PRIORITY","CODE_INSPECTION_GUTTER","EDIT_ORIGIN_LINT_FIX","INDICATOR_ID","Type","ERROR","WARNING","META","_getIconClassForType","type","isFixable","CODE_MARK_TYPE_INSPECTOR","PREF_ENABLED","PREF_COLLAPSED","PREF_ASYNC_TIMEOUT","PREF_PREFER_PROVIDERS","PREF_PREFERRED_ONLY","prefs","getExtensionPrefs","_enabled","_collapsed","$problemsPanel","$fixAllBtn","problemsPanel","$problemsPanelTable","_gotoEnabled","_providers","_registeredLanguageIDs","_hasErrors","_currentPromise","setGotoEnabled","gotoEnabled","get","NAVIGATE_GOTO_FIRST_PROBLEM","setEnabled","NAVIGATE_GOTO_NEXT_PROBLEM","NAVIGATE_GOTO_PREV_PROBLEM","_unregisterAll","getProvidersForPath","filePath","language","getLanguageForPath","getId","context","_buildContext","installedProviders","getProvidersForLanguageId","preferredProviders","prefPreferredProviderNames","prefPreferredOnly","providers","length","reduce","result","key","provider","find","name","push","union","getProviderIDsForLanguage","languageId","map","inspectFile","file","providerList","response","$","Deferred","results","fullPath","filter","canInspect","getDocumentText","done","fileText","perfTimerInspector","markStart","masterPromise","doInParallel","perfTimerProvider","runPromise","scanResult","scanFileAsync","window","setTimeout","errTimeout","pos","line","col","message","format","LINTER_TIMED_OUT","resolve","errors","jsPromise","then","addMeasurement","catch","err","Error","finalizeMeasurement","errError","LINTER_FAILED","console","error","stack","scanFile","promise","sort","a","b","indexOf","fail","reject","updatePanelTitleAndStatusBar","numProblems","providersReportingProblems","aborted","fileName","tooltip","addClass","hide","removeClass","documentFixes","size","MULTIPLE_ERRORS_FIXABLE","MULTIPLE_ERRORS","SINGLE_ERROR_FIXABLE","SINGLE_ERROR","show","ERRORS_PANEL_TITLE_MULTIPLE_FIXABLE","ERRORS_PANEL_TITLE_MULTIPLE","text","STATUSBAR_CODE_INSPECTION_TOOLTIP","iconType","updateIndicator","_getMarkOptions","getMarkOptionUnderlineError","getMarkOptionUnderlineWarn","getMarkOptionUnderlineInfo","_getMarkTypePriority","_shouldMarkTokenAtPosition","editor","isNaN","ch","warn","_createMarkerElement","$marker","attr","trim","click","setCursorPos","toggleCollapsed","scrollToProblem","html","_addDummyGutterMarkerIfNotExist","marker","getGutterMarker","setGutterMarker","_populateDummyGutterElements","from","to","_updateGutterMarks","gutterErrorMessages","lineno","Object","keys","highestPriorityMarkTypeSeen","fixableMarkFound","gutterMessage","prev","current","fixable","getLastVisibleLine","_editorVieportChangeHandler","_evt","gutterRegistrationInProgress","gutterViewportChangeTimer","clearTimeout","vp","getViewport","lineNumber","$lineElement","scrollIntoView","behavior","block","parent","getQuickView","token","Promise","codeInspectionMarks","findMarksAt","$hoverMessage","quickViewPresent","startPos","start","endPos","end","mark","$problemView","fixID","metadata","errorMessageHTML","escape","CLICK_VIEW_PROBLEM","FIX","COPY_ERROR","countEvent","EVENT_TYPE","LINT","_fixProblem","append","selection","getSelection","rangeCount","isCollapsed","evt","preventDefault","stopPropagation","Phoenix","app","copyToClipboard","markPos","content","fixIDCounter","Map","lastDocumentScanTimeStamp","_registerNewFix","fix","providerName","maxOffset","rangeOffset","document","lastChangeTimestamp","clear","_isInvalidFix","set","_updateEditorMarksAndFixResults","resultProviderEntries","getCurrentFullEditor","getText","operation","off","on","resultProvider","markOptions","id","isSamePosition","markText","markToken","scrollPositionMap","_noProviderReturnedResults","currentDoc","fullFilePath","path","basename","ERRORS_NO_FILE","NO_LINT_AVAILABLE","getName","NOTHING_TO_LINT","run","LINT_DISABLED","getCurrentDocument","allErrors","lintFilePath","scrollTop","providerResult","isIgnored","clearAllMarks","clearGutter","this","item","Boolean","NO_ERRORS_MULTIPLE_PROVIDER","NO_ERRORS","perfTimerDOM","forEach","inspectionResult","isExpanded","undefined","codeSnippet","getLine","friendlyLine","substr","iconClass","display","render","reportList","empty","scrollPosition","lastRunTime","register","indexOfProvider","findIndex","entry","splice","includes","unregisterGutter","registerGutter","concat","updateListeners","event","toggleEnabled","enabled","doNotSave","VIEW_TOGGLE_INSPECTION","setChecked","save","toggleProblems","collapsed","handleGotoFirstProblem","first","trigger","handleGotoNextProblem","currentCursor","getCursorPos","nextMarks","getMarksAfter","nextMark","i","markRange","nextMarkRange","handleGotoPrevProblem","prevMarks","getMarksBefore","prevMark","prevMarkRange","fixDetails","isNumber","replaceText","posFromIndex","setSelection","BOUNDARY_BULLSEYE","replaceSelection","showErrorDialog","CANNOT_FIX_TITLE","CANNOT_FIX_MESSAGE","focusActivePane","_fixAllProblems","replacements","values","replaceMultipleRanges","finalCursor","isTestWindow","currentTime","Date","now","CMD_VIEW_TOGGLE_INSPECTION","CMD_VIEW_TOGGLE_PROBLEMS","VIEW_TOGGLE_PROBLEMS","CMD_GOTO_FIRST_PROBLEM","CMD_GOTO_NEXT_PROBLEM","CMD_GOTO_PREV_PROBLEM","definePreference","brackets","config","description","DESCRIPTION_LINTING_ENABLED","e","data","DESCRIPTION_LINTING_COLLAPSED","DESCRIPTION_ASYNC_TIMEOUT","DESCRIPTION_LINTING_PREFER","valueType","DESCRIPTION_USE_PREFERED_ONLY","htmlReady","panelHtml","$selectedRow","checkSelectionInsideElement","range","element","endOffset","startOffset","startNode","startContainer","endNode","endContainer","contains","createBottomPanel","target","hasClass","currentTarget","$triangle","nextUntil","toggleClass","val","getRangeAt","lineTd","parseInt","character","statusIconHtml","addIndicator","registerQuickViewProvider","QUICK_VIEW_NAME","appReady","_PREF_ASYNC_TIMEOUT","_PREF_PREFER_PROVIDERS","_PREF_PREFERRED_ONLY","requestRun"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global jsPromise, path*/\n\n/**\n * Manages linters and other code inspections on a per-language basis. Provides a UI and status indicator for\n * the resulting errors/warnings.\n *\n * Currently, inspection providers are only invoked on the current file and only when it is opened, switched to,\n * or saved. But in the future, inspectors may be invoked as part of a global scan, at intervals while typing, etc.\n * Currently, results are only displayed in a bottom panel list and in a status bar icon. But in the future,\n * results may also be displayed inline in the editor (as gutter markers, etc.).\n * In the future, support may also be added for error/warning providers that cannot process a single file at a time\n * (e.g. a full-project compiler).\n */\ndefine(function (require, exports, module) {\n\n\n    const _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    const Commands                = require(\"command/Commands\"),\n        WorkspaceManager        = require(\"view/WorkspaceManager\"),\n        CommandManager          = require(\"command/CommandManager\"),\n        DocumentManager         = require(\"document/DocumentManager\"),\n        EditorManager           = require(\"editor/EditorManager\"),\n        Dialogs                 = require(\"widgets/Dialogs\"),\n        Editor                  = require(\"editor/Editor\").Editor,\n        MainViewManager         = require(\"view/MainViewManager\"),\n        LanguageManager         = require(\"language/LanguageManager\"),\n        PreferencesManager      = require(\"preferences/PreferencesManager\"),\n        PerfUtils               = require(\"utils/PerfUtils\"),\n        Strings                 = require(\"strings\"),\n        StringUtils             = require(\"utils/StringUtils\"),\n        AppInit                 = require(\"utils/AppInit\"),\n        StatusBar               = require(\"widgets/StatusBar\"),\n        Async                   = require(\"utils/Async\"),\n        PanelTemplate           = require(\"text!htmlContent/problems-panel.html\"),\n        ResultsTemplate         = require(\"text!htmlContent/problems-panel-table.html\"),\n        Mustache                = require(\"thirdparty/mustache/mustache\"),\n        QuickViewManager  = require(\"features/QuickViewManager\"),\n        Metrics           = require(\"utils/Metrics\");\n\n    const CODE_INSPECTION_GUTTER_PRIORITY      = 500,\n        CODE_INSPECTION_GUTTER = \"code-inspection-gutter\";\n\n    const EDIT_ORIGIN_LINT_FIX = \"lint_fix\";\n\n    const INDICATOR_ID = \"status-inspection\";\n\n    /** Values for problem's 'type' property */\n    const Type = {\n        /** Unambiguous error, such as a syntax error */\n        ERROR: \"error\",\n        /** Maintainability issue, probable error / bad smell, etc. */\n        WARNING: \"warning\",\n        /** Inspector unable to continue, code too complex for static analysis, etc. Not counted in err/warn tally. */\n        META: \"meta\"\n    };\n\n    function _getIconClassForType(type, isFixable) {\n        switch (type) {\n        case Type.ERROR: return isFixable ?\n            \"line-icon-problem_type_error fa-solid fa-wrench\":\n            \"line-icon-problem_type_error fa-solid fa-times-circle\";\n        case Type.WARNING: return isFixable ?\n            \"line-icon-problem_type_warning fa-solid fa-wrench\":\n            \"line-icon-problem_type_warning fa-solid fa-exclamation-triangle\";\n        case Type.META: return isFixable ?\n            \"line-icon-problem_type_info fa-solid fa-wrench\":\n            \"line-icon-problem_type_info fa-solid fa-info-circle\";\n        default: return isFixable ?\n            \"line-icon-problem_type_info fa-solid fa-wrench\":\n            \"line-icon-problem_type_info fa-solid fa-info-circle\";\n        }\n    }\n\n    const CODE_MARK_TYPE_INSPECTOR = \"codeInspector\";\n\n    /**\n     * Constants for the preferences defined in this file.\n     */\n    const PREF_ENABLED            = \"enabled\",\n        PREF_COLLAPSED          = \"collapsed\",\n        PREF_ASYNC_TIMEOUT      = \"asyncTimeout\",\n        PREF_PREFER_PROVIDERS   = \"prefer\",\n        PREF_PREFERRED_ONLY     = \"usePreferredOnly\";\n\n    const prefs = PreferencesManager.getExtensionPrefs(\"linting\");\n\n    /**\n     * When disabled, the errors panel is closed and the status bar icon is grayed out.\n     * Takes precedence over _collapsed.\n     * @private\n     * @type {boolean}\n     */\n    var _enabled = false;\n\n    /**\n     * When collapsed, the errors panel is closed but the status bar icon is kept up to date.\n     * @private\n     * @type {boolean}\n     */\n    var _collapsed = false;\n\n    /**\n     * @private\n     * @type {$.Element}\n     */\n    var $problemsPanel;\n\n    let $fixAllBtn;\n\n    /**\n     * @private the panelView\n     * @type {Panel}\n     */\n    var problemsPanel;\n\n    /**\n     * @private\n     * @type {$.Element}\n     */\n    var $problemsPanelTable;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    var _gotoEnabled = false;\n\n    /**\n     * @private\n     * @type {{languageId:string, Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>}}\n     */\n    var _providers = {};\n\n    /**\n     * @private\n     * @type\n     */\n    let _registeredLanguageIDs = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    var _hasErrors;\n\n    /**\n     * Promise of the returned by the last call to inspectFile or null if linting is disabled. Used to prevent any stale promises\n     * to cause updates of the UI.\n     *\n     * @private\n     * @type {$.Promise}\n     */\n    var _currentPromise = null;\n\n    /**\n     * Enable or disable the \"Go to First Error\" command\n     * @param {boolean} gotoEnabled Whether it is enabled.\n     */\n    function setGotoEnabled(gotoEnabled) {\n        CommandManager.get(Commands.NAVIGATE_GOTO_FIRST_PROBLEM).setEnabled(gotoEnabled);\n        CommandManager.get(Commands.NAVIGATE_GOTO_NEXT_PROBLEM).setEnabled(gotoEnabled);\n        CommandManager.get(Commands.NAVIGATE_GOTO_PREV_PROBLEM).setEnabled(gotoEnabled);\n        _gotoEnabled = gotoEnabled;\n    }\n\n    function _unregisterAll() {\n        _providers = {};\n    }\n\n    /**\n     * Returns a list of provider for given file path, if available.\n     * Decision is made depending on the file extension.\n     *\n     * @param {!string} filePath\n     * @return {Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>}\n     */\n    function getProvidersForPath(filePath) {\n        var language            = LanguageManager.getLanguageForPath(filePath).getId(),\n            context             = PreferencesManager._buildContext(filePath, language),\n            installedProviders  = getProvidersForLanguageId(language),\n            preferredProviders,\n\n            prefPreferredProviderNames  = prefs.get(PREF_PREFER_PROVIDERS, context),\n            prefPreferredOnly           = prefs.get(PREF_PREFERRED_ONLY, context),\n\n            providers;\n\n        if (prefPreferredProviderNames && prefPreferredProviderNames.length) {\n            if (typeof prefPreferredProviderNames === \"string\") {\n                prefPreferredProviderNames = [prefPreferredProviderNames];\n            }\n            preferredProviders = prefPreferredProviderNames.reduce(function (result, key) {\n                var provider = _.find(installedProviders, {name: key});\n                if (provider) {\n                    result.push(provider);\n                }\n                return result;\n            }, []);\n            if (prefPreferredOnly) {\n                providers = preferredProviders;\n            } else {\n                providers = _.union(preferredProviders, installedProviders);\n            }\n        } else {\n            providers = installedProviders;\n        }\n        return providers;\n    }\n\n    /**\n     * Returns an array of the IDs of providers registered for a specific language\n     *\n     * @param {!string} languageId\n     * @return {Array.<string>} Names of registered providers.\n     */\n    function getProviderIDsForLanguage(languageId) {\n        if (!_providers[languageId]) {\n            return [];\n        }\n        return _providers[languageId].map(function (provider) {\n            return provider.name;\n        });\n    }\n\n    /**\n     * Runs a file inspection over passed file. Uses the given list of providers if specified, otherwise uses\n     * the set of providers that are registered for the file's language.\n     * This method doesn't update the Brackets UI, just provides inspection results.\n     * These results will reflect any unsaved changes present in the file if currently open.\n     *\n     * The Promise yields an array of provider-result pair objects (the result is the return value of the\n     * provider's scanFile() - see register() for details). The result object may be null if there were no\n     * errors from that provider.\n     * If there are no providers registered for this file, the Promise yields null instead.\n     *\n     * @param {!File} file File that will be inspected for errors.\n     * @param {?Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>} providerList\n     * @return {$.Promise} a jQuery promise that will be resolved with ?Array.<{provider:Object, result: ?{errors:!Array, aborted:boolean}}>\n     */\n    function inspectFile(file, providerList) {\n        var response = new $.Deferred(),\n            results = [];\n\n        providerList = providerList || getProvidersForPath(file.fullPath);\n\n        if (!providerList.length) {\n            response.resolve(null);\n            return response.promise();\n        }\n\n        providerList = providerList.filter(function (provider) {\n            return !provider.canInspect || provider.canInspect(file.fullPath);\n        });\n\n        DocumentManager.getDocumentText(file)\n            .done(function (fileText) {\n                var perfTimerInspector = PerfUtils.markStart(\"CodeInspection:\\t\" + file.fullPath),\n                    masterPromise;\n\n                masterPromise = Async.doInParallel(providerList, function (provider) {\n                    var perfTimerProvider = PerfUtils.markStart(\"CodeInspection '\" + provider.name + \"':\\t\" + file.fullPath),\n                        runPromise = new $.Deferred();\n\n                    runPromise.done(function (scanResult) {\n                        results.push({provider: provider, result: scanResult});\n                    });\n\n                    if (provider.scanFileAsync) {\n                        window.setTimeout(function () {\n                            // timeout error\n                            var errTimeout = {\n                                pos: { line: -1, col: 0},\n                                message: StringUtils.format(Strings.LINTER_TIMED_OUT, provider.name, prefs.get(PREF_ASYNC_TIMEOUT)),\n                                type: Type.ERROR\n                            };\n                            runPromise.resolve({errors: [errTimeout]});\n                        }, prefs.get(PREF_ASYNC_TIMEOUT));\n                        jsPromise(provider.scanFileAsync(fileText, file.fullPath))\n                            .then(function (scanResult) {\n                                PerfUtils.addMeasurement(perfTimerProvider);\n                                runPromise.resolve(scanResult);\n                            })\n                            .catch(function (err) {\n                                err = err || new Error(\"Unknown error while inspecting \"+ file.fullPath);\n                                PerfUtils.finalizeMeasurement(perfTimerProvider);\n                                var errError = {\n                                    pos: {line: -1, col: 0},\n                                    message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\n                                    type: Type.ERROR\n                                };\n                                console.error(\"[CodeInspection] Provider \" + provider.name + \" (async) failed: \" + err.stack);\n                                runPromise.resolve({errors: [errError]});\n                            });\n                    } else {\n                        try {\n                            var scanResult = provider.scanFile(fileText, file.fullPath);\n                            PerfUtils.addMeasurement(perfTimerProvider);\n                            runPromise.resolve(scanResult);\n                        } catch (err) {\n                            PerfUtils.finalizeMeasurement(perfTimerProvider);\n                            var errError = {\n                                pos: {line: -1, col: 0},\n                                message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\n                                type: Type.ERROR\n                            };\n                            console.error(\"[CodeInspection] Provider \" + provider.name +\n                                \" (sync) threw an error: \" + err && (err.stack || err));\n                            runPromise.resolve({errors: [errError]});\n                        }\n                    }\n                    return runPromise.promise();\n\n                }, false);\n\n                masterPromise.then(function () {\n                    // sync async may have pushed results in different order, restore the original order\n                    results.sort(function (a, b) {\n                        return providerList.indexOf(a.provider) - providerList.indexOf(b.provider);\n                    });\n                    PerfUtils.addMeasurement(perfTimerInspector);\n                    response.resolve(results);\n                });\n\n            })\n            .fail(function (err) {\n                console.error(\"[CodeInspection] Could not read file for inspection: \" + file.fullPath);\n                response.reject(err);\n            });\n\n        return response.promise();\n    }\n\n    /**\n     * Update the title of the problem panel and the tooltip of the status bar icon. The title and the tooltip will\n     * change based on the number of problems reported and how many provider reported problems.\n     *\n     * @param {Number} numProblems - total number of problems across all providers\n     * @param {Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>} providersReportingProblems - providers that reported problems\n     * @param {boolean} aborted - true if any provider returned a result with the 'aborted' flag set\n     * @param fileName\n     */\n    function updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted, fileName) {\n        $fixAllBtn.addClass(\"forced-hidden\");\n        var message, tooltip;\n\n        if (providersReportingProblems.length === 1) {\n            // don't show a header if there is only one provider available for this file type\n            $problemsPanelTable.find(\".inspector-section\").hide();\n            $problemsPanelTable.find(\"tr\").removeClass(\"forced-hidden\");\n\n            if (numProblems === 1 && !aborted) {\n                message = documentFixes.size ?\n                    StringUtils.format(Strings.SINGLE_ERROR_FIXABLE, providersReportingProblems[0].name,\n                        documentFixes.size, fileName):\n                    StringUtils.format(Strings.SINGLE_ERROR, providersReportingProblems[0].name, fileName);\n            } else {\n                if (aborted) {\n                    numProblems += \"+\";\n                }\n\n                message = documentFixes.size ?\n                    StringUtils.format(Strings.MULTIPLE_ERRORS_FIXABLE, numProblems,\n                        providersReportingProblems[0].name, documentFixes.size, fileName):\n                    StringUtils.format(Strings.MULTIPLE_ERRORS, numProblems,\n                        providersReportingProblems[0].name, fileName);\n            }\n        } else if (providersReportingProblems.length > 1) {\n            $problemsPanelTable.find(\".inspector-section\").show();\n\n            if (aborted) {\n                numProblems += \"+\";\n            }\n\n            message = documentFixes.size ?\n                StringUtils.format(Strings.ERRORS_PANEL_TITLE_MULTIPLE_FIXABLE, numProblems,\n                    documentFixes.size, fileName):\n                StringUtils.format(Strings.ERRORS_PANEL_TITLE_MULTIPLE, numProblems, fileName);\n        } else {\n            return;\n        }\n\n        $problemsPanel.find(\".title\").text(message);\n        tooltip = StringUtils.format(Strings.STATUSBAR_CODE_INSPECTION_TOOLTIP, message);\n        let iconType = \"inspection-errors\";\n        if(documentFixes.size){\n            iconType =  \"inspection-repair\";\n            $fixAllBtn.removeClass(\"forced-hidden\");\n        }\n\n        StatusBar.updateIndicator(INDICATOR_ID, true, iconType, tooltip);\n    }\n\n    function _getMarkOptions(error){\n        switch (error.type) {\n        case Type.ERROR: return Editor.getMarkOptionUnderlineError();\n        case Type.WARNING: return Editor.getMarkOptionUnderlineWarn();\n        case Type.META: return Editor.getMarkOptionUnderlineInfo();\n        }\n    }\n\n    function _getMarkTypePriority(type){\n        switch (type) {\n        case Type.ERROR: return 3;\n        case Type.WARNING: return 2;\n        case Type.META: return 1;\n        }\n    }\n\n    function _shouldMarkTokenAtPosition(editor, error) {\n        if(isNaN(error.pos.line) || isNaN(error.pos.ch) || error.pos.line < 0 || error.pos.ch < 0){\n            console.warn(\"CodeInspector: Invalid error position: \", error);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * It creates a div element with a span element inside it, and then adds a click handler to move cursor to the\n     * error position.\n     * @param editor - the editor instance\n     * @param line - the line number of the error\n     * @param ch - the character position of the error\n     * @param type - The type of the marker. This is a string that can be one of the error types\n     * @param message - The message that will be displayed when you hover over the marker.\n     * @param isFixable - true if we need to use the fix icon\n     * @returns A DOM element.\n     */\n    function _createMarkerElement(editor, line, ch, type, message, isFixable) {\n        let $marker = $('<div><span>')\n            .attr('title', (message || \"\").trim())\n            .addClass(CODE_INSPECTION_GUTTER);\n        $marker.click(function (){\n            editor.setCursorPos(line, ch);\n            toggleCollapsed(false);\n            scrollToProblem(line);\n        });\n        $marker.find('span')\n            .addClass(_getIconClassForType(type, isFixable))\n            .addClass(\"brackets-inspection-gutter-marker\")\n            .html('&nbsp;');\n        return $marker[0];\n    }\n\n    /**\n     * We have to draw empty gutter markers if it doesnt exist, else there is a visual gap in the gutter when\n     * codemirror renders gutter with lines having no gutter icons\n     * @param editor\n     * @param line\n     * @private\n     */\n    function _addDummyGutterMarkerIfNotExist(editor, line) {\n        let marker = editor.getGutterMarker(line, CODE_INSPECTION_GUTTER);\n        if(!marker){\n            let $marker = $('<div>')\n                .addClass(CODE_INSPECTION_GUTTER);\n            editor.setGutterMarker(line, CODE_INSPECTION_GUTTER, $marker[0]);\n        }\n    }\n\n    function _populateDummyGutterElements(editor, from, to) {\n        for(let line=from; line <= to; line++) {\n            _addDummyGutterMarkerIfNotExist(editor, line);\n        }\n    }\n\n    function _updateGutterMarks(editor, gutterErrorMessages) {\n        // add gutter icons\n        for(let lineno of Object.keys(gutterErrorMessages)){\n            // We mark the line with the Highest priority icon. (Eg. error icon if same line has warnings and info)\n            let highestPriorityMarkTypeSeen = Type.META;\n            let fixableMarkFound = false;\n            let gutterMessage = gutterErrorMessages[lineno].reduce((prev, current)=>{\n                if(current.fixable || prev.fixable){\n                    fixableMarkFound = true;\n                }\n                if(_getMarkTypePriority(current.type) > _getMarkTypePriority(highestPriorityMarkTypeSeen)){\n                    highestPriorityMarkTypeSeen = current.type;\n                }\n                return {message: `${prev.message}\\n${current.message} at column: ${current.ch+1}`};\n            }, {message: ''});\n            let line = gutterErrorMessages[lineno][0].line,\n                ch = gutterErrorMessages[lineno][0].ch,\n                message = gutterMessage.message;\n            let marker = _createMarkerElement(editor, line, ch, highestPriorityMarkTypeSeen, message, fixableMarkFound);\n            editor.setGutterMarker(line, CODE_INSPECTION_GUTTER, marker);\n        }\n        _populateDummyGutterElements(editor, 0, editor.getLastVisibleLine());\n    }\n\n    function _editorVieportChangeHandler(_evt, editor, from, to) {\n        if(gutterRegistrationInProgress){\n            if(editor.gutterViewportChangeTimer){\n                clearTimeout(editor.gutterViewportChangeTimer);\n            }\n            editor.gutterViewportChangeTimer = setTimeout(()=>{\n                const vp = editor.getViewport();\n                _editorVieportChangeHandler(_evt, editor, vp.from, vp.to);\n                clearTimeout(editor.gutterViewportChangeTimer);\n                delete editor.gutterViewportChangeTimer;\n            });\n            return;\n        }\n        _populateDummyGutterElements(editor, from, to);\n    }\n\n    function scrollToProblem(lineNumber) {\n        const $lineElement = $problemsPanelTable.find('td.line-number[data-line=\"' + lineNumber + '\"]');\n        if ($lineElement.length) {\n            $lineElement[0].scrollIntoView({ behavior: 'instant', block: 'start' });\n            return $($lineElement[0]).parent();\n        }\n        return null;\n    }\n\n\n    function getQuickView(editor, pos, token, line) {\n        return new Promise((resolve, reject)=>{\n            let codeInspectionMarks = editor.findMarksAt(pos, CODE_MARK_TYPE_INSPECTOR) || [];\n            let $hoverMessage = $(`<div class=\"code-inspection-item\"></div>`);\n            let quickViewPresent;\n            let startPos = {line: pos.line, ch: token.start},\n                endPos = {line: pos.line, ch: token.end};\n            for(let mark of codeInspectionMarks){\n                let $problemView;\n                quickViewPresent = true;\n                const fixID = `${mark.metadata}`;\n                let errorMessageHTML = `<a style=\"cursor:pointer;color: unset;\">${_.escape(mark.message)}</a>`;\n                if(documentFixes.get(fixID)){\n                    $problemView = $(`<div class=\"code-inspection-quick-view-item\">\n                        <i title=\"${Strings.CLICK_VIEW_PROBLEM}\" style=\"margin-right: 3px;cursor: pointer;\"\n                            class=\"${_getIconClassForType(mark.type, mark.isFixable)}\"></i>\n                        <button class=\"btn btn-mini fix-problem-btn\" style=\"margin-right: 5px;\">${Strings.FIX}</button>\n                        ${errorMessageHTML}\n                        <button class=\"btn btn-mini copy-qv-error-text-btn\" title=\"${Strings.COPY_ERROR}\">\n                            <i class=\"fas fa-copy copy-qv-error-text-btn\"></i>\n                        </button>\n                        <br/>\n                    </div>`);\n                    $problemView.find(\".fix-problem-btn\").click(()=>{\n                        Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"fixClick\", \"quickView\");\n                        scrollToProblem(pos.line);\n                        _fixProblem(fixID);\n                    });\n                    $hoverMessage.append($problemView);\n                } else {\n                    $problemView = $(`<div class=\"code-inspection-quick-view-item\">\n                        <i title=\"${Strings.CLICK_VIEW_PROBLEM}\" style=\"margin-right: 5px; cursor: pointer;\"\n                            class=\"${_getIconClassForType(mark.type, mark.isFixable)}\"></i>\n                        ${errorMessageHTML}\n                        <button class=\"btn btn-mini copy-qv-error-text-btn\" title=\"${Strings.COPY_ERROR}\">\n                            <i class=\"fas fa-copy copy-qv-error-text-btn\"></i>\n                        </button>\n                        <br/></div>`);\n                    $hoverMessage.append($problemView);\n                }\n                $problemView.click(function () {\n                    const selection = window.getSelection();\n                    if(selection && selection.rangeCount > 0 && !selection.isCollapsed) {\n                        // the user may be trying to select text from the error in quick view, in which case we\n                        // shouldnt open the problems panel\n                        return;\n                    }\n                    toggleCollapsed(false);\n                    scrollToProblem(pos.line);\n                    // todo strobe effect\n                });\n                $problemView.find(\".copy-qv-error-text-btn\").click(function (evt) {\n                    evt.preventDefault();\n                    evt.stopPropagation();\n                    Phoenix.app.copyToClipboard(mark.message);\n                });\n                const markPos = mark.find();\n                if(markPos.from && markPos.from.line < startPos.line){\n                    startPos.line = markPos.from.line;\n                }\n                if(markPos.from && markPos.from.ch < startPos.ch){\n                    startPos.ch = markPos.from.ch;\n                }\n                if(markPos.to && markPos.to.line > endPos.line){\n                    endPos.line = markPos.to.line;\n                }\n                if(markPos.to && markPos.to.ch > endPos.ch){\n                    endPos.ch = markPos.to.ch;\n                }\n            }\n            if(quickViewPresent){\n                Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"quickView\", \"shown\");\n                resolve({\n                    start: startPos,\n                    end: endPos,\n                    content: $hoverMessage\n                });\n                return;\n            }\n            reject();\n        });\n    }\n\n    let fixIDCounter = 1;\n    let documentFixes = new Map(), lastDocumentScanTimeStamp;\n    function _registerNewFix(editor, fix, providerName, maxOffset) {\n        if(!editor || !fix || !fix.rangeOffset) {\n            return null;\n        }\n        if(editor.document.lastChangeTimestamp !== lastDocumentScanTimeStamp){\n            // the document changed from the last time the fixes where registered, we have to\n            // invalidate all existing fixes in that case.\n            lastDocumentScanTimeStamp = editor.document.lastChangeTimestamp;\n            documentFixes.clear();\n        }\n        if(_isInvalidFix(fix, maxOffset)){\n            return null;\n        }\n        fixIDCounter++;\n        fix.providerName = providerName;\n        documentFixes.set(`${fixIDCounter}`, fix);\n        return fixIDCounter;\n    }\n\n    /**\n     * Adds gutter icons and squiggly lines under err/warn/info to editor after lint.\n     * also updates  the passed in resultProviderEntries with fixes that can be applied.\n     * @param resultProviderEntries\n     * @private\n     */\n    function _updateEditorMarksAndFixResults(resultProviderEntries) {\n        let editor = EditorManager.getCurrentFullEditor();\n        if(!(editor && resultProviderEntries && resultProviderEntries.length)) {\n            return;\n        }\n        const maxOffset = editor.document.getText().length;\n        editor.operation(function () {\n            editor.off(\"viewportChange.codeInspection\");\n            editor.on(\"viewportChange.codeInspection\", _editorVieportChangeHandler);\n            let gutterErrorMessages = {};\n            for (let resultProvider of resultProviderEntries) {\n                let errors = (resultProvider.result && resultProvider.result.errors) || [];\n                for (let error of errors) {\n                    let line = error.pos.line || 0;\n                    let ch = error.pos.ch || 0;\n                    let fixable = false;\n                    // add squiggly lines\n                    if (_shouldMarkTokenAtPosition(editor, error)) {\n                        let mark;\n                        const markOptions = _getMarkOptions(error);\n                        const fixID = _registerNewFix(editor, error.fix, resultProvider.provider.name, maxOffset);\n                        if(fixID) {\n                            markOptions.metadata = fixID;\n                            markOptions.isFixable = true;\n                            error.fix.id = fixID;\n                            fixable = true;\n                        }\n                        if(error.endPos && !editor.isSamePosition(error.pos, error.endPos)) {\n                            mark = editor.markText(CODE_MARK_TYPE_INSPECTOR, error.pos, error.endPos, markOptions);\n                        } else {\n                            mark = editor.markToken(CODE_MARK_TYPE_INSPECTOR, error.pos, markOptions);\n                        }\n                        mark.type = error.type;\n                        mark.message = error.message;\n                    }\n                    let gutterMessage = gutterErrorMessages[line] || [];\n                    gutterMessage.push({message: error.message, type: error.type, fixable, line, ch});\n                    gutterErrorMessages[line] = gutterMessage;\n                }\n            }\n            _updateGutterMarks(editor, gutterErrorMessages);\n        });\n    }\n\n    const scrollPositionMap = new Map();\n\n    function _noProviderReturnedResults(currentDoc, fullFilePath) {\n        // No provider for current file\n        _hasErrors = false;\n        _currentPromise = null;\n        updatePanelTitleAndStatusBar(0, [], false,\n            fullFilePath ? path.basename(fullFilePath) : Strings.ERRORS_NO_FILE);\n        if(problemsPanel){\n            problemsPanel.hide();\n        }\n        const language = currentDoc && LanguageManager.getLanguageForPath(currentDoc.file.fullPath);\n        if (language) {\n            StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\",\n                StringUtils.format(Strings.NO_LINT_AVAILABLE, language.getName()));\n        } else {\n            StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", Strings.NOTHING_TO_LINT);\n        }\n        setGotoEnabled(false);\n    }\n\n    /**\n     * Run inspector applicable to current document. Updates status bar indicator and refreshes error list in\n     * bottom panel. Does not run if inspection is disabled or if a providerName is given and does not\n     * match the current doc's provider name.\n     *\n     * @param {?string} providerName name of the provider that is requesting a run\n     */\n    function run() {\n        if(!problemsPanel){\n            return;\n        }\n        if (!_enabled) {\n            _hasErrors = false;\n            _currentPromise = null;\n            problemsPanel.hide();\n            StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", Strings.LINT_DISABLED);\n            setGotoEnabled(false);\n            return;\n        }\n\n        let currentDoc = DocumentManager.getCurrentDocument(),\n            providerList = currentDoc && getProvidersForPath(currentDoc.file.fullPath);\n\n        providerList = providerList && providerList.filter(function (provider) {\n            return !provider.canInspect || provider.canInspect(currentDoc.file.fullPath);\n        });\n\n        let editor = EditorManager.getCurrentFullEditor(), fullFilePath;\n        if(editor){\n            lastDocumentScanTimeStamp = editor.document.lastChangeTimestamp;\n            documentFixes.clear();\n            fullFilePath = editor.document.file.fullPath;\n        }\n\n        if (providerList && providerList.length) {\n            let numProblems = 0,\n                aborted = false,\n                allErrors = [],\n                html,\n                providersReportingProblems = [];\n            scrollPositionMap.set($problemsPanelTable.lintFilePath || fullFilePath, $problemsPanelTable.scrollTop());\n\n            // run all the providers registered for this file type\n            (_currentPromise = inspectFile(currentDoc.file, providerList)).then(function (results) {\n                // filter out any ignored results\n                results = results.filter(function (providerResult) {\n                    return !providerResult.result || !providerResult.result.isIgnored;\n                });\n                if(!results.length) {\n                    _noProviderReturnedResults(currentDoc, fullFilePath);\n                    return;\n                }\n                editor.clearAllMarks(CODE_MARK_TYPE_INSPECTOR);\n                editor.clearGutter(CODE_INSPECTION_GUTTER);\n                _updateEditorMarksAndFixResults(results);\n                // check if promise has not changed while inspectFile was running\n                if (this !== _currentPromise) {\n                    return;\n                }\n\n                // how many errors in total?\n                var errors = results.reduce(function (a, item) { return a + (item.result ? item.result.errors.length : 0); }, 0);\n\n                _hasErrors = Boolean(errors);\n\n                if (!errors) {\n                    problemsPanel.hide();\n\n                    var message = Strings.NO_ERRORS_MULTIPLE_PROVIDER;\n                    if (providerList.length === 1) {\n                        message = StringUtils.format(Strings.NO_ERRORS, providerList[0].name);\n                    }\n\n                    StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-valid\", message);\n\n                    setGotoEnabled(false);\n                    return;\n                }\n\n                var perfTimerDOM = PerfUtils.markStart(\"ProblemsPanel render:\\t\" + currentDoc.file.fullPath);\n\n                // Augment error objects with additional fields needed by Mustache template\n                results.forEach(function (inspectionResult) {\n                    var provider = inspectionResult.provider;\n                    var isExpanded = prefs.get(provider.name + \".collapsed\") !== false;\n\n                    if (inspectionResult.result) {\n                        inspectionResult.result.errors.forEach(function (error) {\n                            // some inspectors don't always provide a line number or report a negative line number\n                            if (!isNaN(error.pos.line) &&\n                                    (error.pos.line + 1) > 0 &&\n                                    (error.codeSnippet = currentDoc.getLine(error.pos.line)) !== undefined) {\n                                error.friendlyLine = error.pos.line + 1;\n                                error.codeSnippet = error.codeSnippet.substr(0, 175);  // limit snippet width\n                            }\n\n                            if (error.type !== Type.META) {\n                                numProblems++;\n                            }\n\n                            error.iconClass = _getIconClassForType(error.type, error.fix && error.fix.id);\n\n                            // Hide the errors when the provider is collapsed.\n                            error.display = isExpanded ? \"\" : \"forced-hidden\";\n                        });\n\n                        // if the code inspector was unable to process the whole file, we keep track to show a different status\n                        if (inspectionResult.result.aborted) {\n                            aborted = true;\n                        }\n\n                        if (inspectionResult.result.errors.length) {\n                            allErrors.push({\n                                isExpanded: isExpanded,\n                                providerName: provider.name,\n                                results: inspectionResult.result.errors\n                            });\n\n                            providersReportingProblems.push(provider);\n                        }\n                    }\n                });\n\n                // Update results table\n                html = Mustache.render(ResultsTemplate, {Strings: Strings, reportList: allErrors});\n\n                $problemsPanelTable.lintFilePath = fullFilePath;\n                $problemsPanelTable\n                    .empty()\n                    .append(html);  // otherwise scroll pos from previous contents is remembered\n\n                if (!_collapsed) {\n                    problemsPanel.show();\n                }\n\n                updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted,\n                    path.basename(fullFilePath));\n                setGotoEnabled(true);\n\n                const scrollPosition = scrollPositionMap.get(fullFilePath) || 0;\n                $problemsPanelTable.scrollTop(scrollPosition);\n                PerfUtils.addMeasurement(perfTimerDOM);\n            });\n\n        } else {\n            _noProviderReturnedResults(currentDoc, fullFilePath);\n        }\n    }\n\n    let gutterRegistrationInProgress = false;\n\n    /**\n     * Registers a provider for a specific language to inspect files and provide linting results.\n     *\n     * The provider is passed the text of the file and its full path. Providers should not assume that\n     * the file is open (i.e., `DocumentManager.getOpenDocumentForPath()` may return `null`) or that the\n     * file on disk matches the text given (the file may have unsaved changes).\n     *\n     * Registering any provider for the \"javascript\" language automatically unregisters the built-in\n     * Brackets JSLint provider. This is a temporary convenience until a UI exists for disabling\n     * registered providers.\n     *\n     * Providers must implement `canInspect()`, `scanFile()`, or `scanFileAsync()`. If both `scanFile()`\n     * and `scanFileAsync()` are implemented, `scanFile()` is ignored.\n     *\n     * - `canInspect(fullPath)`: A synchronous call to determine if the file can be scanned by this provider.\n     * - `scanFile(text, fullPath)`: A synchronous function returning linting results or `null`.\n     * - `scanFileAsync(text, fullPath)`: An asynchronous function returning a jQuery Promise resolved with\n     *   the same type of value as `scanFile()`. Rejecting the promise is treated as an internal error in the provider.\n     *\n     * Each error object in the results should have the following structure:\n     *              { pos:{line,ch},\n     *                endPos:?{line,ch},\n     *                message:string,\n     *                htmlMessage:string,\n     *                type:?Type ,\n     *                fix: { // an optional fix, if present will show the fix button\n     *                     replace: \"text to replace the offset given below\",\n     *                     rangeOffset: {\n     *                         start: number,\n     *                         end: number\n     *                }}}\n     * @typedef {Object} Error\n     * @property {Object} pos - The start position of the error.\n     * @property {number} pos.line - The line number (0-based).\n     * @property {number} pos.ch - The character position within the line (0-based).\n     * @property {?Object} endPos - The end position of the error.\n     * @property {number} endPos.line - The end line number (0-based).\n     * @property {number} endPos.ch - The end character position within the line (0-based).\n     * @property {string} message - The error message to be displayed as text.\n     * @property {string} htmlMessage - The error message to be displayed as HTML.\n     * @property {?Type} type - The type of the error. Defaults to `Type.WARNING` if unspecified.\n     * @property {?Object} fix - An optional fix object.\n     * @property {string} fix.replace - The text to replace the error with.\n     * @property {Object} fix.rangeOffset - The range within the text to replace.\n     * @property {number} fix.rangeOffset.start - The start offset of the range.\n     * @property {number} fix.rangeOffset.end - The end offset of the range.\n     *\n     * If no errors are found, return either `null`(treated as file is problem free) or an object with a\n     * zero-length `errors` array. Always use `message` to safely display the error as text. If you want to display HTML\n     * error message, then explicitly use `htmlMessage` to display it. Both `message` and `htmlMessage` can\n     * be used simultaneously.\n     *\n     * After scanning the file, if you need to omit the lint result, return or resolve with `{isIgnored: true}`.\n     * This prevents the file from being marked with a no errors tick mark in the status bar and excludes the linter\n     * from the problems panel.\n     *\n     * @param {string} languageId - The language ID for which the provider is registered.\n     * @param {Object} provider - The provider object.\n     * @param {string} provider.name - The name of the provider.\n     * @param {?function(string, string): { errors: Array<Error>, aborted: boolean }} provider.scanFile - Synchronous scan function.\n     * @param {?function(string, string): jQuery.Promise} provider.scanFileAsync - Asynchronous scan function returning a Promise.\n     */\n    function register(languageId, provider) {\n        if (!_providers[languageId]) {\n            _providers[languageId] = [];\n        } else {\n            // Check if provider with same name exists for the given language\n            // If yes, remove the provider before inserting the most recently loaded one\n            var indexOfProvider = _.findIndex(_providers[languageId], function(entry) { return entry.name === provider.name; });\n            if (indexOfProvider !== -1) {\n                _providers[languageId].splice(indexOfProvider, 1);\n            }\n        }\n\n        _providers[languageId].push(provider);\n\n        if(!_registeredLanguageIDs.includes(languageId)){\n            _registeredLanguageIDs.push(languageId);\n            gutterRegistrationInProgress = true;\n            Editor.unregisterGutter(CODE_INSPECTION_GUTTER);\n            gutterRegistrationInProgress = false;\n            Editor.registerGutter(CODE_INSPECTION_GUTTER, CODE_INSPECTION_GUTTER_PRIORITY, _registeredLanguageIDs);\n        }\n\n        run();  // in case a file of this type is open currently\n    }\n\n    /**\n     * Returns a list of providers registered for given languageId through register function\n     */\n    function getProvidersForLanguageId(languageId) {\n        var result = [];\n        if (_providers[languageId]) {\n            result = result.concat(_providers[languageId]);\n        }\n        if (_providers['*']) {\n            result = result.concat(_providers['*']);\n        }\n        return result;\n    }\n\n    /**\n     * Update DocumentManager listeners.\n     */\n    function updateListeners() {\n        if (_enabled) {\n            // register our event listeners\n            MainViewManager\n                .on(\"currentFileChange.codeInspection\", function () {\n                    run();\n                });\n            DocumentManager\n                .on(\"currentDocumentLanguageChanged.codeInspection\", function () {\n                    run();\n                })\n                .on(\"documentSaved.codeInspection documentRefreshed.codeInspection\", function (event, document) {\n                    if (document === DocumentManager.getCurrentDocument()) {\n                        run();\n                    }\n                });\n        } else {\n            DocumentManager.off(\".codeInspection\");\n            MainViewManager.off(\".codeInspection\");\n        }\n    }\n\n    /**\n     * Enable or disable all inspection.\n     * @param {?boolean} enabled Enabled state. If omitted, the state is toggled.\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\n     */\n    function toggleEnabled(enabled, doNotSave) {\n        if (enabled === undefined) {\n            enabled = !_enabled;\n        }\n\n        // Take no action when there is no change.\n        if (enabled === _enabled) {\n            return;\n        }\n\n        _enabled = enabled;\n\n        CommandManager.get(Commands.VIEW_TOGGLE_INSPECTION).setChecked(_enabled);\n        updateListeners();\n        if (!doNotSave) {\n            prefs.set(PREF_ENABLED, _enabled);\n            prefs.save();\n        }\n\n        // run immediately\n        run();\n    }\n\n    function toggleProblems() {\n        toggleCollapsed();\n    }\n\n    let lastRunTime;\n    $(window.document).on(\"mousemove\", ()=>{\n        if(Phoenix.isTestWindow){\n            return;\n        }\n        const editor = EditorManager.getCurrentFullEditor();\n        if(!editor || editor.document.lastChangeTimestamp === lastDocumentScanTimeStamp) {\n            return;\n        }\n        const currentTime = Date.now();\n        if(lastRunTime && (currentTime - lastRunTime) < 1000) {\n            // we dont run the linter on mouse operations more than 1 times a second.\n            return;\n        }\n        lastRunTime = currentTime;\n        run();\n    });\n\n    /**\n     * Toggle the collapsed state for the panel. This explicitly collapses the panel (as opposed to\n     * the auto collapse due to files with no errors & filetypes with no provider). When explicitly\n     * collapsed, the panel will not reopen automatically on switch files or save.\n     *\n     * @param {?boolean} collapsed Collapsed state. If omitted, the state is toggled.\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\n     */\n    function toggleCollapsed(collapsed, doNotSave) {\n        if (collapsed === undefined) {\n            collapsed = !_collapsed;\n        }\n\n        if (collapsed === _collapsed) {\n            return;\n        }\n\n        _collapsed = collapsed;\n        if (!doNotSave) {\n            prefs.set(PREF_COLLAPSED, _collapsed);\n            prefs.save();\n        }\n\n        if (_collapsed) {\n            problemsPanel.hide();\n        } else {\n            if (_hasErrors) {\n                problemsPanel.show();\n            }\n        }\n    }\n\n    /** Command to go to the first Problem */\n    function handleGotoFirstProblem() {\n        run();\n        if (_gotoEnabled) {\n            $problemsPanel.find(\"tr:not(.inspector-section)\").first().trigger(\"click\");\n        }\n    }\n\n    function handleGotoNextProblem() {\n        if (_gotoEnabled) {\n            const editor = EditorManager.getCurrentFullEditor();\n            if(!editor){\n                return;\n            }\n            const currentCursor = editor.getCursorPos();\n            const nextMarks = editor.getMarksAfter(currentCursor, CODE_MARK_TYPE_INSPECTOR);\n            if(!nextMarks.length || !nextMarks[0].find()){\n                return;\n            }\n\n            let nextMark = null;\n            for (let i = 0; i < nextMarks.length; i++) {\n                const markRange = nextMarks[i].find();\n                if (markRange && (markRange.from.line > currentCursor.line ||\n                    (markRange.from.line === currentCursor.line && markRange.from.ch > currentCursor.ch))) {\n                    nextMark = nextMarks[i];\n                    break;\n                }\n            }\n\n            if (!nextMark) {\n                return;\n            }\n            const nextMarkRange = nextMark.find();\n            if (nextMarkRange) {\n                editor.setCursorPos(nextMarkRange.from.line, nextMarkRange.from.ch);\n            }\n        }\n    }\n\n    function handleGotoPrevProblem() {\n        if (_gotoEnabled) {\n            const editor = EditorManager.getCurrentFullEditor();\n            if (!editor) {\n                return;\n            }\n            const currentCursor = editor.getCursorPos();\n            const prevMarks = editor.getMarksBefore(currentCursor, CODE_MARK_TYPE_INSPECTOR);\n\n            if (!prevMarks.length) {\n                return;\n            }\n\n            let prevMark = null;\n            for (let i = prevMarks.length - 1; i >= 0; i--) {\n                const markRange = prevMarks[i].find();\n                if (markRange && (markRange.to.line < currentCursor.line ||\n                    (markRange.to.line === currentCursor.line && markRange.to.ch < currentCursor.ch))) {\n                    prevMark = prevMarks[i];\n                    break;\n                }\n            }\n\n            if (!prevMark) {\n                return;\n            }\n\n            const prevMarkRange = prevMark.find();\n            if (prevMarkRange) {\n                editor.setCursorPos(prevMarkRange.from.line, prevMarkRange.from.ch);\n            }\n        }\n    }\n\n    // Register command handlers\n    CommandManager.register(Strings.CMD_VIEW_TOGGLE_INSPECTION, Commands.VIEW_TOGGLE_INSPECTION,        toggleEnabled);\n    CommandManager.register(Strings.CMD_VIEW_TOGGLE_PROBLEMS, Commands.VIEW_TOGGLE_PROBLEMS,        toggleProblems);\n    CommandManager.register(Strings.CMD_GOTO_FIRST_PROBLEM,     Commands.NAVIGATE_GOTO_FIRST_PROBLEM,   handleGotoFirstProblem);\n    CommandManager.register(Strings.CMD_GOTO_NEXT_PROBLEM,     Commands.NAVIGATE_GOTO_NEXT_PROBLEM,   handleGotoNextProblem);\n    CommandManager.register(Strings.CMD_GOTO_PREV_PROBLEM,     Commands.NAVIGATE_GOTO_PREV_PROBLEM,   handleGotoPrevProblem);\n\n    // Register preferences\n    prefs.definePreference(PREF_ENABLED, \"boolean\", brackets.config[\"linting.enabled_by_default\"], {\n        description: Strings.DESCRIPTION_LINTING_ENABLED\n    })\n        .on(\"change\", function (e, data) {\n            toggleEnabled(prefs.get(PREF_ENABLED), true);\n        });\n\n    prefs.definePreference(PREF_COLLAPSED, \"boolean\", false, {\n        description: Strings.DESCRIPTION_LINTING_COLLAPSED\n    })\n        .on(\"change\", function (e, data) {\n            toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\n        });\n\n    prefs.definePreference(PREF_ASYNC_TIMEOUT, \"number\", 10000, {\n        description: Strings.DESCRIPTION_ASYNC_TIMEOUT\n    });\n\n    prefs.definePreference(PREF_PREFER_PROVIDERS, \"array\", [], {\n        description: Strings.DESCRIPTION_LINTING_PREFER,\n        valueType: \"string\"\n    });\n\n    prefs.definePreference(PREF_PREFERRED_ONLY, \"boolean\", false, {\n        description: Strings.DESCRIPTION_USE_PREFERED_ONLY\n    });\n\n    function _isInvalidFix(fixDetails, maxOffset) {\n        return (!_.isNumber(fixDetails.rangeOffset.start) || !_.isNumber(fixDetails.rangeOffset.end) ||\n            fixDetails.rangeOffset.start < 0 || fixDetails.rangeOffset.end < 0 ||\n            fixDetails.rangeOffset.start > maxOffset || fixDetails.rangeOffset.end > maxOffset ||\n            typeof fixDetails.replaceText !== \"string\");\n    }\n\n    function _fixProblem(fixID) {\n        const fixDetails = documentFixes.get(fixID);\n        const editor = EditorManager.getCurrentFullEditor();\n        const maxOffset = editor.document.getText().length;\n        if(!editor || !fixDetails || editor.document.lastChangeTimestamp !== lastDocumentScanTimeStamp) {\n            Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"fixFail\", \"dialogShown\");\n            Dialogs.showErrorDialog(Strings.CANNOT_FIX_TITLE, Strings.CANNOT_FIX_MESSAGE);\n        } else if(_isInvalidFix(fixDetails, maxOffset)){\n            Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"fixFail\", \"invalid\");\n            console.error(\"Invalid fix:\", fixDetails); // this should never happen as we filter the fix while inserting\n        } else {\n            const from = editor.posFromIndex(fixDetails.rangeOffset.start),\n                to =  editor.posFromIndex(fixDetails.rangeOffset.end);\n            editor.setSelection(from, to, true, Editor.BOUNDARY_BULLSEYE, EDIT_ORIGIN_LINT_FIX);\n            editor.replaceSelection(fixDetails.replaceText, \"around\");\n        }\n        MainViewManager.focusActivePane();\n        run();\n    }\n\n    function _fixAllProblems() {\n        const editor = EditorManager.getCurrentFullEditor();\n        if(!editor || editor.document.lastChangeTimestamp !== lastDocumentScanTimeStamp) {\n            Dialogs.showErrorDialog(Strings.CANNOT_FIX_TITLE, Strings.CANNOT_FIX_MESSAGE);\n            return;\n        }\n        if(!documentFixes.size){\n            return;\n        }\n        const replacements = [];\n        const maxOffset = editor.document.getText().length;\n        for(let fixDetails of documentFixes.values()){\n            if(_isInvalidFix(fixDetails, maxOffset)){\n                console.error(\"Invalid fix:\", fixDetails); // this should never happen\n            }\n            replacements.push({\n                from: editor.posFromIndex(fixDetails.rangeOffset.start),\n                to: editor.posFromIndex(fixDetails.rangeOffset.end),\n                text: fixDetails.replaceText\n            });\n        }\n        editor.replaceMultipleRanges(replacements, EDIT_ORIGIN_LINT_FIX);\n        const finalCursor = replacements[replacements.length - 1].from;\n        editor.setCursorPos(finalCursor.line, finalCursor.ch);\n        MainViewManager.focusActivePane();\n        run();\n    }\n\n    // Initialize items dependent on HTML DOM\n    AppInit.htmlReady(function () {\n        Editor.registerGutter(CODE_INSPECTION_GUTTER, CODE_INSPECTION_GUTTER_PRIORITY);\n        // Create bottom panel to list error details\n        var panelHtml = Mustache.render(PanelTemplate, Strings);\n        problemsPanel = WorkspaceManager.createBottomPanel(\"errors\", $(panelHtml), 100);\n        $problemsPanel = $(\"#problems-panel\");\n        $fixAllBtn = $problemsPanel.find(\".problems-fix-all-btn\");\n        $fixAllBtn.click(()=>{\n            Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"fixAllClick\", \"panel\");\n            _fixAllProblems();\n        });\n\n        function checkSelectionInsideElement(range, element) {\n            if(!range || range.endOffset === range.startOffset) {\n                return false; // this is a cursor, not a selection.\n            }\n            const startNode = range.startContainer;\n            const endNode = range.endContainer;\n\n            // Checking if the selection's start and end nodes are within the specified element\n            return $.contains(element, startNode) && $.contains(element, endNode);\n        }\n\n        var $selectedRow;\n        $problemsPanelTable = $problemsPanel.find(\".table-container\")\n            .on(\"click\", \"tr\", function (e) {\n                if ($(e.target).hasClass('ph-copy-problem')) {\n                    // Retrieve the message from the data attribute of the clicked element\n                    let message = $(e.target).parent().parent().find(\".line-text\").text();\n                    if(!message){\n                        message = $(e.target).parent().parent().parent().find(\".line-text\").text();\n                    }\n                    message && Phoenix.app.copyToClipboard(message);\n                    e.preventDefault();\n                    e.stopPropagation();\n                    MainViewManager.focusActivePane();\n                    return;\n                }\n                if ($(e.target).hasClass('ph-fix-problem')) {\n                    // Retrieve the message from the data attribute of the clicked element\n                    Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"fixClick\", \"panel\");\n                    _fixProblem(\"\" + $(e.target).data(\"fixid\"));\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return;\n                }\n\n                if ($selectedRow) {\n                    $selectedRow.removeClass(\"selected\");\n                }\n\n                $selectedRow  = $(e.currentTarget);\n                $selectedRow.addClass(\"selected\");\n\n                // This is a inspector title row, expand/collapse on click\n                if ($selectedRow.hasClass(\"inspector-section\")) {\n                    var $triangle = $(\".disclosure-triangle\", $selectedRow);\n                    var isExpanded = $triangle.hasClass(\"expanded\");\n\n                    // Clicking the inspector title section header collapses/expands result rows\n                    if (isExpanded) {\n                        $selectedRow.nextUntil(\".inspector-section\").addClass(\"forced-hidden\");\n                    } else {\n                        $selectedRow.nextUntil(\".inspector-section\").removeClass(\"forced-hidden\");\n                    }\n                    $triangle.toggleClass(\"expanded\");\n\n                    var providerName = $selectedRow.find(\"input[type='hidden']\").val();\n                    prefs.set(providerName + \".collapsed\", !isExpanded);\n                    prefs.save();\n                } else {\n                    const selection = window.getSelection();\n                    if (selection.rangeCount > 0) {\n                        const range = selection.getRangeAt(0);\n                        if(checkSelectionInsideElement(range, $problemsPanel[0])){\n                            // some text is selected in the problems panel, user may want to copy the text, so\n                            // dont set focus to the text area.\n                            return;\n                        }\n                    }\n                    // This is a problem marker row, show the result on click\n                    // Grab the required position data\n                    var lineTd    = $selectedRow.find(\".line-number\");\n                    var line      = parseInt(lineTd.text(), 10) - 1;  // convert friendlyLine back to pos.line\n                    // if there is no line number available, don't do anything\n                    if (!isNaN(line)) {\n                        var character = lineTd.data(\"character\");\n\n                        var editor = EditorManager.getCurrentFullEditor();\n                        editor.setCursorPos(line, character, true);\n                        MainViewManager.focusActivePane();\n                    }\n                }\n            });\n\n        $(\"#problems-panel .close\").click(function () {\n            toggleCollapsed(true);\n            MainViewManager.focusActivePane();\n        });\n\n        // Status bar indicator - icon & tooltip updated by run()\n        var statusIconHtml = Mustache.render(\"<div id=\\\"status-inspection\\\">&nbsp;</div>\", Strings);\n        StatusBar.addIndicator(INDICATOR_ID, $(statusIconHtml), true, \"\", \"\", \"status-indent\");\n\n        $(\"#status-inspection\").click(function () {\n            // Clicking indicator toggles error panel, if any errors in current file\n            if (_hasErrors) {\n                toggleCollapsed();\n            }\n        });\n\n        // Set initial UI state\n        toggleEnabled(prefs.get(PREF_ENABLED), true);\n        toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\n\n        QuickViewManager.registerQuickViewProvider({\n            getQuickView,\n            QUICK_VIEW_NAME: \"CodeInspection\"\n        }, [\"all\"]);\n    });\n\n    AppInit.appReady(function () {\n        // on boot the linter is not somehow showing the lint editor underlines at first time. So we trigger a run\n        // after 2 seconds\n        if(!Phoenix.isTestWindow) {\n            setTimeout(run, 2000);\n        }\n    });\n\n    // Testing\n    exports._unregisterAll          = _unregisterAll;\n    exports._PREF_ASYNC_TIMEOUT     = PREF_ASYNC_TIMEOUT;\n    exports._PREF_PREFER_PROVIDERS  = PREF_PREFER_PROVIDERS;\n    exports._PREF_PREFERRED_ONLY    = PREF_PREFERRED_ONLY;\n\n    // Public API\n    exports.CODE_INSPECTION_GUTTER      = CODE_INSPECTION_GUTTER;\n    exports.register                    = register;\n    exports.Type                        = Type;\n    exports.toggleEnabled               = toggleEnabled;\n    exports.inspectFile                 = inspectFile;\n    exports.requestRun                  = run;\n    exports.getProvidersForPath         = getProvidersForPath;\n    exports.getProviderIDsForLanguage   = getProviderIDsForLanguage;\n    exports.scrollToProblem             = scrollToProblem;\n});\n"],"file":"CodeInspection.js"}
{"version":3,"sources":["filesystem/File.js"],"names":["define","require","exports","module","FileSystemEntry","File","fullPath","fileSystem","this","_isFile","call","_insertIfNotPresent","addedList","file","length","foundEntry","find","entry","push","prototype","Object","create","constructor","parentClass","_contents","_encoding","_preserveBOM","_hash","_clearCachedData","apply","read","options","callback","encoding","_stat","bypassCache","watched","_isWatched","stat","_impl","readFile","_path","err","data","preserveBOM","doNotCache","bind","write","undefined","blind","expectedHash","expectedContents","_fileSystem","_beginChange","writeFile","created","_endChange","parent","getDirectoryForPath","parentPath","_handleDirectoryChange","added","removed","_fireChangeEvent"],"mappings":"AAqBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,gBAAkBH,QAAQ,8BAe9B,SAASI,KAAKC,SAAUC,YACpBC,KAAKC,SAAU,EACfL,gBAAgBM,KAAKF,KAAMF,SAAUC,YAyGzC,SAASI,oBAAoBC,UAAWC,MACpC,IAAID,YAAcA,UAAUE,OACxB,MAAO,CAACD,MAEZ,MAAME,WAAaH,UAAUI,KAAKC,OAASA,MAAMX,WAAaO,KAAKP,UAInE,OAHIS,YACAH,UAAUM,KAAKL,MAEZD,UA9GXP,KAAKc,UAAYC,OAAOC,OAAOjB,gBAAgBe,WAC/Cd,KAAKc,UAAUG,YAAcjB,KAC7BA,KAAKc,UAAUI,YAAcnB,gBAAgBe,UAO7Cd,KAAKc,UAAUK,UAAY,KAQ3BnB,KAAKc,UAAUM,UAAY,KAO3BpB,KAAKc,UAAUO,cAAe,EAU9BrB,KAAKc,UAAUQ,MAAQ,KAOvBtB,KAAKc,UAAUS,iBAAmB,WAC9BxB,gBAAgBe,UAAUS,iBAAiBC,MAAMrB,MACjDA,KAAKgB,UAAY,MAWrBnB,KAAKc,UAAUW,KAAO,SAAUC,QAASC,UAYrC,GAXyB,mBAAd,UACPA,SAAWD,SACXA,QAAU,IACFE,SAAWzB,KAAKiB,WAE5BM,QAAQE,SAAWF,QAAQE,UAAYzB,KAAKiB,WAAa,OAMlC,OAAnBjB,KAAKgB,YAAsBhB,KAAK0B,OAASH,QAAQE,WAAazB,KAAKiB,WAAcM,QAAQI,YAA7F,CAKA,IAAIC,QAAU5B,KAAK6B,aACfD,UACAL,QAAQO,KAAO9B,KAAK0B,OAGxB1B,KAAK+B,MAAMC,SAAShC,KAAKiC,MAAOV,QAAS,SAAUW,IAAKC,KAAMV,SAAUW,YAAaN,MACjF,GAAII,IAKA,OAJIX,QAAQc,YACRrC,KAAKoB,wBAETI,SAASU,KAITX,QAAQc,aAERrC,KAAKmB,MAAQW,KAAKX,MAClBnB,KAAKiB,UAAYQ,SACjBzB,KAAKkB,aAAekB,YAGhBR,UACA5B,KAAK0B,MAAQI,KACb9B,KAAKgB,UAAYmB,OAIzBX,SAASU,IAAKC,KAAMV,SAAUK,OAChCQ,KAAKtC,YAhCHwB,SAAS,KAAMxB,KAAKgB,UAAWhB,KAAKiB,UAAWjB,KAAK0B,QAuD5D7B,KAAKc,UAAU4B,MAAQ,SAAUJ,KAAMZ,QAASC,UACrB,mBAAZD,SACPC,SAAWD,QACXA,QAAU,UAEMiB,IAAZjB,UACAA,QAAU,IAGdC,SAAWA,UAAY,cAItBD,QAAQkB,QACTlB,QAAQmB,aAAe1C,KAAKmB,MAC5BI,QAAQoB,iBAAmB3C,KAAKgB,WAE/BO,QAAQE,WACTF,QAAQE,SAAWzB,KAAKiB,WAAa,QAEzCM,QAAQa,YAAcpC,KAAKkB,aAG3BlB,KAAK4C,YAAYC,eAEjB7C,KAAK+B,MAAMe,UAAU9C,KAAKiC,MAAOE,KAAMZ,QAAS,SAAUW,IAAKJ,KAAMiB,SACjE,GAAIb,IAAJ,CACIlC,KAAKoB,mBACL,IACII,SAASU,KACX,QAEElC,KAAK4C,YAAYI,mBAczB,GARAhD,KAAKmB,MAAQW,KAAKX,MAGdnB,KAAK6B,eACL7B,KAAK0B,MAAQI,KACb9B,KAAKgB,UAAYmB,MAGjBY,QAAS,CACT,IAAIE,OAASjD,KAAK4C,YAAYM,oBAAoBlD,KAAKmD,YACvDnD,KAAK4C,YAAYQ,uBAAuBH,OAAQ,SAAUI,MAAOC,SAC7D,IAEI9B,SAAS,KAAMM,MACjB,QACMmB,OAAOpB,eAGPwB,MAAQlD,oBAAoBkD,MAAOrD,MACnCA,KAAK4C,YAAYW,iBAAiBN,OAAQI,MAAOC,UAIrDtD,KAAK4C,YAAYI,eAEvBV,KAAKtC,YAEP,IAEIwB,SAAS,KAAMM,MACjB,QAEE9B,KAAK4C,YAAYW,iBAAiBvD,MAGlCA,KAAK4C,YAAYI,eAG3BV,KAAKtC,QAIXL,OAAOD,QAAUG","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var FileSystemEntry = require(\"filesystem/FileSystemEntry\");\n\n\n    /*\n     * Model for a File.\n     *\n     * This class should *not* be instantiated directly. Use FileSystem.getFileForPath,\n     * FileSystem.resolve, or Directory.getContents to create an instance of this class.\n     *\n     * See the FileSystem class for more details.\n     *\n     * @constructor\n     * @param {!string} fullPath The full path for this File.\n     * @param {!FileSystem} fileSystem The file system associated with this File.\n     */\n    function File(fullPath, fileSystem) {\n        this._isFile = true;\n        FileSystemEntry.call(this, fullPath, fileSystem);\n    }\n\n    File.prototype = Object.create(FileSystemEntry.prototype);\n    File.prototype.constructor = File;\n    File.prototype.parentClass = FileSystemEntry.prototype;\n\n    /**\n     * Cached contents of this file. This value is nullable but should NOT be undefined.\n     * @private\n     * @type {?string}\n     */\n    File.prototype._contents = null;\n\n\n    /**\n     * Encoding detected by brackets-shell\n     * @private\n     * @type {?string}\n     */\n    File.prototype._encoding = null;\n\n    /**\n     * BOM detected by brackets-shell\n     * @private\n     * @type {?bool}\n     */\n    File.prototype._preserveBOM = false;\n\n    /**\n     * Consistency hash for this file. Reads and writes update this value, and\n     * writes confirm the hash before overwriting existing files. The type of\n     * this object is dependent on the FileSystemImpl; the only constraint is\n     * that === can be used as an equality relation on hashes.\n     * @private\n     * @type {?object}\n     */\n    File.prototype._hash = null;\n\n    /**\n     * Clear any cached data for this file. Note that this explicitly does NOT\n     * clear the file's hash.\n     * @private\n     */\n    File.prototype._clearCachedData = function () {\n        FileSystemEntry.prototype._clearCachedData.apply(this);\n        this._contents = null;\n    };\n\n    /**\n     * Read a file.\n     *\n     * @param {Object=} options properties {encoding: 'one of format supported here:\n     * https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/encoding'}\n     * @param {function (?string, string=, FileSystemStats=)} callback Callback that is passed the\n     *              FileSystemError string or the file's contents and its stats.\n     */\n    File.prototype.read = function (options, callback) {\n        if (typeof (options) === \"function\") {\n            callback = options;\n            options = {};\n            options.encoding = this._encoding;\n        }\n        options.encoding = options.encoding || this._encoding || \"utf8\";\n\n        // We don't need to check isWatched() here because contents are only saved\n        // for watched files. Note that we need to explicitly test this._contents\n        // for a default value; otherwise it could be the empty string, which is\n        // falsey.\n        if (this._contents !== null && this._stat && options.encoding === this._encoding && !options.bypassCache) {\n            callback(null, this._contents, this._encoding, this._stat);\n            return;\n        }\n\n        var watched = this._isWatched();\n        if (watched) {\n            options.stat = this._stat;\n        }\n\n        this._impl.readFile(this._path, options, function (err, data, encoding, preserveBOM, stat) {\n            if (err) {\n                if(!options.doNotCache){\n                    this._clearCachedData();\n                }\n                callback(err);\n                return;\n            }\n\n            if(!options.doNotCache) {\n                // Always store the hash\n                this._hash = stat._hash;\n                this._encoding = encoding;\n                this._preserveBOM = preserveBOM;\n\n                // Only cache data for watched files\n                if (watched) {\n                    this._stat = stat;\n                    this._contents = data;\n                }\n            }\n\n            callback(err, data, encoding, stat);\n        }.bind(this));\n    };\n\n    function _insertIfNotPresent(addedList, file) {\n        if(!addedList || !addedList.length) {\n            return [file];\n        }\n        const foundEntry = addedList.find(entry => entry.fullPath === file.fullPath);\n        if(!foundEntry){\n            addedList.push(file);\n        }\n        return addedList;\n    }\n\n    /**\n     * Write a file.\n     *\n     * @param {string} data Data to write.\n     * @param {Object=} options properties {encoding: 'one of format supported here:\n     * https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/encoding'}\n     * @param {function (?string, FileSystemStats=)=} callback Callback that is passed the\n     *              FileSystemError string or the file's new stats.\n     */\n    File.prototype.write = function (data, options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        } else {\n            if (options === undefined) {\n                options = {};\n            }\n\n            callback = callback || function () {};\n        }\n\n        // Request a consistency check if the write is not blind\n        if (!options.blind) {\n            options.expectedHash = this._hash;\n            options.expectedContents = this._contents;\n        }\n        if (!options.encoding) {\n            options.encoding = this._encoding || \"utf8\";\n        }\n        options.preserveBOM = this._preserveBOM;\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._impl.writeFile(this._path, data, options, function (err, stat, created) {\n            if (err) {\n                this._clearCachedData();\n                try {\n                    callback(err);\n                } finally {\n                    // Always unblock external change events\n                    this._fileSystem._endChange();\n                }\n                return;\n            }\n\n            // Always store the hash\n            this._hash = stat._hash;\n\n            // Only cache data for watched files\n            if (this._isWatched()) {\n                this._stat = stat;\n                this._contents = data;\n            }\n\n            if (created) {\n                var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n                this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                    try {\n                        // Notify the caller\n                        callback(null, stat);\n                    } finally {\n                        if (parent._isWatched()) {\n                            // If the write succeeded and the parent directory is watched,\n                            // fire a synthetic change event\n                            added = _insertIfNotPresent(added, this);\n                            this._fileSystem._fireChangeEvent(parent, added, removed);\n\n                        }\n                        // Always unblock external change events\n                        this._fileSystem._endChange();\n                    }\n                }.bind(this));\n            } else {\n                try {\n                    // Notify the caller\n                    callback(null, stat);\n                } finally {\n                    // existing file modified\n                    this._fileSystem._fireChangeEvent(this);\n\n                    // Always unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }\n        }.bind(this));\n    };\n\n    // Export this class\n    module.exports = File;\n});\n"],"file":"File.js"}
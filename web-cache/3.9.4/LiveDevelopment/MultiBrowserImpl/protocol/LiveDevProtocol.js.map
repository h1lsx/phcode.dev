{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol.js"],"names":["define","require","exports","module","EventDispatcher","LiveDevProtocolRemote","DocumentObserver","LanguageManager","RemoteFunctions","EditorManager","LiveDevMultiBrowser","PreferencesManager","HTMLInstrumentation","StringUtils","FileViewController","MainViewManager","LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME","randomString","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","EVENT_LIVE_PREVIEW_CLICKED","EVENT_LIVE_PREVIEW_RELOAD","_connections","_transport","_nextMsgId","_responseDeferreds","getConnectionIds","Object","keys","_focusEditorIfNeeded","editor","tagName","contentEditable","focusShouldBeInLivePreview","includes","focus","cssLangIDS","lessLangIDS","_isLessOrSCSS","language","getLanguageForPath","document","file","fullPath","getId","_searchAndCursorIfCSS","allSelectors","nodeName","codeMirror","_codeMirror","length","selector","cursor","getSearchCursor","found","findNext","setCursorPos","from","line","ch","htmlTagSearch","RegExp","_tagSelectedInLivePreview","tagId","highlightPref","getViewState","liveDoc","getCurrentLiveDoc","activeEditor","getActiveEditor","activeFullEditor","getCurrentFullEditor","liveDocPath","doc","activeEditorPath","activeFullEditorPath","allOpenFileCount","getWorkingSetSize","ALL_PANES","selectInHTMLEditor","fullHtmlEditor","position","getPositionFromTagId","parseInt","masterEditor","_masterEditor","isRelated","openAndSelectDocument","WORKING_SET_VIEW","ACTIVE_PANE","done","_receive","clientId","msgStr","msg","JSON","parse","event","method","deferred","id","error","reject","resolve","clicked","trigger","_send","clients","result","$","Deferred","send","stringify","promise","_connect","url","_close","setTransport","transport","off","on","start","_getRemoteFunctionsScript","script","config","getRemoteScriptContents","transportScript","getRemoteScript","remoteFunctionsScript","evaluate","params","expression","setStylesheetText","text","getStylesheetText","reload","ignoreCache","close","closeAllConnections","forEach","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Provides the protocol that Brackets uses to talk to a browser instance for live development.\n * Protocol methods are converted to a JSON message format, which is then sent over a provided\n * low-level transport and interpreted in the browser. For messages that expect a response, the\n * response is returned through a promise as an object. Scripts that implement remote logic are\n * provided during the instrumentation stage by \"getRemoteFunctions()\".\n *\n * Events raised by the remote browser are dispatched as jQuery events which type is equal to the 'method'\n * property. The received message object is dispatched as the first parameter and enriched with a\n * 'clientId' property being the client ID of the remote browser.\n *\n * It keeps active connections which are  updated when receiving \"connect\" and \"close\" from the\n * underlying transport. Events \"Connection.connect\"/\"Connection.close\" are triggered as\n * propagation of transport's \"connect\"/\"close\".\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    const EventDispatcher = require(\"utils/EventDispatcher\");\n\n    // Text of the script we'll inject into the browser that handles protocol requests.\n    const LiveDevProtocolRemote = require(\"text!LiveDevelopment/BrowserScripts/LiveDevProtocolRemote.js\"),\n        DocumentObserver      = require(\"text!LiveDevelopment/BrowserScripts/DocumentObserver.js\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        RemoteFunctions       = require(\"text!LiveDevelopment/BrowserScripts/RemoteFunctions.js\"),\n        EditorManager         = require(\"editor/EditorManager\"),\n        LiveDevMultiBrowser   = require(\"LiveDevelopment/LiveDevMultiBrowser\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        HTMLInstrumentation   = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation\"),\n        StringUtils = require(\"utils/StringUtils\"),\n        FileViewController    = require(\"project/FileViewController\"),\n        MainViewManager     = require(\"view/MainViewManager\");\n\n    const LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = `phoenix_live_preview_scripts_instrumented_${StringUtils.randomString(8)}.js`;\n    const LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = `pageLoaderWorker_${StringUtils.randomString(8)}.js`;\n\n    const EVENT_LIVE_PREVIEW_CLICKED = \"livePreviewClicked\",\n        EVENT_LIVE_PREVIEW_RELOAD = \"livePreviewReload\";\n\n    /**\n     * @private\n     * Active connections.\n     * @type {Object}\n     */\n    var _connections = {};\n\n    /**\n     * @private\n     * The low-level transport we're communicating over, set by `setTransport()`.\n     * @type {{start: function(), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}}\n     */\n    var _transport = null;\n\n    /**\n     * @private\n     * A unique message serial number, used to match up responses with request messages.\n     * @type {number}\n     */\n    var _nextMsgId = 1;\n\n    /**\n     * @private\n     * A map of response IDs to deferreds, for messages that are awaiting responses.\n     * @type {Object}\n     */\n    var _responseDeferreds = {};\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return Object.keys(_connections);\n    }\n\n    /**\n     * When user clicks on text boxes or other focusable keyboard elements in live preview, we should not\n     * set focus to editor\n     * @private\n     */\n    function _focusEditorIfNeeded(editor, tagName, contentEditable) {\n        const focusShouldBeInLivePreview = ['INPUT', 'TEXTAREA'].includes(tagName) || contentEditable;\n        if(focusShouldBeInLivePreview){\n            return;\n        }\n        editor.focus();\n    }\n\n    const cssLangIDS = [\"css\", \"scss\", \"sass\", \"less\"];\n    const lessLangIDS = [\"scss\", \"sass\", \"less\"];\n    function _isLessOrSCSS(editor) {\n        if(!editor){\n            return false;\n        }\n        const language = LanguageManager.getLanguageForPath(editor.document.file.fullPath);\n        return language && lessLangIDS.includes(language.getId());\n    }\n\n    function _searchAndCursorIfCSS(editor, allSelectors, nodeName) {\n        const codeMirror =  editor._codeMirror;\n        const language = LanguageManager.getLanguageForPath(editor.document.file.fullPath);\n        if(!language || !cssLangIDS.includes(language.getId())){\n            return;\n        }\n\n        // this is a css file\n        if(allSelectors && allSelectors.length){\n            // check if we can find a class selector\n            for(let selector of allSelectors){\n                const cursor = codeMirror.getSearchCursor(selector);\n                const found = cursor.findNext();\n                if (found) {\n                    editor.setCursorPos(cursor.from().line, cursor.from().ch, true);\n                    return;\n                }\n            }\n        }\n        // check if we can do tag matching, html tag selectors are not case-sensitive\n        const htmlTagSearch = new RegExp(nodeName, \"i\");\n        const cursor = codeMirror.getSearchCursor(htmlTagSearch);\n        const found = cursor.findNext();\n        if (found) {\n            editor.setCursorPos(cursor.from().line, cursor.from().ch, true);\n        }\n    }\n\n    function _tagSelectedInLivePreview(tagId, nodeName, contentEditable, allSelectors) {\n        const highlightPref = PreferencesManager.getViewState(\"livedevHighlight\");\n        if(!highlightPref){\n            // live preview highlight and reverse highlight feature is disabled\n            return;\n        }\n        const liveDoc = LiveDevMultiBrowser.getCurrentLiveDoc(),\n            activeEditor = EditorManager.getActiveEditor(), // this can be an inline editor\n            activeFullEditor = EditorManager.getCurrentFullEditor();\n        const liveDocPath = liveDoc ? liveDoc.doc.file.fullPath : null,\n            activeEditorPath = activeEditor ? activeEditor.document.file.fullPath : null,\n            activeFullEditorPath = activeFullEditor ? activeFullEditor.document.file.fullPath : null;\n        if(!liveDocPath){\n            activeEditor && activeEditor.focus(); // restore focus from live preview\n            return;\n        }\n        const allOpenFileCount = MainViewManager.getWorkingSetSize(MainViewManager.ALL_PANES);\n        function selectInHTMLEditor(fullHtmlEditor) {\n            const position = HTMLInstrumentation.getPositionFromTagId(fullHtmlEditor, parseInt(tagId, 10));\n            if(position && fullHtmlEditor) {\n                const masterEditor = fullHtmlEditor.document._masterEditor || fullHtmlEditor;\n                masterEditor.setCursorPos(position.line, position.ch, true);\n                _focusEditorIfNeeded(masterEditor, nodeName, contentEditable);\n            }\n        }\n        if(liveDocPath === activeFullEditorPath) {\n            // if the active pane is the html being live previewed, select that.\n            selectInHTMLEditor(activeFullEditor);\n        } else if(liveDoc.isRelated(activeEditorPath) || _isLessOrSCSS(activeEditor)) {\n            // the active editor takes the priority in the workflow. If a css related file is active,\n            // then we dont need to open the html live doc. For less files, we dont check if its related as\n            // its not directly linked usually and needs a compile step. so we just do a fuzzy search.\n            _focusEditorIfNeeded(activeEditor, nodeName, contentEditable);\n            _searchAndCursorIfCSS(activeEditor, allSelectors, nodeName);\n            // in this case, see if we need to do any css reverse highlight magic here\n        } else if(!allOpenFileCount){\n            // no open editor in any panes, then open the html file directly.\n            FileViewController.openAndSelectDocument(liveDocPath,\n                FileViewController.WORKING_SET_VIEW, MainViewManager.ACTIVE_PANE)\n                .done(()=>{\n                    selectInHTMLEditor(EditorManager.getActiveEditor());\n                });\n        }\n    }\n\n    /**\n     * @private\n     * Handles a message received from the remote protocol handler via the transport.\n     * If the message has an `id` field, it's assumed to be a response to a previous\n     * request, and will be passed along to the original promise returned by `_send()`.\n     * Otherwise, it's treated as an event and dispatched.\n     * TODO: we should probably have a way of returning the results from all clients, not just the first?\n     *\n     * @param {number} clientId ID of the client that sent the message\n     * @param {string} msg The message that was sent, in JSON string format\n     */\n    function _receive(clientId, msgStr) {\n        var msg = JSON.parse(msgStr),\n            event = msg.method || \"event\",\n            deferred;\n        if (msg.id) {\n            deferred = _responseDeferreds[msg.id];\n            if (deferred) {\n                delete _responseDeferreds[msg.id];\n                if (msg.error) {\n                    deferred.reject(msg);\n                } else {\n                    deferred.resolve(msg);\n                }\n            }\n        } else if (msg.clicked && msg.tagId) {\n            _tagSelectedInLivePreview(msg.tagId, msg.nodeName, msg.contentEditable, msg.allSelectors);\n            exports.trigger(EVENT_LIVE_PREVIEW_CLICKED, msg);\n        } else {\n            // enrich received message with clientId\n            msg.clientId = clientId;\n            exports.trigger(event, msg);\n        }\n    }\n\n    /**\n     * @private\n     * Dispatches a message to the remote protocol handler via the transport.\n     *\n     * @param {Object} msg The message to send.\n     * @param {number|Array.<number>} idOrArray ID or IDs of the client(s) that should\n     *     receive the message.\n     * @return {$.Promise} A promise that's fulfilled when the response to the message is received.\n     */\n    function _send(msg, clients) {\n        var id = _nextMsgId++,\n            result = new $.Deferred();\n\n        // broadcast if there are no specific clients\n        clients = clients || getConnectionIds();\n        msg.id = id;\n        _responseDeferreds[id] = result;\n        _transport.send(clients, JSON.stringify(msg));\n        return result.promise();\n    }\n\n     /**\n     * @private\n     * Handles when a connection is made to the live development protocol handler.\n     * Injects the RemoteFunctions script in order to provide highlighting and live DOM editing functionality.\n     * Records the connection's client ID and triggers the \"Coonnection.connect\" event.\n     * @param {number} clientId\n     * @param {string} url\n     */\n    function _connect(clientId, url) {\n        // add new connections\n        // TODO: check URL\n        _connections[clientId] = true;\n\n        exports.trigger(\"ConnectionConnect\", {\n            clientId: clientId,\n            url: url\n        });\n    }\n\n    /**\n     * @private\n     * Handles when a connection is closed.\n     * @param {number} clientId\n     */\n    function _close(clientId) {\n        if(!_connections[clientId]){\n            return;\n        }\n        delete _connections[clientId];\n        exports.trigger(\"ConnectionClose\", {\n            clientId: clientId\n        });\n    }\n\n\n    /**\n     * Sets the transport that should be used by the protocol. See `LiveDevelopment.setTransport()`\n     * for more detail on the transport.\n     * @param {{start: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        if (_transport) {\n            _transport.off(\".livedev\");\n        }\n        _transport = transport;\n\n        _transport\n            .on(\"connect.livedev\", function (event, msg) {\n                _connect(msg[0], msg[1]);\n            })\n            .on(\"message.livedev\", function (event, msg) {\n                _receive(msg[0], msg[1]);\n            })\n            .on(\"close.livedev\", function (event, msg) {\n                _close(msg[0]);\n            });\n        _transport.start();\n    }\n\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to implement remote commands that handle protocol requests.\n     * Includes the <script> tags.\n     * @return {string}\n     */\n    function _getRemoteFunctionsScript() {\n        let script = \"\";\n        // Inject DocumentObserver into the browser (tracks related documents)\n        script += DocumentObserver;\n        // Inject remote functions into the browser.\n        script += \"\\nwindow._LD=(\" + RemoteFunctions + \"(\" + JSON.stringify(LiveDevMultiBrowser.config) + \"))\";\n        return \"\\n\" + script + \"\\n\";\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScriptContents() {\n        const transportScript = _transport.getRemoteScript() || \"\";\n        const remoteFunctionsScript = _getRemoteFunctionsScript() || \"\";\n        return transportScript +\n            \"\\n\" + LiveDevProtocolRemote + \"\\n\" +\n            remoteFunctionsScript;\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScript() {\n        // give a wrong random file name that wont have a possibility of an actual file name\n        return `\\n\\t\\t<script src=\"${LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME}\"></script>`;\n    }\n\n    /**\n     * Protocol method. Evaluates the given script in the browser (in global context), and returns a promise\n     * that will be fulfilled with the result of the script, if any.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @param {string} script The script to evaluate.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function evaluate(script, clients) {\n        return _send(\n            {\n                method: \"Runtime.evaluate\",\n                params: {\n                    expression: script\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads a CSS styleseet in the browser (by replacing its text) given its url.\n     * @param {string} url Absolute URL of the stylesheet\n     * @param {string} text The new text of the stylesheet\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function setStylesheetText(url, text, clients) {\n        return _send(\n            {\n                method: \"CSS.setStylesheetText\",\n                params: {\n                    url: url,\n                    text: text\n                }\n            }\n        );\n    }\n\n     /**\n     * Protocol method. Rretrieves the content of a given stylesheet (for unit testing)\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should navigate to the given URL.\n     * @param {string} url Absolute URL that identifies the stylesheet.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function getStylesheetText(url, clients) {\n        return _send(\n            {\n                method: \"CSS.getStylesheetText\",\n                params: {\n                    url: url\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads the page that is currently loaded into the browser, optionally ignoring cache.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should reload the page.\n     * @param {boolean} ignoreCache If true, browser cache is ignored.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function reload(ignoreCache, clients) {\n        exports.trigger(EVENT_LIVE_PREVIEW_RELOAD, clients);\n        return _send(\n            {\n                method: \"Page.reload\",\n                params: {\n                    ignoreCache: true\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Closes the connection to the given client. Proxies to the transport.\n     * @param {number} clientId\n     */\n    function close(clientId) {\n        _transport.close(clientId);\n    }\n\n    function closeAllConnections() {\n        getConnectionIds().forEach(function (clientId) {\n            close(clientId);\n        });\n        _connections = {};\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // public API\n    exports.setTransport = setTransport;\n    exports.getRemoteScript = getRemoteScript;\n    exports.getRemoteScriptContents = getRemoteScriptContents;\n    exports.evaluate = evaluate;\n    exports.setStylesheetText = setStylesheetText;\n    exports.getStylesheetText = getStylesheetText;\n    exports.reload = reload;\n    exports.close = close;\n    exports.getConnectionIds = getConnectionIds;\n    exports.closeAllConnections = closeAllConnections;\n    exports.LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME;\n    exports.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME;\n    exports.EVENT_LIVE_PREVIEW_CLICKED = EVENT_LIVE_PREVIEW_CLICKED;\n    exports.EVENT_LIVE_PREVIEW_RELOAD = EVENT_LIVE_PREVIEW_RELOAD;\n});\n"],"file":"LiveDevProtocol.js"}
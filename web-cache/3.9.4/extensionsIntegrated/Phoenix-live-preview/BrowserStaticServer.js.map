{"version":3,"sources":["extensionsIntegrated/Phoenix-live-preview/BrowserStaticServer.js"],"names":["define","require","exports","module","BaseServer","LiveDevelopmentUtils","LiveDevelopment","LiveDevProtocol","marked","DocumentManager","Mustache","FileSystem","EventDispatcher","CommandManager","Commands","StringUtils","EventManager","LivePreviewSettings","ProjectManager","Strings","utils","BootstrapCSSText","GithubCSSText","HilightJSText","GFMCSSText","markdownHTMLTemplate","redirectionHTMLTemplate","EVENT_GET_PHOENIX_INSTANCE_ID","EVENT_GET_CONTENT","EVENT_TAB_ONLINE","EVENT_REPORT_ERROR","EVENT_UPDATE_TITLE_ICON","EVENT_EMBEDDED_IFRAME_ESCAPE_PRESS","EVENT_SERVER_READY","makeEventDispatcher","livePreviewTabs","Map","PHCODE_LIVE_PREVIEW_QUERY_PARAM","navigatorChannel","NAVIGATOR_CHANNEL_ID","Phoenix","PHOENIX_INSTANCE_ID","livePreviewChannel","LIVE_PREVIEW_MESSENGER_CHANNEL","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","_staticServerInstance","$livepreviewServerIframe","LIVE_PREVIEW_STATIC_SERVER_BASE_URL","PREVIEW_BASE_URL","BASE_URL_PATH_PREFIX","getLivePreviewNotSupportedURL","window","baseURL","encodeURIComponent","DESCRIPTION_LIVEDEV_MAIN_HEADING","DESCRIPTION_LIVEDEV_MAIN_SPAN","getNoPreviewURL","heading","DESCRIPTION_LIVEDEV_NO_PREVIEW","message","DESCRIPTION_LIVEDEV_NO_PREVIEW_DETAILS","_isLivePreviewSupported","isNativeApp","browser","desktop","isSafari","mobile","isIos","async","getPreviewDetails","Promise","resolve","reject","URL","isNoPreview","projectRoot","getProjectRoot","fullPath","projectRootUrl","currentDocument","getCurrentDocument","currentFile","file","getSelectedItem","httpFilePath","startsWith","customServeURL","getCustomServerConfig","shouldUseInbuiltPreview","isMarkdownFile","isSVG","relativePath","path","relative","filePath","isHTMLFile","isCustomServer","serverSupportsHotReload","isUsingCustomServer","DESCRIPTION_LIVEDEV_EXCLUDED","format","DESCRIPTION_LIVEDEV_NO_PREVIEW_EXCLUDED","getCustomServeRoot","isPreviewableFile","currentLivePreviewDetails","getLivePreviewDetails","liveDocument","isRelated","doc","e","_initNavigatorChannel","BroadcastChannel","onmessage","event","logger","livePreview","log","type","data","_sendInitialURL","pageLoaderID","set","lastSeen","Date","navigationTab","_sendToLivePreviewServerTabs","postMessage","_initLivePreviewChannel","eventName","getContent","url","then","response","requestID","catch","console","error","clientID","reportError","Error","trigger","StaticServer","config","this","_baseUrl","_getInstrumentedContent","bind","call","_getMarkdown","getDocumentForPath","done","text","getText","replace","markdownHtml","templateVars","markdownContent","parse","BOOTSTRAP_LIB_CSS","HIGHLIGHT_JS_CSS","TRUSTED_ORIGINS_EMBED","JSON","stringify","TRUSTED_ORIGINS","HIGHLIGHT_JS","GFM_CSS","PARENT_ORIGIN","location","origin","html","render","contents","headers","Content-Type","fail","err","_getRedirectionPage","redirectURL","searchParams","delete","href","getBaseUrl","_startHeartBeatListeners","TAB_HEARTBEAT_TIMEOUT","setInterval","endTime","tab","keys","tabInfo","get","timeDiff","messageToLivePreviewTabs","contentWindow","currentPopoutURL","redirectAllTabs","newURL","force","_projectOpened","_evt","_isLiveHighlightEnabled","FILE_LIVE_HIGHLIGHT","getChecked","getPageLoaderURL","DESCRIPTION_LIVEDEV_SECURITY_POPOUT_MESSAGE","APP_NAME","TRUST_PROJECT","getTabPopoutURL","openURL","hasActiveLivePreviews","size","getRemoteTransportScript","init","setLivePreviewTransportBridge","$","attr","registerEventHandler","on","EVENT_PROJECT_OPEN","setOptions","renderer","Renderer","pedantic","gfm","breaks","sanitize","smartLists","smartypants","xhtml","prototype","Object","create","constructor","pathToUrl","baseUrl","_pathResolver","encodeURI","urlToPath","indexOf","urlObj","decodeURI","pathname","canServe","localPath","match","isStaticHtmlFileExt","readyToServe","Deferred","promise","addVirtualContentAtPath","docText","add","setInstrumentationEnabled","remove","removeVirtualContentAtPath","clear","requestedPath","_documentKey","_liveDocuments","virtualDocument","_virtualServingDocuments","isWithinProject","isLivePreviewPopoutPage","getResponseData","body","getRemoteScript","getFileForPath","getOpenDocumentForPath","fs","readFile","BYTE_ARRAY_ENCODING","binContent","endsWith","start","isActive","stop","undefined","_ev","phoenixInstanceID","requestPath","title","faviconBase64","focusActiveEditorIfFocusInLivePreview"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2012 - present Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*global Phoenix, logger, fs, path */\n\ndefine(function (require, exports, module) {\n\n    const BaseServer = require(\"LiveDevelopment/Servers/BaseServer\").BaseServer,\n        LiveDevelopmentUtils = require(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        LiveDevelopment    = require(\"LiveDevelopment/main\"),\n        LiveDevProtocol = require(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        marked = require('thirdparty/marked.min'),\n        DocumentManager = require(\"document/DocumentManager\"),\n        Mustache = require(\"thirdparty/mustache/mustache\"),\n        FileSystem = require(\"filesystem/FileSystem\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        CommandManager     = require(\"command/CommandManager\"),\n        Commands           = require(\"command/Commands\"),\n        StringUtils       = require(\"utils/StringUtils\"),\n        EventManager = require(\"utils/EventManager\"),\n        LivePreviewSettings  = require(\"./LivePreviewSettings\"),\n        ProjectManager = require(\"project/ProjectManager\"),\n        Strings = require(\"strings\"),\n        utils = require('./utils'),\n        BootstrapCSSText = require(\"text!thirdparty/bootstrap/bootstrap.min.css\"),\n        GithubCSSText = require(\"text!thirdparty/highlight.js/styles/github.min.css\"),\n        HilightJSText = require(\"text!thirdparty/highlight.js/highlight.min.js\"),\n        GFMCSSText = require(\"text!thirdparty/gfm.min.css\"),\n        markdownHTMLTemplate = require(\"text!./markdown.html\"),\n        redirectionHTMLTemplate = require(\"text!./redirectPage.html\");\n\n    const EVENT_GET_PHOENIX_INSTANCE_ID = 'GET_PHOENIX_INSTANCE_ID';\n    const EVENT_GET_CONTENT = 'GET_CONTENT';\n    const EVENT_TAB_ONLINE = 'TAB_ONLINE';\n    const EVENT_REPORT_ERROR = 'REPORT_ERROR';\n    const EVENT_UPDATE_TITLE_ICON = 'UPDATE_TITLE_AND_ICON';\n    const EVENT_EMBEDDED_IFRAME_ESCAPE_PRESS = 'embeddedEscapeKeyPressed';\n    // In browser the SERVER_READY event is raised by the phcode.live virtual server page. That is why you wouldnt see\n    // this triggered in the phcode.dev codebase. It comes from the embedded iframe. Do not remove as unused.\n    const EVENT_SERVER_READY = 'SERVER_READY';\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    const livePreviewTabs = new Map();\n    const PHCODE_LIVE_PREVIEW_QUERY_PARAM = \"phcodeLivePreview\";\n\n    // Communication Channels for PHCode.dev Editor and Live Preview\n    // -------------------------------------------------------------\n    //\n    // NAVIGATOR_CHANNEL:\n    // - Purpose: To handle navigation messages between the PHCode.dev editor and multiple tabs open\n    //   at phcode.dev/live-preview-loader.html.\n    // - Function: Mainly used to redirect pages in response to user actions, such as clicking on different\n    //   files in the files panel or through other navigational inputs.\n    // - Channel ID: `live-preview-loader-${Phoenix.PHOENIX_INSTANCE_ID}` uniquely identifies this channel\n    //   for a specific phoenix instance. This allows multiple live previews to exist if the user opens the\n    //   same project in multiple phoenix editor instances.\n    let navigatorChannel;\n    const NAVIGATOR_CHANNEL_ID = `live-preview-loader-${Phoenix.PHOENIX_INSTANCE_ID}`;\n\n    // LIVE_PREVIEW_MESSENGER_CHANNEL:\n    // - Purpose: To facilitate communication of live preview transport messages between the PHCode.dev\n    //   editor and tabs open at phcode.dev/live-preview-loader.html.\n    // - Function: Acts as a relay channel. Messages received here are forwarded to the LIVE_PREVIEW_MAIN_CHANNEL\n    //   in the phcode.live domain.\n    // - Note: This setup ensures that messages are securely relayed within the constraints of the same origin\n    //   communication policy.\n    let livePreviewChannel;\n    const LIVE_PREVIEW_MESSENGER_CHANNEL = `live-preview-messenger-${Phoenix.PHOENIX_INSTANCE_ID}`;\n\n    // LIVE_PREVIEW_MAIN_CHANNEL:\n    // - Purpose: The primary channel for receiving live preview messages in the phcode.live preview iframe.\n    // - Function: Listens to messages forwarded from LIVE_PREVIEW_MESSENGER_CHANNEL and updates the\n    //   live preview accordingly in phcode.live domain.\n    // - Note: This channel is crucial for the real-time update and synchronization of the live preview\n    //   with user actions in the PHCode.dev editor.\n    const LIVE_PREVIEW_BROADCAST_CHANNEL_ID = `${Phoenix.PHOENIX_INSTANCE_ID}_livePreview`;\n\n    let _staticServerInstance, $livepreviewServerIframe;\n\n    const LIVE_PREVIEW_STATIC_SERVER_BASE_URL = \"https://phcode.live/\";\n    // #LIVE_PREVIEW_STATIC_SERVER_BASE_URL_OVERRIDE uncomment below line if you are developing -\n    // live preview server for browser.\n    // const LIVE_PREVIEW_STATIC_SERVER_BASE_URL = \"http://localhost:8001/\";\n    // const LIVE_PREVIEW_STATIC_SERVER_ORIGIN = \"http://localhost:8001\";\n\n    const PREVIEW_BASE_URL = `${LIVE_PREVIEW_STATIC_SERVER_BASE_URL}vfs/PHOENIX_LIVE_PREVIEW_${Phoenix.PHOENIX_INSTANCE_ID}`;\n    const BASE_URL_PATH_PREFIX = `/vfs/PHOENIX_LIVE_PREVIEW_${Phoenix.PHOENIX_INSTANCE_ID}`;\n\n    function getLivePreviewNotSupportedURL() {\n        return `${window.Phoenix.baseURL}assets/phoenix-splash/live-preview-error.html?mainHeading=`+\n            encodeURIComponent(`${Strings.DESCRIPTION_LIVEDEV_MAIN_HEADING}`) + \"&mainSpan=\"+\n            encodeURIComponent(`${Strings.DESCRIPTION_LIVEDEV_MAIN_SPAN}`);\n    }\n\n    function getNoPreviewURL(\n        heading = Strings.DESCRIPTION_LIVEDEV_NO_PREVIEW,\n        message = Strings.DESCRIPTION_LIVEDEV_NO_PREVIEW_DETAILS\n    ){\n        return `${window.Phoenix.baseURL}assets/phoenix-splash/no-preview.html?jsonInput=`+\n            encodeURIComponent(`{\"heading\":\"${heading}\",`\n                +`\"details\":\"${message}\"}`);\n    }\n\n    function _isLivePreviewSupported() {\n        // in safari, service workers are disabled in third party iframes. We use phcode.live for secure sandboxing\n        // live previews into its own domain apart from phcode.dev. Since safari doesn't support this, we are left\n        // with using phcode.dev domain directly for live previews. That is a large attack surface for untrusted\n        // code execution. so we will disable live previews in safari instead of shipping a security vulnerability.\n        return Phoenix.isNativeApp || !(Phoenix.browser.desktop.isSafari || Phoenix.browser.mobile.isIos);\n    }\n\n    /**\n     * Finds out a {URL,filePath} to live preview from the project. Will return and empty object if the current\n     * file is not previewable.\n     * @return {Promise<*>}\n     */\n    async function getPreviewDetails() {\n        return new Promise(async (resolve, reject)=>{ // eslint-disable-line\n            // async is explicitly caught\n            try {\n                if(!_isLivePreviewSupported()){\n                    resolve({\n                        URL: getLivePreviewNotSupportedURL(),\n                        isNoPreview: true\n                    });\n                    return;\n                }\n                const projectRoot = ProjectManager.getProjectRoot().fullPath;\n                const projectRootUrl = `${PREVIEW_BASE_URL}${projectRoot}`;\n                const currentDocument = DocumentManager.getCurrentDocument();\n                const currentFile = currentDocument? currentDocument.file : ProjectManager.getSelectedItem();\n                if(currentFile){\n                    let fullPath = currentFile.fullPath;\n                    let httpFilePath = null;\n                    if(fullPath.startsWith(\"http://\") || fullPath.startsWith(\"https://\")){\n                        httpFilePath = fullPath;\n                    }\n                    const customServeURL = LivePreviewSettings.getCustomServerConfig(fullPath);\n                    const shouldUseInbuiltPreview = utils.isMarkdownFile(fullPath) || utils.isSVG(fullPath);\n                    if(customServeURL){\n                        const relativePath = path.relative(projectRoot, fullPath);\n                        resolve({\n                            URL: customServeURL,\n                            filePath: relativePath,\n                            fullPath: fullPath,\n                            isMarkdownFile: utils.isMarkdownFile(fullPath),\n                            isHTMLFile: utils.isHTMLFile(fullPath),\n                            isCustomServer: true,\n                            serverSupportsHotReload: LivePreviewSettings.serverSupportsHotReload()\n                        });\n                        return;\n                    } else if(LivePreviewSettings.isUsingCustomServer() && !customServeURL && !shouldUseInbuiltPreview){\n                        // this is the case where the file is outside of a custom configured server root (E. `www/`)\n                        // like `notServed/Path.html`. For markdown and SVG, we will still use the inbuilt live preview.\n                        resolve({\n                            URL: getNoPreviewURL(Strings.DESCRIPTION_LIVEDEV_EXCLUDED,\n                                StringUtils.format(Strings.DESCRIPTION_LIVEDEV_NO_PREVIEW_EXCLUDED,\n                                    LivePreviewSettings.getCustomServeRoot())),\n                            isNoPreview: true\n                        });\n                        return;\n                    }  else if(utils.isPreviewableFile(fullPath)){\n                        const filePath = httpFilePath || path.relative(projectRoot, fullPath);\n                        let URL = httpFilePath || `${projectRootUrl}${filePath}`;\n                        resolve({\n                            URL,\n                            filePath: filePath,\n                            fullPath: fullPath,\n                            isMarkdownFile: utils.isMarkdownFile(fullPath),\n                            isHTMLFile: utils.isHTMLFile(fullPath)\n                        });\n                        return;\n                    } else {\n                        const currentLivePreviewDetails = LiveDevelopment.getLivePreviewDetails();\n                        if(currentLivePreviewDetails && currentLivePreviewDetails.liveDocument\n                            && currentLivePreviewDetails.liveDocument.isRelated\n                            && currentLivePreviewDetails.liveDocument.isRelated(fullPath)){\n                            fullPath = currentLivePreviewDetails.liveDocument.doc.file.fullPath;\n                            const filePath = path.relative(projectRoot, fullPath);\n                            let URL = `${projectRootUrl}${filePath}`;\n                            resolve({\n                                URL,\n                                filePath: filePath,\n                                fullPath: fullPath,\n                                isMarkdownFile: utils.isMarkdownFile(fullPath),\n                                isHTMLFile: utils.isHTMLFile(fullPath)\n                            });\n                            return;\n                        }\n                    }\n                }\n                resolve({\n                    URL: getNoPreviewURL(),\n                    isNoPreview: true\n                });\n            }catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    function _initNavigatorChannel() {\n        navigatorChannel = new BroadcastChannel(NAVIGATOR_CHANNEL_ID);\n        navigatorChannel.onmessage = (event) => {\n            window.logger.livePreview.log(\"Live Preview navigator channel: Phoenix received event from tab: \", event);\n            const type = event.data.type;\n            switch (type) {\n            case 'GET_INITIAL_URL':\n                _sendInitialURL(event.data.pageLoaderID);\n                return;\n            case 'TAB_LOADER_ONLINE':\n                livePreviewTabs.set(event.data.pageLoaderID, {\n                    lastSeen: new Date(),\n                    URL: event.data.URL,\n                    navigationTab: true\n                });\n                return;\n            default: return; // ignore messages not intended for us.\n            }\n        };\n    }\n\n    // this is the server tabs located at \"src/live-preview.html\" which embeds the `phcode.live` server and\n    // preview iframes.\n    function _sendToLivePreviewServerTabs(data, pageLoaderID=null) {\n        livePreviewChannel.postMessage({\n            pageLoaderID,\n            data\n        });\n    }\n\n    function _initLivePreviewChannel() {\n        livePreviewChannel = new BroadcastChannel(LIVE_PREVIEW_MESSENGER_CHANNEL);\n        livePreviewChannel.onmessage = (event) => {\n            window.logger.livePreview.log(\"StaticServer: Live Preview message channel Phoenix recvd:\", event);\n            const pageLoaderID = event.data.pageLoaderID;\n            const data = event.data.data;\n            const eventName =  data.eventName;\n            const message =  data.message;\n            switch (eventName) {\n            case EVENT_GET_PHOENIX_INSTANCE_ID:\n                _sendToLivePreviewServerTabs({\n                    type: 'PHOENIX_INSTANCE_ID',\n                    PHOENIX_INSTANCE_ID: Phoenix.PHOENIX_INSTANCE_ID\n                }, pageLoaderID);\n                return;\n            case EVENT_GET_CONTENT:\n                getContent(message.path,  message.url)\n                    .then(response =>{\n                        // response has the following attributes set\n                        // response.contents: <text or arrayBuffer content>,\n                        // response.path\n                        // headers: {'Content-Type': 'text/html'} // optional headers\n                        response.type = 'REQUEST_RESPONSE';\n                        response.requestID = message.requestID;\n                        _sendToLivePreviewServerTabs(response, pageLoaderID);\n                    })\n                    .catch(console.error);\n                return;\n            case EVENT_TAB_ONLINE:\n                livePreviewTabs.set(message.clientID, {\n                    lastSeen: new Date(),\n                    URL: message.URL\n                });\n                return;\n            case EVENT_REPORT_ERROR:\n                logger.reportError(new Error(message));\n                return;\n            default:\n                exports.trigger(eventName, {\n                    data\n                });\n            }\n        };\n    }\n\n    // see markdown advanced rendering options at https://marked.js.org/using_advanced\n    marked.setOptions({\n        renderer: new marked.Renderer(),\n        pedantic: false,\n        gfm: true,\n        breaks: false,\n        sanitize: false,\n        smartLists: true,\n        smartypants: false,\n        xhtml: false\n    });\n\n    /**\n     * @constructor\n     * @extends {BaseServer}\n     * Live preview server that uses a built-in HTTP server to serve static\n     * and instrumented files.\n     *\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string), nodeDomain: NodeDomain}} config\n     *    Configuration parameters for this server:\n     *        baseUrl        - Optional base URL (populated by the current project)\n     *        pathResolver   - Function to covert absolute native paths to project relative paths\n     *        root           - Native path to the project root (and base URL)\n     */\n    function StaticServer(config) {\n        this._baseUrl       = PREVIEW_BASE_URL;\n        this._getInstrumentedContent = this._getInstrumentedContent.bind(this);\n        BaseServer.call(this, config);\n    }\n\n    StaticServer.prototype = Object.create(BaseServer.prototype);\n    StaticServer.prototype.constructor = StaticServer;\n\n    /**\n     * Returns a base url for current project.\n     *\n     * @return {string}\n     * Base url for current project.\n     */\n    StaticServer.prototype.getBaseUrl = function () {\n        return this._baseUrl;\n    };\n\n    /**\n     * Returns a URL for a given path\n     * @param {string} path Absolute path to covert to a URL\n     * @return {?string} Converts a path within the project root to a URL.\n     *  Returns null if the path is not a descendant of the project root.\n     */\n    StaticServer.prototype.pathToUrl = function (path) {\n        const baseUrl         = this.getBaseUrl(),\n            relativePath    = this._pathResolver(path);\n\n        // See if base url has been specified and path is within project\n        if (relativePath !== path) {\n            // Map to server url. Base url is already encoded, so don't encode again.\n\n            return `${baseUrl}${encodeURI(path)}`;\n        }\n\n        return null;\n    };\n\n    /**\n     * Convert a URL to a local full file path\n     * @param {string} url\n     * @return {?string} The absolute path for given URL or null if the path is\n     *  not a descendant of the project.\n     */\n    StaticServer.prototype.urlToPath = function (url) {\n        let baseUrl = this.getBaseUrl();\n\n        if (baseUrl !== \"\" && url.indexOf(baseUrl) === 0) {\n            const urlObj = new URL(url);\n\n            const filePath = decodeURI(urlObj.pathname)\n                .replace(BASE_URL_PATH_PREFIX, \"\");\n            return decodeURI(filePath);\n        }\n\n        return null;\n    };\n\n    /**\n     * Determines whether we can serve local file.\n     * @param {string} localPath A local path to file being served.\n     * @return {boolean} true for yes, otherwise false.\n     */\n    StaticServer.prototype.canServe = function (localPath) {\n        // If we can't transform the local path to a project relative path,\n        // the path cannot be served\n        if (localPath === this._pathResolver(localPath)) {\n            return false;\n        }\n\n        // Url ending in \"/\" implies default file, which is usually index.html.\n        // Return true to indicate that we can serve it.\n        if (localPath.match(/\\/$/)) {\n            return true;\n        }\n\n        // FUTURE: do a MIME Type lookup on file extension\n        return LiveDevelopmentUtils.isStaticHtmlFileExt(localPath);\n    };\n\n    /**\n     * Gets the server details from the StaticServerDomain in node.\n     * The domain itself handles starting a server if necessary (when\n     * the staticServer.getServer command is called).\n     *\n     * @return {jQuery.Promise} A promise that resolves/rejects when\n     *     the server is ready/failed.\n     */\n    StaticServer.prototype.readyToServe = function () {\n        return $.Deferred().resolve().promise(); // virtual server is always assumed present in phoenix\n    };\n\n    /**\n     * This will add the given text to be served when the path is hit in server. use this to either serve a file\n     * that doesn't exist in project, or to override a given path to the contents you give.\n     */\n    StaticServer.prototype.addVirtualContentAtPath = function (path, docText) {\n        BaseServer.prototype.addVirtualContentAtPath.call(this, path, docText);\n    };\n\n    /**\n     * See BaseServer#add. StaticServer ignores documents that do not have\n     * a setInstrumentationEnabled method. Updates request filters.\n     */\n    StaticServer.prototype.add = function (liveDocument) {\n        if (liveDocument.setInstrumentationEnabled) {\n            // enable instrumentation\n            liveDocument.setInstrumentationEnabled(true);\n        }\n\n        BaseServer.prototype.add.call(this, liveDocument);\n    };\n\n    /**\n     * See BaseServer#remove. Updates request filters.\n     */\n    StaticServer.prototype.remove = function (liveDocument) {\n        BaseServer.prototype.remove.call(this, liveDocument);\n    };\n\n    /**\n     * removes path added by addVirtualContentAtPath()\n     */\n    StaticServer.prototype.removeVirtualContentAtPath = function (path) {\n        BaseServer.prototype.removeVirtualContentAtPath.call(this, path);\n    };\n\n    /**\n     * See BaseServer#clear. Updates request filters.\n     */\n    StaticServer.prototype.clear = function () {\n        BaseServer.prototype.clear.call(this);\n    };\n\n    function _getMarkdown(fullPath) {\n        return new Promise((resolve, reject)=>{\n            DocumentManager.getDocumentForPath(fullPath)\n                .done(function (doc) {\n                    let text = doc.getText();\n                    //  Input: special ZERO WIDTH unicode characters (for example \\uFEFF) might interfere with parsing.\n                    //  Some text editors add them at the start of the file. See\n                    // https://github.com/markedjs/marked/issues/2139\n                    text = text.replace(/^[\\u200B\\u200C\\u200D\\u200E\\u200F\\uFEFF]/, \"\");\n                    let markdownHtml = marked.parse(text);\n                    let templateVars = {\n                        markdownContent: markdownHtml,\n                        BOOTSTRAP_LIB_CSS: BootstrapCSSText,\n                        HIGHLIGHT_JS_CSS: GithubCSSText,\n                        TRUSTED_ORIGINS_EMBED:\n                            `const TRUSTED_ORIGINS_EMBED = ${JSON.stringify(Phoenix.TRUSTED_ORIGINS)};`,\n                        HIGHLIGHT_JS: HilightJSText,\n                        GFM_CSS: GFMCSSText,\n                        PARENT_ORIGIN: location.origin\n                    };\n                    let html = Mustache.render(markdownHTMLTemplate, templateVars);\n                    resolve({\n                        contents: html,\n                        headers: {'Content-Type': 'text/html'},\n                        path: fullPath\n                    });\n                })\n                .fail(function (err) {\n                    reject(new Error(`Markdown rendering failed for ${fullPath}: ` + err));\n                });\n        });\n    }\n\n    /**\n     * return a page loader html with redirect script tag that just redirects the page to the given redirectURL.\n     * Strips the PHCODE_LIVE_PREVIEW_QUERY_PARAM in redirectURL also, indicating this is not a live previewed url.\n     *\n     * @param redirectURL\n     * @return {string}\n     * @private\n     */\n    function _getRedirectionPage(redirectURL) {\n        let url = new URL(redirectURL);\n        // strip this query param as the redirection will be done by the page loader and not the content iframe.\n        url.searchParams.delete(PHCODE_LIVE_PREVIEW_QUERY_PARAM);\n        let templateVars = {\n            redirectURL: url.href\n        };\n        return Mustache.render(redirectionHTMLTemplate, templateVars);\n    }\n\n    /**\n     * @private\n     * Events raised by broadcast channel from the service worker will be captured here. The service worker will ask\n     * all phoenix instances if the url to be served should be replaced with instrumented content here or served\n     * as static file from disk.\n     */\n    StaticServer.prototype._getInstrumentedContent = function (requestedPath, url) {\n        return new Promise((resolve, reject)=>{\n            let path = this._documentKey(requestedPath),\n                liveDocument = this._liveDocuments[path],\n                virtualDocument = this._virtualServingDocuments[path];\n            let contents;\n            if(!ProjectManager.isWithinProject(requestedPath)) {\n                console.error(\"Security issue prevented: Live preview tried to access non project resource!!!\", path);\n                resolve({\n                    path,\n                    contents: null // 404. the user doesnt need to know this, might be a mistake too\n                });\n                return;\n            }\n\n            url = new URL(url);\n            let isLivePreviewPopoutPage = false;\n            if(url.searchParams.get(PHCODE_LIVE_PREVIEW_QUERY_PARAM)) {\n                isLivePreviewPopoutPage = true;\n            }\n            if (virtualDocument) {\n                // virtual document overrides takes precedence over live preview docs\n                contents = virtualDocument;\n            } else if (liveDocument && liveDocument.getResponseData) {\n                contents = liveDocument.getResponseData().body;\n                if(isLivePreviewPopoutPage && contents.indexOf(LiveDevProtocol.getRemoteScript()) === -1){\n                    // #LIVE_PREVIEW_TAB_NAVIGATION_RACE_FIX\n                    // check if this is a live preview html. If so, then if you are here, it means that users switched\n                    // live preview to a different page while we are just about to serve an old live preview page that is\n                    // no longer in live preview. If we just serve the raw html here, it will not have any tab navigation\n                    // instrumentation on popped out tabs and live preview navigation will stop on this page. So we will\n                    // use a page loader url to continue navigation.\n                    console.log(\"serving stale live preview with navigable url\", url);\n                    contents = _getRedirectionPage(url);\n                }\n            } else {\n                const file = FileSystem.getFileForPath(requestedPath);\n                let doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n                if (doc) {\n                    // this file is open in some editor, so we sent the edited contents.\n                    contents = doc.getText();\n                } else {\n                    fs.readFile(requestedPath, fs.BYTE_ARRAY_ENCODING, function (error, binContent) {\n                        if(error){\n                            binContent = null;\n                        }\n                        resolve({\n                            path,\n                            contents: binContent\n                        });\n                    });\n                    return;\n                }\n            }\n\n            let headers;\n            if(path.endsWith(\".htm\") || path.endsWith(\".html\") || path.endsWith(\".xhtml\") || path.endsWith(\".php\")) {\n                headers = {\n                    'Content-Type': 'text/html;charset=UTF-8'\n                };\n            }\n\n            resolve({\n                path,\n                contents: contents,\n                headers\n            });\n        });\n    };\n\n    function getContent(path, url) {\n        const currentDocument = DocumentManager.getCurrentDocument();\n        const currentFile = currentDocument? currentDocument.file : ProjectManager.getSelectedItem();\n        if(!_staticServerInstance){\n            return Promise.reject(\"Static serve not started!\");\n        }\n        if(!url.startsWith(_staticServerInstance.getBaseUrl())) {\n            return Promise.reject(\"Not serving content as url belongs to another phcode instance: \" + url);\n        }\n        if(utils.isMarkdownFile(path) && currentFile && currentFile.fullPath === path){\n            return _getMarkdown(path);\n        }\n        if(_staticServerInstance){\n            return _staticServerInstance._getInstrumentedContent(path, url);\n        }\n        return Promise.reject(\"Cannot get content\");\n    };\n\n    /**\n     * See BaseServer#start. Starts listenting to StaticServerDomain events.\n     */\n    StaticServer.prototype.start = async function () {\n        _staticServerInstance = this;\n        // in browsers, the virtual server is always loaded permanently in iframe.\n    };\n\n    StaticServer.prototype.isActive = function () {\n        return _staticServerInstance === this;\n    };\n\n    /**\n     * See BaseServer#stop. Remove event handlers from StaticServerDomain.\n     */\n    StaticServer.prototype.stop = function () {\n        _staticServerInstance = undefined;\n    };\n\n    exports.on(EVENT_REPORT_ERROR, function(_ev, event){\n        logger.reportError(new Error(event.data.message));\n    });\n    exports.on(EVENT_GET_CONTENT, function(_ev, event){\n        window.logger.livePreview.log(\"Static Server GET_CONTENT\", event);\n        if(event.data.message && event.data.message.phoenixInstanceID === Phoenix.PHOENIX_INSTANCE_ID) {\n            const requestPath = event.data.message.path,\n                requestID = event.data.message.requestID,\n                url = event.data.message.url;\n            getContent(requestPath, url)\n                .then(response =>{\n                    // response has the following attributes set\n                    // response.contents: <text or arrayBuffer content>,\n                    // response.path\n                    // headers: {'Content-Type': 'text/html'} // optional headers\n                    response.type = 'REQUEST_RESPONSE';\n                    response.requestID = requestID;\n                    messageToLivePreviewTabs(response);\n                })\n                .catch(console.error);\n        }\n    });\n    exports.on(EVENT_GET_PHOENIX_INSTANCE_ID, function(_ev){\n        messageToLivePreviewTabs({\n            type: 'PHOENIX_INSTANCE_ID',\n            PHOENIX_INSTANCE_ID: Phoenix.PHOENIX_INSTANCE_ID\n        });\n    });\n\n    exports.on(EVENT_TAB_ONLINE, function(_ev, event){\n        livePreviewTabs.set(event.data.message.clientID, {\n            lastSeen: new Date(),\n            URL: event.data.message.URL\n        });\n    });\n\n    function _startHeartBeatListeners() {\n        // If we didn't receive heartbeat message from a tab for 10 seconds, we assume tab closed\n        const TAB_HEARTBEAT_TIMEOUT = 10000; // in millis secs\n        setInterval(()=>{\n            let endTime = new Date();\n            for(let tab of livePreviewTabs.keys()){\n                const tabInfo = livePreviewTabs.get(tab);\n                let timeDiff = endTime - tabInfo.lastSeen; // in ms\n                if(timeDiff > TAB_HEARTBEAT_TIMEOUT){\n                    livePreviewTabs.delete(tab);\n                    // the parent navigationTab `phcode.dev/live-preview-loader.html` which loads the live preview tab\n                    // is in the list too. We should not raise browser close for a live-preview-loader tab.\n                    if(!tabInfo.navigationTab) {\n                        exports.trigger('BROWSER_CLOSE', { data: { message: {clientID: tab}}});\n                    }\n                }\n            }\n        }, 1000);\n    }\n\n    /**\n     * The message should be and object of the form: {type, ...}. a type attribute is mandatory\n     * @param message\n     */\n    function messageToLivePreviewTabs(message) {\n        if(!message.type){\n            throw new Error('Missing type attribute to send live preview message to tabs');\n        }\n        // The embedded iframe is a trusted origin and hence we use '*'. We can alternatively use\n        // getStaticServerBaseURLs().origin, but there seems to be a single error on startup\n        // Most likely as we switch frequently between about:blank and the live preview server host page.\n        // Error message in console:\n        // `Failed to execute 'postMessage' on 'DOMWindow': The target origin provided ('http://localhost:8001')\n        // does not match the recipient window's origin ('http://localhost:8000').`\n        $livepreviewServerIframe && $livepreviewServerIframe[0].contentWindow.postMessage(message, '*');\n        _sendToLivePreviewServerTabs(message);\n    }\n\n    let currentPopoutURL;\n    function _sendInitialURL(pageLoaderID) {\n        if(!currentPopoutURL){\n            return;\n        }\n        navigatorChannel.postMessage({\n            type: 'INITIAL_URL_NAVIGATE',\n            URL: currentPopoutURL,\n            pageLoaderID: pageLoaderID\n        });\n    }\n\n    function redirectAllTabs(newURL, force) {\n        currentPopoutURL = newURL;\n        navigatorChannel.postMessage({\n            type: 'REDIRECT_PAGE',\n            URL: newURL,\n            force\n        });\n    }\n\n    function _projectOpened(_evt, projectRoot) {\n        navigatorChannel.postMessage({\n            type: 'PROJECT_SWITCH',\n            projectRoot: projectRoot.fullPath\n        });\n    }\n\n    exports.on(EVENT_UPDATE_TITLE_ICON, function(_ev, event){\n        const title = event.data.message.title;\n        const faviconBase64 = event.data.message.faviconBase64;\n        navigatorChannel.postMessage({\n            type: 'UPDATE_TITLE_ICON',\n            title,\n            faviconBase64\n        });\n    });\n\n    function _isLiveHighlightEnabled() {\n        return CommandManager.get(Commands.FILE_LIVE_HIGHLIGHT).getChecked();\n    }\n    exports.on(EVENT_EMBEDDED_IFRAME_ESCAPE_PRESS, function () {\n        if(!_isLiveHighlightEnabled()){\n            return;\n        }\n        utils.focusActiveEditorIfFocusInLivePreview();\n    });\n\n    function getPageLoaderURL(url) {\n        return `${Phoenix.baseURL}live-preview-loader.html?`\n            +`virtualServerURL=${encodeURIComponent(LIVE_PREVIEW_STATIC_SERVER_BASE_URL)}`\n            +`&phoenixInstanceID=${Phoenix.PHOENIX_INSTANCE_ID}&initialURL=${encodeURIComponent(url)}`\n            +`&localMessage=${encodeURIComponent(Strings.DESCRIPTION_LIVEDEV_SECURITY_POPOUT_MESSAGE)}`\n            +`&appName=${encodeURIComponent(Strings.APP_NAME)}`\n            +`&initialProjectRoot=${encodeURIComponent(ProjectManager.getProjectRoot().fullPath)}`\n            +`&okMessage=${encodeURIComponent(Strings.TRUST_PROJECT)}`;\n    }\n\n    function getTabPopoutURL(url) {\n        let openURL = new URL(url);\n        // we tag all externally opened urls with query string parameter phcodeLivePreview=\"true\" to address\n        // #LIVE_PREVIEW_TAB_NAVIGATION_RACE_FIX\n        openURL.searchParams.set(PHCODE_LIVE_PREVIEW_QUERY_PARAM, \"true\");\n        return  getPageLoaderURL(openURL.href);\n    }\n\n    function hasActiveLivePreviews() {\n        return livePreviewTabs.size > 0;\n    }\n\n    function getRemoteTransportScript() {\n        return `TRANSPORT_CONFIG.LIVE_PREVIEW_BROADCAST_CHANNEL_ID = \"${LIVE_PREVIEW_BROADCAST_CHANNEL_ID}\";\\n`;\n    }\n\n    function init() {\n        LiveDevelopment.setLivePreviewTransportBridge(exports);\n        // load the hidden iframe that loads the service worker server page once. we will reuse the same server\n        // as this is a cross-origin server phcode.live, the browser will identify it as a security issue\n        // if we continuously reload the service worker loader page frequently and it will stop working.\n        $livepreviewServerIframe = $(\"#live-preview-server-iframe\");\n        let url = LIVE_PREVIEW_STATIC_SERVER_BASE_URL +\n            `?parentOrigin=${location.origin}`;\n        $livepreviewServerIframe.attr(\"src\", url);\n        _initNavigatorChannel();\n        _initLivePreviewChannel();\n        EventManager.registerEventHandler(\"ph-liveServer\", exports);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_OPEN, _projectOpened);\n        _startHeartBeatListeners();\n    }\n\n    exports.init = init;\n    exports.StaticServer = StaticServer;\n    exports.messageToLivePreviewTabs = messageToLivePreviewTabs;\n    exports.getPreviewDetails = getPreviewDetails;\n    exports.livePreviewTabs = livePreviewTabs;\n    exports.redirectAllTabs = redirectAllTabs;\n    exports.getTabPopoutURL = getTabPopoutURL;\n    exports.hasActiveLivePreviews = hasActiveLivePreviews;\n    exports.getNoPreviewURL = getNoPreviewURL;\n    exports.getRemoteTransportScript = getRemoteTransportScript;\n    exports.PHCODE_LIVE_PREVIEW_QUERY_PARAM = PHCODE_LIVE_PREVIEW_QUERY_PARAM;\n    exports.EVENT_SERVER_READY = EVENT_SERVER_READY;\n});\n"],"file":"BrowserStaticServer.js"}
{"version":3,"sources":["extensions/default/DebugCommands/MacroRunner.js"],"names":["define","require","exports","module","FileViewController","brackets","getModule","CommandManager","EditorManager","KeyEvent","Commands","PreferencesManager","Editor","_","ProjectManager","openFile","filePath","startsWith","jsPromise","openFileAndAddToWorkingSet","projectFilePath","path","join","getProjectRoot","fullPath","setCursors","selections","activeEditor","getActiveEditor","Error","parsedSelections","map","selection","parts","split","length","line","ch","Number","isNaN","start","end","fromLine","fromCh","toLine","toCh","setSelections","computeCursors","editor","addQuotes","getSelections","cursor","expectCursorsToBe","expectedSelections","currentSelections","i","includes","raiseKeyEvent","key","event","element","options","doc","ownerDocument","view","defaultView","bubbles","cancelable","keyIdentifer","keyIdentifier","oEvent","KeyboardEvent","Object","defineProperty","get","this","keyCodeVal","keyCode","console","log","dispatchEvent","keydown","keysArray","modifiers","document","activeElement","typeAtCursor","text","origin","replaceRange","_toPos","posString","pos","validateText","from","to","selectedText","getTextBetween","_getMarkLocations","markType","whichAPI","marks","getAllMarks","marksLocations","mark","loc","find","push","validateAllMarks","validateEqual","obj1","obj2","isEqual","JSON","stringify","validateMarks","totalMarkCount","undefined","closeFile","execute","FILE_CLOSE","_forceClose","closeAll","FILE_CLOSE_ALL","execCommand","commandID","args","undo","EDIT_UNDO","redo","EDIT_REDO","setPreference","value","set","getPreference","EDITING","setEditorSpacing","useTabs","spaceOrTabCount","isAutoMode","file","getAutoTabSpaces","setAutoTabSpaces","_autoDetectTabSpaces","setUseTabChar","setTabSize","setSpaceUnits","__PR","async","runMacro","macroText","errors","AsyncFunction","constructor","macroAsync","e","error","lineNo","errorCode","errorText","Phoenix","isTestWindow","window"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, jsPromise*/\n\n/**\n *  Utilities functions for running macros.\n *  Eg:\n *  await __PR.openFile(\"a.html\");\n *   __PR.setCursors([\"17:28\", \"17:28-17:30\"])\n * __PR.expectCursorsToBe([\"17:28\", \"17:28-17:30\"])\n * __PR.keydown([\"BACK_SPACE\"])\n * __PR.typeAtCursor(\"hello\")\n * __PR.validateText(`a`, \"16:14-16:15\")\n * __PR.validateAllMarks(\"startTagSyncEdit\", [\"16:14-16:15\"]); // All marks of type startTagSyncEdit should be there\n * __PR.validateMarks(\"startTagSyncEdit\", [\"16:14-16:15\"], 1); // 1 is total marks of type startTagSyncEdit\n *\n *  This can be later extended to run macros. But since this uses eval, the\n *  security posture must be changed. One way is to:\n *  1. create an iframe that contains the macro panel and codemirror surface in a sandboxed or 3rd party context. This\n *     will create origin isolation in browser so that extensions cannot read or write to the ifrmae macro code.\n *  2. The iframe should be created in an extensions and once created, only that iframe should be tested to run evaled\n *     code. So the iframe will post message with code to eval and we will only eval that.\n *  3. The iframe can request to save data to eval which we need to carefully handle.\n *  4. Now this is a problem only when we securely sandbox extensions in the future, as for now an extension can run\n *     eval itself and pretty much all of this is no-op till we have extension sandbox. So this is not the security\n *     model now.\n */\ndefine(function (require, exports, module) {\n    const FileViewController = brackets.getModule(\"project/FileViewController\"),\n        CommandManager = brackets.getModule(\"command/CommandManager\"),\n        EditorManager = brackets.getModule(\"editor/EditorManager\"),\n        KeyEvent = brackets.getModule(\"utils/KeyEvent\"),\n        Commands = brackets.getModule(\"command/Commands\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Editor = brackets.getModule(\"editor/Editor\"),\n        _ = brackets.getModule(\"thirdparty/lodash\"),\n        ProjectManager = brackets.getModule(\"project/ProjectManager\");\n\n    /**\n     * Open a project relative file or absolute file path. if no leading slash, path is assumed to be project relative\n     * @param filePath\n     * @returns {Promise<null>}\n     */\n    function openFile(filePath) {\n        if(filePath.startsWith('/')) {\n            return jsPromise(FileViewController.openFileAndAddToWorkingSet(filePath));\n        }\n        const projectFilePath = path.join(ProjectManager.getProjectRoot().fullPath, filePath);\n        return jsPromise(FileViewController.openFileAndAddToWorkingSet(projectFilePath));\n    }\n\n\n    /**\n     * Set cursor positions or text selections in the active CodeMirror editor based on a specified format.\n     * The input should be an array of strings where each string can denote a cursor position (\"line:char\")\n     * or a text selection range (\"line:char-line:char\"). For a selection, the first part is the anchor and\n     * the second is the head of the selection.\n     *\n     * Example usage: [\"1:2\", \"2:2-3:4\"]\n     *\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     * @throws {Error} Throws an error if no active editor is found or if there are parsing issues with the input.\n     */\n    function setCursors(selections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to set cursor at: ${selections}`);\n        }\n        // Parse the selection strings to CodeMirror positions\n        const parsedSelections = selections.map(selection => {\n            const parts = selection.split('-');\n            if (parts.length === 1) {\n                const [line, ch] = parts[0].split(':').map(Number);\n                if (isNaN(line) || isNaN(ch)) {\n                    throw new Error(`Invalid cursor format: ${parts[0]} for ${selections}`);\n                }\n                return {start: {line: line - 1, ch: ch - 1}, end: {line: line - 1, ch: ch - 1}};\n            } else if (parts.length === 2) {\n                const [fromLine, fromCh] = parts[0].split(':').map(Number);\n                const [toLine, toCh] = parts[1].split(':').map(Number);\n                if (isNaN(fromLine) || isNaN(fromCh) || isNaN(toLine) || isNaN(toCh)) {\n                    throw new Error(`Invalid selection range format: ${selection}`);\n                }\n                return {start: {line: fromLine - 1, ch: fromCh -1}, end: {line: toLine - 1, ch: toCh - 1}};\n            } else {\n                throw new Error(`Invalid format: ${selection}`);\n            }\n        });\n\n        // Set the selections in the editor\n        activeEditor.setSelections(parsedSelections);\n    }\n\n    /**\n     * gets cursor selections array that can be used in the setCursors API\n     * @param editor\n     * @returns {*}\n     */\n    function computeCursors(editor, addQuotes) {\n        const selections = editor.getSelections();\n        return selections.map(selection => {\n            const start = selection.start;\n            const end = selection.end;\n            let cursor;\n\n            // Check if the selection is a cursor (start and end are the same)\n            if (start.line === end.line && start.ch === end.ch) {\n                cursor = `${start.line + 1}:${start.ch + 1}`;\n            } else {\n                cursor = `${start.line + 1}:${start.ch + 1}-${end.line + 1}:${end.ch + 1}`;\n            }\n            return addQuotes ? `\"${cursor}\"` : cursor;\n        });\n    }\n\n    /**\n     * Validates the currently active editor has selections as given here\n     */\n    function expectCursorsToBe(expectedSelections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found for expectCursorsToBe: ${expectedSelections}`);\n        }\n        const currentSelections = computeCursors(activeEditor);\n        if(currentSelections.length !== expectedSelections.length) {\n            throw new Error(`expectCursorsToBe: [${expectedSelections.join(\", \")}] `+\n             `but got [${currentSelections.join(\", \")}]`);\n        }\n        for(let i = 0; i < currentSelections.length; i++) {\n            if(!currentSelections.includes(`${expectedSelections[i]}`) ||\n                !expectedSelections.includes(currentSelections[i])){\n                throw new Error(`expectCursorsToBe: [${expectedSelections.join(\", \")}] `+\n                    `but got [${currentSelections.join(\", \")}]`);\n            }\n        }\n    }\n\n    /**\n     * Simulate a key event.\n     * @param {Number} key Key code available as One of the KeyEvent.DOM_VK_*\n     * @param {String} event Key event to simulate. one of keydown, keyup or keypress\n     * @param {HTMLElement} element Element to receive event\n     * @param {KeyboardEventInit} options Optional arguments for key event\n     */\n    function raiseKeyEvent(key, event, element, options) {\n        const doc = element.ownerDocument;\n\n        if(typeof options === 'undefined') {\n            options = {\n                view: doc.defaultView,\n                bubbles: true,\n                cancelable: true,\n                keyIdentifer: key\n            };\n        } else {\n            options.view = doc.defaultView;\n            options.bubbles = true;\n            options.cancelable = true;\n            options.keyIdentifier = key;\n        }\n        const oEvent = new KeyboardEvent(event, options);\n\n        if (event !== \"keydown\" && event !== \"keyup\" && event !== \"keypress\") {\n            console.log(\"SpecRunnerUtils.simulateKeyEvent() - unsupported keyevent: \" + event);\n            return;\n        }\n\n        // Chromium Hack: need to override the 'which' property.\n        // Note: this code is not designed to work in IE, Safari,\n        // or other browsers. Well, maybe with Firefox. YMMV.\n        Object.defineProperty(oEvent, 'keyCode', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n        Object.defineProperty(oEvent, 'which', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n        Object.defineProperty(oEvent, 'charCode', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n\n        oEvent.keyCodeVal = key;\n        if (oEvent.keyCode !== key) {\n            console.log(\"SpecRunnerUtils.simulateKeyEvent() - keyCode mismatch: \" + oEvent.keyCode);\n        }\n\n        element.dispatchEvent(oEvent);\n    }\n\n    /**\n     * @param {Array<string>} keysArray An array of Key strings available as One of the KeyEvent.DOM_VK_* without the\n     *    `KeyEvent.DOM_VK_` prefix. Eg: use `[\"ESCAPE\"]` instead of fully specifying [`DOM_VK_ESCAPE`]\n     *    E.g: __PR.keydown([\"BACK_SPACE\"]) or __PR.keydown([\"BACK_SPACE\"], {ctrlKey: true})\n     * @param {object} modifiers to modify the key\n     * @param {boolean} modifiers.ctrlKey\n     * @param {boolean} modifiers.altKey\n     * @param {boolean} modifiers.shiftKey\n     * @param {boolean} modifiers.metaKey\n     * @param keysArray\n     */\n    function keydown(keysArray, modifiers) {\n        for(let key of keysArray) {\n            if(typeof key === \"string\"){\n                if(!key.startsWith(\"DOM_VK_\")){\n                    key = \"DOM_VK_\"+key;\n                }\n                key = KeyEvent[key];\n                if(!key){\n                    throw new Error(`Invalid key \"${key}\"`);\n                }\n            }\n            raiseKeyEvent(key, \"keydown\", document.activeElement, modifiers);\n        }\n    }\n\n    function typeAtCursor(text, origin) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to typeAtCursor: ${text}`);\n        }\n        const selections = activeEditor.getSelections();\n        // Insert text at each cursor or the head of each selection.\n        // We perform the insertions in reverse order to avoid affecting the indices of subsequent insertions.\n        for (let selection of selections) {\n            activeEditor.replaceRange(text, selection.start, selection.end, origin);\n        }\n    }\n\n    // converts string of from \"ln:ch\" to pos object\n    function _toPos(posString) {\n        const pos = posString.split(\":\");\n        return {line: Number(pos[0]) - 1, ch: Number(pos[1]) - 1 };\n    }\n\n    /**\n     * Verify if the given text is same as what is in between the given selection.\n     * @param {string} text\n     * @param {string} selection of the form \"ln:ch-ln:ch\"\n     */\n    function validateText(text, selection) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to validateText: ${text} at selection ${selection}`);\n        }\n        const from = selection.split(\"-\")[0], to = selection.split(\"-\")[1];\n        const selectedText = activeEditor.getTextBetween(_toPos(from), _toPos(to));\n        if(selectedText !== text){\n            throw new Error(`validateText: expected text at [${selection}] to be \"${text}\" but got \"${selectedText}\"`);\n        }\n    }\n\n    function _getMarkLocations(markType, whichAPI, selections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to ${whichAPI}: \"${markType}\" for selection \"${selections}\"`);\n        }\n        const marks = activeEditor.getAllMarks(markType);\n        const marksLocations = [];\n        for(let mark of marks){\n            const loc = mark.find();\n            marksLocations.push(`${loc.from.line+1}:${loc.from.ch+1}-${loc.to.line+1}:${loc.to.ch+1}`);\n        }\n        return marksLocations;\n    }\n\n    /**\n     * validates all marks of the given mark type\n     * @param {string} markType\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     */\n    function validateAllMarks(markType, selections) {\n        const marksLocations = _getMarkLocations(markType, \"validateAllMarks\", selections);\n        if(!selections || marksLocations.length !== selections.length){\n            throw new Error(`validateAllMarks expected marks \"${markType}\" at: [${selections&&selections.join(\", \")}] `+\n                `but got marked locations [${marksLocations.join(\", \")}]`);\n        }\n        for(let i = 0; i < selections.length; i++) {\n            if(!selections.includes(`${marksLocations[i]}`) ||\n                !marksLocations.includes(selections[i])){\n                throw new Error(`validateAllMarks expected marks \"${markType}\" at: [${selections.join(\", \")}] `+\n                    `but got marked locations [${marksLocations.join(\", \")}]`);\n            }\n        }\n    }\n\n    function validateEqual(obj1, obj2) {\n        if(!_.isEqual(obj1, obj2)){\n            throw new Error(`validateEqual: expected ${JSON.stringify(obj1)} to equal ${JSON.stringify(obj2)}`);\n        }\n    }\n\n    /**\n     * validates if the given mark type is present in the specified selections\n     * @param {string} markType\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     * @param {number} [totalMarkCount] optional to validate against the total number of expected marks of the type\n     */\n    function validateMarks(markType, selections, totalMarkCount) {\n        const marksLocations = _getMarkLocations(markType, \"validateMarks\", selections);\n        if(!selections){\n            return;\n        }\n        if(totalMarkCount !== undefined && marksLocations.length !== totalMarkCount){\n            throw new Error(`validateMarks expected mark count for \"${markType}\" to be: ${totalMarkCount} `+\n                `but got ${marksLocations.length}`);\n        }\n        for(let selection of selections) {\n            if(!marksLocations.includes(selection)){\n                throw new Error(`validateMarks expected marks \"${markType}\" to be at: [${selections.join(\", \")}] `+\n                    `but got marked locations [${marksLocations.join(\", \")}]`);\n            }\n        }\n    }\n\n    function closeFile() {\n        return jsPromise(CommandManager.execute(Commands.FILE_CLOSE, { _forceClose: true }));\n    }\n\n    function closeAll() {\n        return jsPromise(CommandManager.execute(Commands.FILE_CLOSE_ALL, { _forceClose: true }));\n    }\n\n    function execCommand(commandID, args) {\n        return jsPromise(CommandManager.execute(commandID, args));\n    }\n\n    function undo() {\n        return execCommand(Commands.EDIT_UNDO);\n    }\n\n    function redo() {\n        return execCommand(Commands.EDIT_REDO);\n    }\n\n    function setPreference(key, value){\n        PreferencesManager.set(key, value);\n    }\n\n    function getPreference(key){\n        return PreferencesManager.get(key);\n    }\n\n    const EDITING = {\n        setEditorSpacing: function (useTabs, spaceOrTabCount, isAutoMode) {\n            const activeEditor = EditorManager.getActiveEditor();\n            if(!activeEditor){\n                throw new Error(`No active editor found to setEditorSpacing`);\n            }\n            const fullPath = activeEditor.document.file.fullPath;\n            if(Editor.Editor.getAutoTabSpaces(fullPath) !== isAutoMode){\n                Editor.Editor.setAutoTabSpaces(isAutoMode, fullPath);\n                isAutoMode && Editor.Editor._autoDetectTabSpaces(activeEditor, true, true);\n            }\n            Editor.Editor.setUseTabChar(useTabs, fullPath);\n            if(useTabs) {\n                Editor.Editor.setTabSize(spaceOrTabCount, fullPath);\n            } else {\n                Editor.Editor.setSpaceUnits(spaceOrTabCount, fullPath);\n            }\n        }\n    };\n\n    const __PR= {\n        openFile, setCursors, expectCursorsToBe, keydown, typeAtCursor, validateText, validateAllMarks, validateMarks,\n        closeFile, closeAll, undo, redo, setPreference, getPreference, validateEqual, EDITING\n    };\n\n    async function runMacro(macroText) {\n        let errors = [];\n        try{\n            const AsyncFunction = async function () {}.constructor;\n            const macroAsync = new AsyncFunction(\"__PR\", \"KeyEvent\", macroText);\n            await macroAsync(__PR, KeyEvent);\n        } catch (e) {\n            console.error(\"Error executing macro: \", macroText, e);\n            errors.push({\n                lineNo: 0, line: '',\n                errorCode: `ERROR_EXEC`,\n                errorText: `${e}`\n            });\n        }\n        return errors;\n    }\n\n    if(Phoenix.isTestWindow) {\n        window.__PR = __PR;\n    }\n    exports.computeCursors = computeCursors;\n    exports.runMacro = runMacro;\n});\n"],"file":"MacroRunner.js"}
{"version":3,"sources":["editor/EditorHelper/IndentHelper.js"],"names":["define","require","exports","module","_","CodeMirror","PreferencesManager","EditorPreferences","SOFT_TABS","INDENT_REGEX","INDENT_TYPE_SPACE","INDENT_TYPE_TAB","makeIndentsMap","editor","ignoreSingleSpaces","scanLineLimit","indents","Map","previousSize","previousIndentType","totalLines","lineCount","key","scanLimit","Math","min","i","line","document","getLine","indent","indentType","use","weight","entry","matches","match","length","indentDifference","absoluteIndentDifference","encodeIndentsKey","undefined","get","set","indentAmount","typeCharacter","String","decodeIndentsKey","indentsKey","keyHasTypeSpace","type","amount","Number","slice","getMostUsedKey","result","maxUsed","maxWeight","usedCount","makeIndentString","indentCharacter","repeat","_detectIndent","this","size","keyOfMostUsedIndent","_addIndentAtEachSelection","selections","self","instance","_codeMirror","usingTabs","getOption","indentUnit","edits","each","sel","indentStr","numSpaces","start","ch","push","edit","text","doMultipleEdits","_autoIndentEachSelection","lineLengths","commands","indentAuto","changed","newSelections","getSelections","index","newSel","cmpPos","end","indentMore","_handleTabKey","selectionType","search","_handleSoftTabNavigation","direction","functionName","overallJump","cursor","jump","substr","addHelpers","Editor","prototype"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * self program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * self program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with self program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Editor instance helpers for indentation relator editor flows. Only to be used from Editor.js.\n */\n\ndefine(function (require, exports, module) {\n\n    const _ = require(\"thirdparty/lodash\"),\n        CodeMirror = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        EditorPreferences = require(\"./EditorPreferences\");\n\n    const SOFT_TABS = EditorPreferences.SOFT_TABS;\n\n    /*Start of modified code: https://www.npmjs.com/package/detect-indent\n    * We modified the code to work on editor as well as text and adds `scanLineLimit` for partial scans in large text*/\n    // Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\n    const INDENT_REGEX = /^(?:( )+|\\t+)/;\n\n    const INDENT_TYPE_SPACE = 'space';\n    const INDENT_TYPE_TAB = 'tab';\n\n    /**\n     Make a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\n     The key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n     ```\n     indents = {\n     t3: [1, 0],\n     t4: [1, 5],\n     s5: [1, 0],\n     s12: [1, 0],\n     }\n     ```\n     */\n    function makeIndentsMap(editor, ignoreSingleSpaces, scanLineLimit) {\n        const indents = new Map();\n\n        // Remember the size of previous line's indentation\n        let previousSize = 0;\n        let previousIndentType;\n\n        // Indents key (ident type + size of the indents/unindents)\n        const totalLines = editor.lineCount();\n        let key, scanLimit = scanLineLimit ? Math.min(scanLineLimit, totalLines) : totalLines;\n\n        for (let i =0; i < scanLimit; i++) {\n            const line = editor.document.getLine(i);\n            if (!line) {\n                // Ignore empty lines\n                continue;\n            }\n\n            let indent;\n            let indentType;\n            let use;\n            let weight;\n            let entry;\n            const matches = line.match(INDENT_REGEX);\n\n            if (matches === null) {\n                previousSize = 0;\n                previousIndentType = '';\n            } else {\n                indent = matches[0].length;\n                indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n                // Ignore single space unless it's the only indent detected to prevent common false positives\n                if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n                    continue;\n                }\n\n                if (indentType !== previousIndentType) {\n                    previousSize = 0;\n                }\n\n                previousIndentType = indentType;\n\n                use = 1;\n                weight = 0;\n\n                const indentDifference = indent - previousSize;\n                previousSize = indent;\n\n                // Previous line have same indent?\n                if (indentDifference === 0) {\n                    // Not a new \"use\" of the current indent:\n                    use = 0;\n                    // But do add a bit to it for breaking ties:\n                    weight = 1;\n                    // We use the key from previous loop\n                } else {\n                    const absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n                    key = encodeIndentsKey(indentType, absoluteIndentDifference);\n                }\n\n                // Update the stats\n                entry = indents.get(key);\n                entry = entry === undefined ? [1, 0] : [entry[0] + use, entry[1] + weight];\n\n                indents.set(key, entry);\n            }\n        }\n\n        return indents;\n    }\n\n    // Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\n    function encodeIndentsKey(indentType, indentAmount) {\n        const typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n        return typeCharacter + String(indentAmount);\n    }\n\n    // Extract the indent type and amount from a key of the indents Map.\n    function decodeIndentsKey(indentsKey) {\n        const keyHasTypeSpace = indentsKey[0] === 's';\n        const type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n        const amount = Number(indentsKey.slice(1));\n\n        return {type, amount};\n    }\n\n    // Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n    // or return undefined if there are no indents.\n    function getMostUsedKey(indents) {\n        let result;\n        let maxUsed = 0;\n        let maxWeight = 0;\n\n        for (const [key, [usedCount, weight]] of indents) {\n            if (usedCount > maxUsed || (usedCount === maxUsed && weight > maxWeight)) {\n                maxUsed = usedCount;\n                maxWeight = weight;\n                result = key;\n            }\n        }\n\n        return result;\n    }\n\n    function makeIndentString(type, amount) {\n        const indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n        return indentCharacter.repeat(amount);\n    }\n\n    /**\n     * computes the tab/spaces config for the file\n     * @param {number} [scanLineLimit] - Optional number of lines to scan. This can be used if you dont want to scan\n     *   full text for large texts. default scans all text.\n     * @returns {{amount: number, indent: string, type: (string)}}\n     */\n    function _detectIndent(scanLineLimit) {\n        const editor = this;\n        // Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n        // If no indents are identified, run again and include all indents for comprehensive detection\n        let indents = makeIndentsMap(editor, true, scanLineLimit);\n        if (indents.size === 0) {\n            indents = makeIndentsMap(editor, false, scanLineLimit);\n        }\n\n        const keyOfMostUsedIndent = getMostUsedKey(indents);\n\n        let type;\n        let amount = 0;\n        let indent = '';\n\n        if (keyOfMostUsedIndent !== undefined) {\n            ({type, amount} = decodeIndentsKey(keyOfMostUsedIndent));\n            indent = makeIndentString(type, amount);\n        }\n\n        return {\n            amount,\n            type,\n            indent\n        };\n    }\n    /*End of copied code: https://www.npmjs.com/package/detect-indent*/\n\n    /**\n     * Helper function for `_handleTabKey()` (case 2) - see comment in that function.\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\n     *     The selections to indent.\n     */\n    function _addIndentAtEachSelection(selections) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        var instance = self._codeMirror,\n            usingTabs = instance.getOption(\"indentWithTabs\"),\n            indentUnit = instance.getOption(\"indentUnit\"),\n            edits = [];\n\n        _.each(selections, function (sel) {\n            var indentStr = \"\", i, numSpaces;\n            if (usingTabs) {\n                indentStr = \"\\t\";\n            } else {\n                numSpaces = indentUnit - (sel.start.ch % indentUnit);\n                for (i = 0; i < numSpaces; i++) {\n                    indentStr += \" \";\n                }\n            }\n            edits.push({edit: {text: indentStr, start: sel.start}});\n        });\n\n        self.document.doMultipleEdits(edits);\n    }\n\n    /**\n     * Helper function for `_handleTabKey()` (case 3) - see comment in that function.\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\n     *     The selections to indent.\n     */\n    function _autoIndentEachSelection(selections) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        // Capture all the line lengths, so we can tell if anything changed.\n        // Note that self function should only be called if all selections are within a single line.\n        var instance = self._codeMirror,\n            lineLengths = {};\n        _.each(selections, function (sel) {\n            lineLengths[sel.start.line] = instance.getLine(sel.start.line).length;\n        });\n\n        // First, try to do a smart indent on all selections.\n        CodeMirror.commands.indentAuto(instance);\n\n        // If there were no code or selection changes, then indent each selection one more indent.\n        var changed = false,\n            newSelections = self.getSelections();\n        if (newSelections.length === selections.length) {\n            _.each(selections, function (sel, index) {\n                var newSel = newSelections[index];\n                if (CodeMirror.cmpPos(sel.start, newSel.start) !== 0 ||\n                    CodeMirror.cmpPos(sel.end, newSel.end) !== 0 ||\n                    instance.getLine(sel.start.line).length !== lineLengths[sel.start.line]) {\n                    changed = true;\n                    // Bail - we don't need to look any further once we've found a change.\n                    return false;\n                }\n            });\n        } else {\n            changed = true;\n        }\n\n        if (!changed) {\n            CodeMirror.commands.indentMore(instance);\n        }\n    }\n\n    function _handleTabKey() {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        // Tab key handling is done as follows:\n        // 1. If any of the selections are multiline, just add one indent level to the\n        //    beginning of all lines that intersect any selection.\n        // 2. Otherwise, if any of the selections is a cursor or single-line range that\n        //    ends at or after the first non-whitespace character in a line:\n        //    - if indentation is set to tabs, just insert a hard tab before each selection.\n        //    - if indentation is set to spaces, insert the appropriate number of spaces before\n        //      each selection to get to its next soft tab stop.\n        // 3. Otherwise (all selections are cursors or single-line, and are in the whitespace\n        //    before their respective lines), try to autoindent each line based on the mode.\n        //    If none of the cursors moved and no space was added, then add one indent level\n        //    to the beginning of all lines.\n\n        // Note that in case 2, we do the \"dumb\" insertion even if the cursor is immediately\n        // before the first non-whitespace character in a line. It might seem more convenient\n        // to do autoindent in that case. However, the problem is if that line is already\n        // indented past its \"proper\" location. In that case, we don't want Tab to\n        // *outdent* the line. If we had more control over the autoindent algorithm or\n        // implemented it ourselves, we could handle that case separately.\n\n        var instance = self._codeMirror,\n            selectionType = \"indentAuto\",\n            selections = self.getSelections();\n\n        _.each(selections, function (sel) {\n            if (sel.start.line !== sel.end.line) {\n                // Case 1 - we found a multiline selection. We can bail as soon as we find one of these.\n                selectionType = \"indentAtBeginning\";\n                return false;\n            } else if (sel.end.ch > 0 && sel.end.ch >= instance.getLine(sel.end.line).search(/\\S/)) {\n                // Case 2 - we found a selection that ends at or after the first non-whitespace\n                // character on the line. We need to keep looking in case we find a later multiline\n                // selection though.\n                selectionType = \"indentAtSelection\";\n            }\n        });\n\n        switch (selectionType) {\n        case \"indentAtBeginning\":\n            // Case 1\n            CodeMirror.commands.indentMore(instance);\n            break;\n\n        case \"indentAtSelection\":\n            // Case 2\n            self._addIndentAtEachSelection(selections);\n            break;\n\n        case \"indentAuto\":\n            // Case 3\n            self._autoIndentEachSelection(selections);\n            break;\n        }\n    }\n\n    /**\n     * @private\n     * Handle left arrow, right arrow, backspace and delete keys when soft tabs are used.\n     * @param {number} direction Direction of movement: 1 for forward, -1 for backward\n     * @param {string} functionName name of the CodeMirror function to call if we handle the key\n     */\n    function _handleSoftTabNavigation(direction, functionName) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        var instance = self._codeMirror,\n            overallJump = null;\n\n        if (!instance.getOption(\"indentWithTabs\") && PreferencesManager.get(SOFT_TABS)) {\n            var indentUnit = instance.getOption(\"indentUnit\");\n\n            _.each(self.getSelections(), function (sel) {\n                if (CodeMirror.cmpPos(sel.start, sel.end) !== 0) {\n                    // self is a range - it will just collapse/be deleted regardless of the jump we set, so\n                    // we can just ignore it and continue. (We don't want to return false in self case since\n                    // we want to keep looking at other ranges.)\n                    return;\n                }\n\n                var cursor = sel.start,\n                    jump   = (indentUnit === 0) ? 1 : cursor.ch % indentUnit,\n                    line   = instance.getLine(cursor.line);\n\n                // Don't do any soft tab handling if there are non-whitespace characters before the cursor in\n                // any of the selections.\n                if (line.substr(0, cursor.ch).search(/\\S/) !== -1) {\n                    jump = null;\n                } else if (direction === 1) { // right\n                    if (indentUnit) {\n                        jump = indentUnit - jump;\n                    }\n\n                    // Don't jump if it would take us past the end of the line, or if there are\n                    // non-whitespace characters within the jump distance.\n                    if (cursor.ch + jump > line.length || line.substr(cursor.ch, jump).search(/\\S/) !== -1) {\n                        jump = null;\n                    }\n                } else { // left\n                    // If we are on the tab boundary, jump by the full amount,\n                    // but not beyond the start of the line.\n                    if (jump === 0) {\n                        jump = indentUnit;\n                    }\n                    if (cursor.ch - jump < 0) {\n                        jump = null;\n                    } else {\n                        // We're moving left, so negate the jump.\n                        jump = -jump;\n                    }\n                }\n\n                // Did we calculate a jump, and is self jump value either the first one or\n                // consistent with all the other jumps? If so, we're good. Otherwise, bail\n                // out of the foreach, since as soon as we hit an inconsistent jump we don't\n                // have to look any further.\n                if (jump !== null &&\n                    (overallJump === null || overallJump === jump)) {\n                    overallJump = jump;\n                } else {\n                    overallJump = null;\n                    return false;\n                }\n            });\n        }\n\n        if (overallJump === null) {\n            // Just do the default move, which is one char in the given direction.\n            overallJump = direction;\n        }\n        instance[functionName](overallJump, \"char\");\n    }\n\n    /**\n     * add required helpers to editor\n     * @param Editor\n     */\n    function addHelpers(Editor) {\n        // only private Editor APIs should be assigned below. Public APIs should be updated in Editor.js only.\n        Editor.prototype._addIndentAtEachSelection = _addIndentAtEachSelection;\n        Editor.prototype._autoIndentEachSelection = _autoIndentEachSelection;\n        Editor.prototype._handleTabKey = _handleTabKey;\n        Editor.prototype._handleSoftTabNavigation = _handleSoftTabNavigation;\n        Editor.prototype._detectIndent = _detectIndent;\n    }\n\n    exports.addHelpers =addHelpers;\n});\n"],"file":"IndentHelper.js"}
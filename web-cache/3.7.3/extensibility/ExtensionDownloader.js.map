{"version":3,"sources":["extensibility/ExtensionDownloader.js"],"names":["define","require","exports","module","EventDispatcher","ExtensionLoader","FileUtils","NodeUtils","Package","FileSystem","FileSystemError","ZipUtils","makeEventDispatcher","EVENT_DOWNLOAD_FILE_PROGRESS","EVENT_EXTRACT_FILE_PROGRESS","downloadCancelled","_unzipExtension","data","projectPath","flattenFirstLevelInZip","progressCb","Promise","resolve","reject","unzipBinDataToLocation","then","catch","_getExtensionName","fileNameHint","guessedName","path","basename","substring","lastIndexOf","downloadFile","downloadId","url","filenameHint","destinationDirectory","_proxy","d","$","Deferred","getUserExtensionPath","console","log","window","JSZipUtils","getBinaryContent","callback","async","err","error","_progressCB","done","total","trigger","getFileForPath","unlink","extractErr","unlinkError","progress","status","percent","abortCheck","promise","abortDownload","_validateAndNpmInstallIfNodeExtension","nodeExtPath","packageJSONFile","join","packageJson","catchToNull","jsPromise","readAsText","JSON","parse","e","nodeConfig","main","nodeIsRequired","Phoenix","isNativeApp","nodeMainFile","file","isExists","existsAsync","npmInstallFolder","npmInstall","nodeModulesFolder","directory","getDirectoryForPath","nodePackageJson","nodePackageFile","npmInstallPlatformPath","fs","getTauriPlatformPath","_npmInstallInFolder","install","config","validationErr","name","nameHint","installationStatus","InstallationStatuses","FAILED","errors","INSTALLED","installedTo","_markForDeleteOnRestart","extensionDirectory","fullPath","_DELETED_EXTENSION_FILE_MARKER","writeText","remove","extensionPath","NOT_FOUND","update"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, jsPromise, catchToNull*/\n\ndefine(function (require, exports, module) {\n    const EventDispatcher = require(\"utils/EventDispatcher\"),\n        ExtensionLoader = require(\"utils/ExtensionLoader\"),\n        FileUtils        = require(\"file/FileUtils\"),\n        NodeUtils        = require(\"utils/NodeUtils\"),\n        Package  = require(\"extensibility/Package\"),\n        FileSystem = require(\"filesystem/FileSystem\"),\n        FileSystemError = require(\"filesystem/FileSystemError\"),\n        ZipUtils = require(\"utils/ZipUtils\");\n    EventDispatcher.makeEventDispatcher(exports);\n\n    const EVENT_DOWNLOAD_FILE_PROGRESS = \"DownloadProgress\",\n        EVENT_EXTRACT_FILE_PROGRESS = \"ExtractProgress\",\n        downloadCancelled = {};\n\n    function _unzipExtension(data, projectPath, flattenFirstLevelInZip, progressCb) {\n        return new Promise((resolve, reject)=>{\n            ZipUtils.unzipBinDataToLocation(data, projectPath, flattenFirstLevelInZip, progressCb)\n                .then(resolve)\n                .catch(reject);\n        });\n    }\n\n    function _getExtensionName(fileNameHint) {\n        let guessedName = path.basename(fileNameHint, \".zip\"); //Eg. c/x/rain.monokai-dark-soda-1.0.9.zip is input\n        guessedName = guessedName.substring(0, guessedName.lastIndexOf(\"-\"));\n        return guessedName; //rain.monokai-dark-soda\n    }\n\n    function downloadFile(downloadId, {url, filenameHint, destinationDirectory}, _proxy) {\n        const d = new $.Deferred();\n        let guessedName = _getExtensionName(filenameHint);\n        destinationDirectory = destinationDirectory || ExtensionLoader.getUserExtensionPath();\n        console.log(\"Download extension\", downloadId, url, filenameHint, guessedName);\n        window.JSZipUtils.getBinaryContent(url, {\n            callback: async function(err, data) {\n                if(downloadCancelled[downloadId]){\n                    d.reject();\n                    delete downloadCancelled[downloadId];\n                } else if(err) {\n                    console.error(\"could not download extension zip file!\", err);\n                    d.reject();\n                } else {\n                    function _progressCB(done, total) {\n                        exports.trigger(EVENT_EXTRACT_FILE_PROGRESS, done, total);\n                        return !downloadCancelled[downloadId]; // continueExtraction id not download cancelled\n                    }\n                    FileSystem.getFileForPath(destinationDirectory + \"/\" + guessedName).unlink(()=>{\n                        // we dont mind the error if there is any to delete the folder\n                        console.log(\"[Extension] extracting\", downloadId, url, filenameHint, guessedName);\n                        _unzipExtension(data, destinationDirectory + \"/\" + guessedName, true, _progressCB)\n                            .then(()=>{\n                                console.log(\"[Extension] extraction done\", downloadId, url, filenameHint, guessedName);\n                                d.resolve(destinationDirectory + \"/\" + guessedName);\n                            })\n                            .catch((extractErr)=>{\n                                console.error(\"Error extracting extension zip, cleaning up\", extractErr);\n                                FileSystem.getFileForPath(destinationDirectory + \"/\" + guessedName)\n                                    .unlink((unlinkError)=>{\n                                        if(unlinkError){\n                                            console.error(\"Error cleaning up extenstion folder: \",\n                                                destinationDirectory + \"/\" + unlinkError);\n                                        }\n                                        d.reject();\n                                    });\n                            });\n                    });\n                }\n            },\n            progress: function (status){\n                if(status.percent === 100) {\n                    exports.trigger(EVENT_EXTRACT_FILE_PROGRESS, 0);\n                    return;\n                }\n                exports.trigger(EVENT_DOWNLOAD_FILE_PROGRESS, status.percent || 0);\n            },\n            abortCheck: function () {\n                return downloadCancelled[downloadId];\n            }\n        });\n        return d.promise();\n    }\n\n    function abortDownload(downloadId) {\n        downloadCancelled[downloadId] = true;\n    }\n\n    async function _validateAndNpmInstallIfNodeExtension(nodeExtPath) {\n        const packageJSONFile = FileSystem.getFileForPath(path.join(nodeExtPath, \"package.json\"));\n        let packageJson = await catchToNull(jsPromise(FileUtils.readAsText(packageJSONFile)),\n            \"package.json not found for installing extension, trying to continue \"+ nodeExtPath);\n        try{\n            if(packageJson){\n                packageJson = JSON.parse(packageJson);\n            }\n        } catch (e) {\n            console.error(\"Error parsing package json for extension\", nodeExtPath, e);\n            return null; // let it flow, we are only concerned of node extensions\n        }\n        if(!packageJson || !packageJson.nodeConfig || !packageJson.nodeConfig.main){\n            // legacy extensions can be loaded with no package.json\n            // else if no node config, or node main is not defined, we just treat it as a non node extension\n            return null;\n        }\n        if(packageJson.nodeConfig.nodeIsRequired && !Phoenix.isNativeApp) {\n            return \"Extension can only be installed in native builds!\";\n        }\n        if(!Phoenix.isNativeApp){\n            return null;\n        }\n        let nodeMainFile = path.join(nodeExtPath, packageJson.nodeConfig.main);\n        let file = FileSystem.getFileForPath(nodeMainFile);\n        let isExists = await file.existsAsync();\n        if(!isExists){\n            console.error(\"Extension cannot be installed; could not find node main file: \",\n                nodeMainFile, packageJson.nodeConfig.main);\n            return \"Extension is broken, (Err: node main file not found)\";\n        }\n\n        let npmInstallFolder = packageJson.nodeConfig.npmInstall;\n        if(!npmInstallFolder) {\n            return null;\n        }\n        npmInstallFolder = path.join(nodeExtPath, packageJson.nodeConfig.npmInstall);\n        const nodeModulesFolder = path.join(npmInstallFolder, \"node_modules\");\n        let directory = FileSystem.getDirectoryForPath(npmInstallFolder);\n        isExists = await directory.existsAsync();\n        if(!isExists){\n            console.error(\"Extension cannot be installed; could not find folder to run npm install: \",\n                npmInstallFolder);\n            return \"Extension is broken, (Err: node source folder not found)\";\n        }\n\n        const nodePackageJson = path.join(npmInstallFolder, \"package.json\");\n        let nodePackageFile = FileSystem.getFileForPath(nodePackageJson);\n        isExists = await nodePackageFile.existsAsync();\n        if(!isExists){\n            console.error(\"Extension cannot be installed; could not find package.json file to npm install in: \",\n                npmInstallFolder);\n            return \"Extension is broken, (Err: it's node package.json not found)\";\n        }\n\n        directory = FileSystem.getDirectoryForPath(nodeModulesFolder);\n        isExists = await directory.existsAsync();\n        if(isExists) {\n            console.error(\"Could not install extension as the extension has node_modules folder in\" +\n                \" the package\", nodeModulesFolder, \"Extensions that defines a nodeConfig.npmInstall\" +\n                \" path should not package node_modules!\");\n            return \"Extension is broken. (Err: cannot npm install inside extension folder\" +\n                \" as it already has node_modules)\";\n        }\n        const npmInstallPlatformPath = Phoenix.fs.getTauriPlatformPath(npmInstallFolder);\n        return NodeUtils._npmInstallInFolder(npmInstallPlatformPath);\n    }\n\n    function install(path, destinationDirectory, config) {\n        const d = new $.Deferred();\n        // if we reached here in phoenix, install succeeded\n        _validateAndNpmInstallIfNodeExtension(path)\n            .then(validationErr =>{\n                if(validationErr) {\n                    d.resolve({\n                        name: _getExtensionName(config.nameHint),\n                        installationStatus: Package.InstallationStatuses.FAILED,\n                        errors: [validationErr]\n                    });\n                    return;\n                }\n                d.resolve({\n                    name: _getExtensionName(config.nameHint),\n                    installationStatus: Package.InstallationStatuses.INSTALLED,\n                    installedTo: path\n                });\n            }).catch(err=>{\n                console.error(\"Error installing extension\", err);\n                d.resolve({\n                    name: _getExtensionName(config.nameHint),\n                    installationStatus: Package.InstallationStatuses.FAILED,\n                    errors: [\"Error installing extension\"]\n                });\n            });\n        return d.promise();\n    }\n\n    function _markForDeleteOnRestart(extensionDirectory) {\n        let file = FileSystem.getFileForPath(\n            path.join(extensionDirectory.fullPath, ExtensionLoader._DELETED_EXTENSION_FILE_MARKER));\n        return jsPromise(FileUtils.writeText(file, \"This extension is marked for delete on restart of phcode\", true));\n    }\n\n    /**\n     * Removes the extension at the given path.\n     *\n     * @param {string} extensionPath The absolute path to the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed, or\n     *     rejected if there was an error.\n     */\n    function remove(extensionPath) {\n        const d = new $.Deferred();\n        const extensionDirectory = FileSystem.getDirectoryForPath(extensionPath);\n        extensionDirectory.unlink(err=>{\n            if(err && err !== FileSystemError.NOT_FOUND){ // && err !== enoent\n                // if we cant delete the extension, we will try to mark the extension to be removed on restart.\n                // This can happen in windows with node extensions where nodejs holds fs locks on the node folder.\n                _markForDeleteOnRestart(extensionDirectory)\n                    .then(d.resolve)\n                    .catch(d.reject);\n                return;\n            }\n            d.resolve();\n        });\n        return d.promise();\n    }\n\n    exports.downloadFile = downloadFile;\n    exports.abortDownload = abortDownload;\n    exports.install = install;\n    exports.remove = remove;\n    exports.update = install;\n    exports.EVENT_DOWNLOAD_FILE_PROGRESS = EVENT_DOWNLOAD_FILE_PROGRESS;\n    exports.EVENT_EXTRACT_FILE_PROGRESS = EVENT_EXTRACT_FILE_PROGRESS;\n});\n"],"file":"ExtensionDownloader.js"}
{"version":3,"sources":["language/CSSUtils.js"],"names":["define","require","exports","module","CodeMirror","Async","DocumentManager","AppInit","EditorManager","HTMLUtils","LanguageManager","ProjectManager","TokenUtils","IndexingWorker","_","MAX_CONTENT_LENGTH","SELECTOR","PROP_NAME","PROP_VALUE","IMPORT_URL","_bracketPairs","{","[","(","_invertedBracketPairs","invert","isCSSPreprocessorFile","filePath","languageId","getLanguageForPath","getId","_hasNonWhitespace","text","test","_getContextState","ctx","token","state","localState","htmlState","context","html","_isInPropName","lastToken","type","_isInPropValue","isInsideParens","prev","_isInAtRule","createInfo","offset","name","index","values","isNewItem","range","ruleInfo","_getPropNameInfo","propName","offsetInToken","tokenString","string","excludedCharacters","movePrevToken","indexOf","length","moveNextToken","testPos","ch","pos","line","testToken","editor","getTokenAt","_getPropNameStartingFromPropValue","ctxClone","$","extend","moveSkippingWhitespace","_getPrecedingPropValues","lastValue","curValue","propValues","match","push","reverse","_getSucceedingPropValues","currentValue","trim","_getRangeForPropValue","startCtx","endCtx","start","end","clone","_getRuleInfoStartingFromPropValue","editorParam","_codeMirror","contextDoc","document","doc","propNamePos","backwardPos","forwardPos","propNameCtx","getInitialContext","backwardCtx","forwardCtx","canAddNewOne","substr","getLine","concat","_getImportUrlInfo","getInfoAtPos","constPos","mode","getModeForSelection","localMode","tagInfo","getTagInfo","position","_contextCM","value","attr","replace","getCompleteSelectors","info","useGroup","parentSelectors","completeSelectors","selectorGroup","selector","extractAllSelectors","documentMode","lines","lineCount","style","stream","selectors","getMode","indentUnit","currentSelector","currentLevel","ruleStartChar","ruleStartLine","selectorStartChar","selectorStartLine","selectorGroupStartLine","selectorGroupStartChar","declListStartLine","declListStartChar","escapePattern","RegExp","validationPattern","_parseRuleList","_hasStream","eol","StringStream","_firstToken","startState","splitLines","current","_nextToken","_firstTokenSkippingWhitespace","_nextTokenSkippingWhitespace","_isStartComment","_parseComment","_nextTokenSkippingComments","_skipToClosingBracket","startChar","skippedText","unmatchedBraces","_maybeProperty","_skipProperty","prevToken","_getParentSelectors","j","declListEndLine","level","_parseSelector","escapedToken","unicodeChar","parseInt","String","fromCharCode","selectorStart","selectorEndLine","selectorEndChar","_parseSelectorList","_parseDeclarationList","sgLine","Math","min","endChar","substring","nested","undefined","declListEndChar","includeCommentInNextRule","_isStartAtRule","_followedByPseudoSelector","_isVariableInterpolatedProperty","_parseAtRule","_parseRule","escapeToken","_stripAtRules","_getSelectorInFinalCSSForm","selectorArray","finalSelectorArray","parentSelectorArray","group","forEach","split","cs","ampersandIndex","ps","join","_findAllMatchingSelectorsInText","allSelectors","result","classOrIdSelector","re","entry","actualSelector","search","_addSelectorsToResults","resultSelectors","selectorsToAdd","sourceDoc","lineOffset","selectorInfo","lineStart","lineEnd","_findMatchingRulesInCSSFiles","Deferred","_loadFileAndScan","fullPath","oneFileResult","getDocumentForPath","done","oneCSSFileMatches","getText","getLanguage","resolve","fail","error","console","warn","promise","getAllFiles","getLanguageFilter","cssFiles","doInParallel","fileInfo","number","then","reject","_findMatchingRulesInStyleBlocks","htmlDocument","htmlEditor","getCurrentFullEditor","styleBlocks","findStyleBlocks","styleBlockInfo","oneStyleBlockMatches","findMatchingRules","findSelectorAtDocumentPos","cm","foundChars","isPreprocessorDoc","file","_skipToOpeningBracket","eotIndex","skipPrevSibling","unshift","isAtStart","_removeComments","content","_removeStrings","s","reduceStyleSheetForRegExParsing","addRuleToDocument","useTabChar","newRule","blankLineOffset","i","docLines","lastDocLine","lastDocChar","replaceRange","from","to","consolidateRules","rules","newRules","lastRule","rule","getRangeSelectors","startIndex","endIndex","startLine","endLine","_extractSelectorSet","selectorList","regex","Set","item","extracted","extractSelectorBase","add","CSSSelectorCache","Phoenix","libs","LRUCache","maxSize","sizeCalculation","_projectFileChanged","_evt","changedPath","isFile","delete","isDirectory","VFS","ensureTrailingSlash","cachedFilePaths","Array","keys","startsWith","CSS_MODE_MAP","css","less","scss","_loadFileAndScanCSSSelectorCached","Promise","cachedSelectors","get","JSON","parse","langID","log","execPeer","cssMode","set","stringify","catch","err","_htmlLikeFileExts","_isHtmlLike","cacheInProgress","fetchBlock10Secs","max","ttl","async","_precacheExternalStyleSheet","link","has","extension","path","extname","URL","pathname","slice","responseHead","fetch","method","contentLength","headers","response","styleSheetText","selectorJson","e","MAX_ALLOWED_EXTERNAL_STYLE_SHEETS","_getLinkedCSSFileSelectors","htmlFileContent","fileMode","linkedFiles","catchToNull","htmlMode","externalStyleSheetCount","cachedSelectorsArray","_getAllSelectorsInCurrentHTMLEditor","cssText","selectorsPromise","htmlLanguageID","remoteLinkedSelectors","toUpperCase","globalPrecacheRun","getAllCssSelectorsInProject","options","includeClasses","includeIDs","scanCurrentHtml","promises","map","mergedSets","allSettled","results","status","reason","_populateSelectorCache","currentCacheRun","jsPromise","cssFile","appReady","isSpecRunnerWindow","on","EVENT_PROJECT_FILE_CHANGED","EVENT_PROJECT_OPEN","clear","setTimeout","EVENT_DOCUMENT_CHANGE","event","_changelist"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n/*global jsPromise, catchToNull, path*/\n\n/**\n * Set of utilities for simple parsing of CSS text.\n */\ndefine(function (require, exports, module) {\n\n\n    var CodeMirror          = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        Async               = require(\"utils/Async\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        AppInit             = require(\"utils/AppInit\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        HTMLUtils           = require(\"language/HTMLUtils\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        TokenUtils          = require(\"utils/TokenUtils\"),\n        IndexingWorker      = require(\"worker/IndexingWorker\"),\n        _                   = require(\"thirdparty/lodash\");\n\n    const MAX_CONTENT_LENGTH = 10 * 1024 * 1024; // 10MB\n    // Constants\n    const SELECTOR   = \"selector\",\n        PROP_NAME  = \"prop.name\",\n        PROP_VALUE = \"prop.value\",\n        IMPORT_URL = \"import.url\";\n\n    /**\n     * List of all bracket pairs that is keyed by opening brackets, and the inverted list\n     * that is keyed by closing brackets.\n     * @type {{string: string}}\n     */\n    var _bracketPairs = { \"{\": \"}\",\n            \"[\": \"]\",\n            \"(\": \")\" },\n        _invertedBracketPairs = _.invert(_bracketPairs);\n\n    /**\n     * Determines if the given path is a CSS preprocessor file that CSSUtils supports.\n     * @param {string} filePath Absolute path to the file.\n     * @return {boolean} true if LanguageManager identifies filePath as less or scss language.\n     */\n    function isCSSPreprocessorFile(filePath) {\n        var languageId = LanguageManager.getLanguageForPath(filePath).getId();\n        return (languageId === \"less\" || languageId === \"scss\");\n    }\n\n    /**\n     * @private\n     * Helper function to check whether the given text string has any non whitespace character.\n     * @param {!string} text\n     * @return {boolean} true if text has any non whitespace character\n     */\n    function _hasNonWhitespace(text) {\n        return (/\\S/.test(text));\n    }\n\n    /**\n     * @private\n     * Returns state of a context\n     * @param {{editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}}} ctx\n     * @return {{tokenize:function, state:string, stateArg:string, context:Object}}\n     */\n    function _getContextState(ctx) {\n        if (!ctx || !ctx.token) {\n            return null;\n        }\n        var state = ctx.token.state.localState || ctx.token.state;\n        // if state contains a valid html inner state use that first\n        if (state.htmlState) {\n            state = ctx.token.state.htmlState;\n        } else {\n            if (!state.context && ctx.token.state.html && ctx.token.state.html.localState) {\n                state = ctx.token.state.html.localState;\n            }\n        }\n        return state;\n    }\n\n    /**\n     * @private\n     * Checks if the current cursor position is inside the property name context\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return {boolean} true if the context is in property name\n     */\n    function _isInPropName(ctx) {\n        var state = _getContextState(ctx),\n            lastToken;\n        if (!state || !state.context || ctx.token.type === \"comment\") {\n            return false;\n        }\n\n        lastToken = state.context.type;\n        return (lastToken === \"{\" || lastToken === \"rule\" || lastToken === \"block\");\n    }\n\n    /**\n     * @private\n     * Checks if the current cursor position is inside the property value context\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return {boolean} true if the context is in property value\n     */\n    function _isInPropValue(ctx) {\n\n        function isInsideParens(context) {\n            if (context.type !== \"parens\" || !context.prev) {\n                return false;\n            }\n\n            if (context.prev.type === \"prop\") {\n                return true;\n            }\n\n            return isInsideParens(context.prev);\n        }\n\n        var state = _getContextState(ctx);\n        if (!state || !state.context || !state.context.prev || ctx.token.type === \"comment\") {\n            return false;\n        }\n\n        return ((state.context.type === \"prop\" &&\n                    (state.context.prev.type === \"rule\" || state.context.prev.type === \"block\")) ||\n                    isInsideParens(state.context));\n    }\n\n    /**\n     * @private\n     * Checks if the current cursor position is inside an at-rule\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return {boolean} true if the context is in property value\n     */\n    function _isInAtRule(ctx) {\n        var state = _getContextState(ctx);\n        if (!state || !state.context) {\n            return false;\n        }\n        return (state.context.type === \"atBlock_parens\");\n    }\n\n    /**\n     * @private\n     * Creates a context info object\n     * @param {string=} context A constant string\n     * @param {number=} offset The offset of the token for a given cursor position\n     * @param {string=} name Property name of the context\n     * @param {number=} index The index of the property value for a given cursor position\n     * @param {Array.<string>=} values An array of property values\n     * @param {boolean=} isNewItem If this is true, then the value in index refers to the index at which a new item\n     *     is going to be inserted and should not be used for accessing an existing value in values array.\n     * @param {{start: {line: number, ch: number},\n     *          end: {line: number, ch: number}}=} range A range object with a start position and an end position\n     * @return {{context: string,\n     *           offset: number,\n     *           name: string,\n     *           index: number,\n     *           values: Array.<string>,\n     *           isNewItem: boolean,\n     *           range: {start: {line: number, ch: number},\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\n     */\n    function createInfo(context, offset, name, index, values, isNewItem, range) {\n        var ruleInfo = { context: context || \"\",\n            offset: offset || 0,\n            name: name || \"\",\n            index: -1,\n            values: [],\n            isNewItem: (isNewItem === true),\n            range: range };\n\n        if (context === PROP_VALUE || context === SELECTOR || context === IMPORT_URL) {\n            ruleInfo.index = index;\n            ruleInfo.values = values;\n        }\n\n        return ruleInfo;\n    }\n\n    /**\n     * @private\n     * Scan backwards to check for any prefix if the current context is property name.\n     * If the current context is in a prefix (either 'meta' or '-'), then scan forwards\n     * to collect the entire property name. Return the name of the property in the CSS\n     * context info object if there is one that seems to be valid. Return an empty context\n     * info when we find an invalid one.\n     *\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} ctx  context\n     * @return {{context: string,\n     *           offset: number,\n     *           name: string,\n     *           index: number,\n     *           values: Array.<string>,\n     *           isNewItem: boolean,\n     *           range: {start: {line: number, ch: number},\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\n     */\n    function _getPropNameInfo(ctx) {\n        var propName = \"\",\n            offset = TokenUtils.offsetInToken(ctx),\n            tokenString = ctx.token.string,\n            excludedCharacters = [\";\", \"{\", \"}\"];\n\n        if (ctx.token.type === \"property\" || ctx.token.type === \"property error\" ||\n                ctx.token.type === \"tag\") {\n            propName = tokenString;\n            if (TokenUtils.movePrevToken(ctx) && _hasNonWhitespace(ctx.token.string) &&\n                    excludedCharacters.indexOf(ctx.token.string) === -1) {\n                propName = ctx.token.string + tokenString;\n                offset += ctx.token.string.length;\n            }\n        } else if (ctx.token.type === \"meta\" || tokenString === \"-\") {\n            propName = tokenString;\n            if (TokenUtils.moveNextToken(ctx) &&\n                    (ctx.token.type === \"property\" || ctx.token.type === \"property error\" ||\n                    ctx.token.type === \"tag\")) {\n                propName += ctx.token.string;\n            }\n        } else if (_hasNonWhitespace(tokenString) && excludedCharacters.indexOf(tokenString) === -1) {\n            // We're not inside the property name context.\n            return createInfo();\n        } else {\n            var testPos = {ch: ctx.pos.ch + 1, line: ctx.pos.line},\n                testToken = ctx.editor.getTokenAt(testPos, true);\n\n            if (testToken.type === \"property\" || testToken.type === \"property error\" ||\n                    testToken.type === \"tag\") {\n                propName = testToken.string;\n                offset = 0;\n            } else if (testToken.type === \"meta\" || testToken.string === \"-\") {\n                ctx.pos = testPos;\n                ctx.token = testToken;\n                return _getPropNameInfo(ctx);\n            }\n        }\n\n        // If we're in the property name context but not in an existing property name,\n        // then reset offset to zero.\n        if (propName === \"\") {\n            offset = 0;\n        }\n\n        return createInfo(PROP_NAME, offset, propName);\n    }\n\n    /**\n     * @private\n     * Scans backwards from the current context and returns the name of the property if there is\n     * a valid one.\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return {string} the property name of the current rule.\n     */\n    function _getPropNameStartingFromPropValue(ctx) {\n        var ctxClone = $.extend({}, ctx),\n            propName = \"\";\n        do {\n            // If we're no longer in the property value before seeing a colon, then we don't\n            // have a valid property name. Just return an empty string.\n            if (ctxClone.token.string !== \":\" && !_isInPropValue(ctxClone)) {\n                return \"\";\n            }\n        } while (ctxClone.token.string !== \":\" && TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctxClone));\n\n        if (ctxClone.token.string === \":\" && TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctxClone) &&\n                (ctxClone.token.type === \"property\" || ctxClone.token.type === \"property error\")) {\n            propName = ctxClone.token.string;\n            if (TokenUtils.movePrevToken(ctxClone) && ctxClone.token.type === \"meta\") {\n                propName = ctxClone.token.string + propName;\n            }\n        }\n\n        return propName;\n    }\n\n    /**\n     * @private\n     * Gets all of the space/comma seperated tokens before the the current cursor position.\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return {?Array.<string>} An array of all the space/comma seperated tokens before the\n     *    current cursor position\n     */\n    function _getPrecedingPropValues(ctx) {\n        var lastValue = \"\",\n            curValue,\n            propValues = [];\n        while (ctx.token.string !== \":\" && TokenUtils.movePrevToken(ctx)) {\n            if (ctx.token.string === \":\" || !_isInPropValue(ctx)) {\n                break;\n            }\n\n            curValue = ctx.token.string;\n            if (lastValue !== \"\") {\n                curValue += lastValue;\n            }\n\n            if ((ctx.token.string.length > 0 && !ctx.token.string.match(/\\S/)) ||\n                    ctx.token.string === \",\") {\n                lastValue = curValue;\n            } else {\n                lastValue = \"\";\n                if (propValues.length === 0 || curValue.match(/,\\s*$/)) {\n                    // stack is empty, or current value ends with a comma\n                    // (and optional whitespace), so push it on the stack\n                    propValues.push(curValue);\n                } else {\n                    // current value does not end with a comma (and optional ws) so prepend\n                    // to last stack item (e.g. \"rgba(50\" get broken into 2 tokens)\n                    propValues[propValues.length - 1] = curValue + propValues[propValues.length - 1];\n                }\n            }\n        }\n        if (propValues.length > 0) {\n            propValues.reverse();\n        }\n\n        return propValues;\n    }\n\n    /**\n     * @private\n     * Gets all of the space/comma seperated tokens after the the current cursor position.\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @param {string} currentValue The token string at the current cursor position\n     * @return {?Array.<string>} An array of all the space/comma seperated tokens after the\n     *    current cursor position\n     */\n    function _getSucceedingPropValues(ctx, currentValue) {\n        var lastValue = currentValue,\n            propValues = [];\n\n        while (ctx.token.string !== \";\" && ctx.token.string !== \"}\" && TokenUtils.moveNextToken(ctx)) {\n            if (ctx.token.string === \";\" || ctx.token.string === \"}\") {\n                break;\n            }\n            if (!_isInPropValue(ctx)) {\n                lastValue = \"\";\n                break;\n            }\n\n            if (lastValue === \"\") {\n                lastValue = ctx.token.string.trim();\n            } else if (lastValue.length > 0) {\n                if (ctx.token.string.length > 0 && !ctx.token.string.match(/\\S/)) {\n                    lastValue += ctx.token.string;\n                    propValues.push(lastValue);\n                    lastValue = \"\";\n                } else if (ctx.token.string === \",\") {\n                    lastValue += ctx.token.string;\n                } else if (lastValue && lastValue.match(/,$/)) {\n                    propValues.push(lastValue);\n                    if (ctx.token.string.length > 0) {\n                        lastValue = ctx.token.string;\n                    } else {\n                        lastValue = \"\";\n                    }\n                } else {\n                    // e.g. \"rgba(50\" gets broken into 2 tokens\n                    lastValue += ctx.token.string;\n                }\n            }\n        }\n        if (lastValue.length > 0) {\n            propValues.push(lastValue);\n        }\n\n        return propValues;\n    }\n\n    /**\n     * @private\n     * Return a range object with a start position and an end position after\n     * skipping any whitespaces and all separators used before and after a\n     * valid property value.\n     *\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} startCtx context\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} endCtx context\n     * @return {{start: {line: number, ch: number},\n     *           end: {line: number, ch: number}}} A range object.\n     */\n    function _getRangeForPropValue(startCtx, endCtx) {\n        var range = { \"start\": {},\n            \"end\": {} };\n\n        // Skip the \":\" and any leading whitespace\n        while (TokenUtils.moveNextToken(startCtx)) {\n            if (_hasNonWhitespace(startCtx.token.string)) {\n                break;\n            }\n        }\n\n        // Skip the trailing whitespace and property separators.\n        while (endCtx.token.string === \";\" || endCtx.token.string === \"}\" ||\n                !_hasNonWhitespace(endCtx.token.string)) {\n            TokenUtils.movePrevToken(endCtx);\n        }\n\n        range.start = _.clone(startCtx.pos);\n        range.start.ch = startCtx.token.start;\n\n        range.end = _.clone(endCtx.pos);\n        range.end.ch = endCtx.token.end;\n\n        return range;\n    }\n\n    /**\n     * @private\n     * Returns a context info object for the current CSS style rule\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @param {!Editor} editor\n     * @return {{context: string,\n     *           offset: number,\n     *           name: string,\n     *           index: number,\n     *           values: Array.<string>,\n     *           isNewItem: boolean,\n     *           range: {start: {line: number, ch: number},\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\n     */\n    function _getRuleInfoStartingFromPropValue(ctx, editorParam) {\n        var editor      = editorParam._codeMirror || editorParam,\n            contextDoc  = editor.document || editor.doc,\n            propNamePos = $.extend({}, ctx.pos),\n            backwardPos = $.extend({}, ctx.pos),\n            forwardPos  = $.extend({}, ctx.pos),\n            propNameCtx = TokenUtils.getInitialContext(editor, propNamePos),\n            backwardCtx,\n            forwardCtx,\n            lastValue = \"\",\n            propValues = [],\n            index = -1,\n            offset = TokenUtils.offsetInToken(ctx),\n            canAddNewOne = false,\n            testPos = {ch: ctx.pos.ch + 1, line: ctx.pos.line},\n            testToken = editor.getTokenAt(testPos, true),\n            propName,\n            range;\n\n        // Get property name first. If we don't have a valid property name, then\n        // return a default rule info.\n        propName = _getPropNameStartingFromPropValue(propNameCtx);\n        if (!propName) {\n            return createInfo();\n        }\n\n        // Scan backward to collect all preceding property values\n        backwardCtx = TokenUtils.getInitialContext(editor, backwardPos);\n        propValues = _getPrecedingPropValues(backwardCtx);\n\n        lastValue = \"\";\n        if (ctx.token.string === \":\") {\n            index = 0;\n            canAddNewOne = true;\n        } else {\n            index = propValues.length - 1;\n            if (ctx.token.string === \",\") {\n                propValues[index] += ctx.token.string;\n                index++;\n                canAddNewOne = true;\n            } else {\n                index = (index < 0) ? 0 : index + 1;\n                if (ctx.token.string.match(/\\S/)) {\n                    lastValue = ctx.token.string;\n                } else {\n                    // Last token is all whitespace\n                    canAddNewOne = true;\n                    if (index > 0) {\n                        // Append all spaces before the cursor to the previous value in values array\n                        propValues[index - 1] += ctx.token.string.substr(0, offset);\n                    }\n                }\n            }\n        }\n\n        if (canAddNewOne) {\n            offset = 0;\n\n            // If pos is at EOL, then there's implied whitespace (newline).\n            if (contextDoc.getLine(ctx.pos.line).length > ctx.pos.ch  &&\n                    (testToken.string.length === 0 || testToken.string.match(/\\S/))) {\n                canAddNewOne = false;\n            }\n        }\n\n        // Scan forward to collect all succeeding property values and append to all propValues.\n        forwardCtx = TokenUtils.getInitialContext(editor, forwardPos);\n        propValues = propValues.concat(_getSucceedingPropValues(forwardCtx, lastValue));\n\n        if (propValues.length) {\n            range = _getRangeForPropValue(backwardCtx, forwardCtx);\n        } else {\n            // No property value, so just return the cursor pos as range\n            range = { \"start\": _.clone(ctx.pos),\n                \"end\": _.clone(ctx.pos) };\n        }\n\n        // If current index is more than the propValues size, then the cursor is\n        // at the end of the existing property values and is ready for adding another one.\n        if (index === propValues.length) {\n            canAddNewOne = true;\n        }\n\n        return createInfo(PROP_VALUE, offset, propName, index, propValues, canAddNewOne, range);\n    }\n\n    /**\n     * @private\n     * Returns a context info object for the current CSS import rule\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @param {!Editor} editor\n     * @return {{context: string,\n     *           offset: number,\n     *           name: string,\n     *           index: number,\n     *           values: Array.<string>,\n     *           isNewItem: boolean,\n     *           range: {start: {line: number, ch: number},\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\n     */\n    function _getImportUrlInfo(ctx, editor) {\n        var backwardPos = $.extend({}, ctx.pos),\n            forwardPos  = $.extend({}, ctx.pos),\n            backwardCtx,\n            forwardCtx,\n            index = 0,\n            propValues = [],\n            offset = TokenUtils.offsetInToken(ctx);\n\n        // Currently only support url. May be null if starting to type\n        if (ctx.token.type && ctx.token.type !== \"string\") {\n            return createInfo();\n        }\n\n        // Move backward to @import and collect data as we go. We return propValues\n        // array, but we can only have 1 value, so put all data in first item\n        backwardCtx = TokenUtils.getInitialContext(editor._codeMirror, backwardPos);\n        propValues[0] = backwardCtx.token.string;\n\n        while (TokenUtils.movePrevToken(backwardCtx)) {\n            if (backwardCtx.token.type === \"def\" && backwardCtx.token.string === \"@import\") {\n                break;\n            }\n\n            if (backwardCtx.token.type && backwardCtx.token.type !== \"atom\" && backwardCtx.token.string !== \"url\") {\n                // Previous token may be white-space\n                // Otherwise, previous token may only be \"url(\"\n                break;\n            }\n\n            propValues[0] = backwardCtx.token.string + propValues[0];\n            offset += backwardCtx.token.string.length;\n        }\n\n        if (backwardCtx.token.type !== \"def\" || backwardCtx.token.string !== \"@import\") {\n            // Not in url\n            return createInfo();\n        }\n\n        // Get value after cursor up until closing paren or newline\n        forwardCtx = TokenUtils.getInitialContext(editor._codeMirror, forwardPos);\n        do {\n            if (!TokenUtils.moveNextToken(forwardCtx)) {\n                if (forwardCtx.token.string === \"(\") {\n                    break;\n                } else {\n                    return createInfo();\n                }\n            }\n            propValues[0] += forwardCtx.token.string;\n        } while (forwardCtx.token.string !== \")\" && forwardCtx.token.string !== \"\");\n\n        return createInfo(IMPORT_URL, offset, \"\", index, propValues, false);\n    }\n\n    /**\n     * Returns a context info object for the given cursor position\n     * @param {!Editor} editor\n     * @param {{ch: number, line: number}} constPos  A CM pos (likely from editor.getCursorPos())\n     * @return {{context: string,\n     *           offset: number,\n     *           name: string,\n     *           index: number,\n     *           values: Array.<string>,\n     *           isNewItem: boolean,\n     *           range: {start: {line: number, ch: number},\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\n     */\n    function getInfoAtPos(editor, constPos) {\n        // We're going to be changing pos a lot, but we don't want to mess up\n        // the pos the caller passed in so we use extend to make a safe copy of it.\n        var pos = $.extend({}, constPos),\n            ctx = TokenUtils.getInitialContext(editor._codeMirror, pos),\n            mode = editor.getModeForSelection();\n\n        // Check if this is inside a style block or in a css/less document.\n        if (mode !== \"css\" && mode !== \"text/x-scss\" && mode !== \"text/x-less\") {\n            return createInfo();\n        }\n\n        // Context from the current editor will have htmlState if we are in css mode\n        // and in attribute value state of a tag with attribute name style\n        if (ctx.token.state.htmlState && (!ctx.token.state.localMode || ctx.token.state.localMode.name !== \"css\")) {\n\n            // tagInfo is required to aquire the style attr value\n            var tagInfo = HTMLUtils.getTagInfo(editor, pos, true),\n                // To be used as relative character position\n                offset = tagInfo.position.offset;\n\n            /**\n             * We will use this CM to cook css context in case of style attribute value\n             * as CM in htmlmixed mode doesn't yet identify this as css context. We provide\n             * a no-op display function to run CM without a DOM head.\n             */\n            var _contextCM = new CodeMirror(function () {}, {\n                value: \"{\" + tagInfo.attr.value.replace(/(^\")|(\"$)/g, \"\"),\n                mode: \"css\"\n            });\n\n            ctx = TokenUtils.getInitialContext(_contextCM, {line: 0, ch: offset + 1});\n        }\n\n        if (_isInPropName(ctx)) {\n            return _getPropNameInfo(ctx);\n        }\n\n        if (_isInPropValue(ctx)) {\n            return _getRuleInfoStartingFromPropValue(ctx, ctx.editor);\n        }\n\n        if (_isInAtRule(ctx)) {\n            return _getImportUrlInfo(ctx, editor);\n        }\n\n        return createInfo();\n    }\n\n    /**\n     * Return a string that shows the literal parent hierarchy of the selector\n     * in info.\n     *\n     * @param {!SelectorInfo} info\n     * @param {boolean=} useGroup true to append selectorGroup instead of selector\n     * @return {string} the literal parent hierarchy of the selector\n     */\n    function getCompleteSelectors(info, useGroup) {\n        if (info.parentSelectors) {\n            // Show parents with / separators.\n            var completeSelectors = info.parentSelectors + \" / \";\n            if (useGroup && info.selectorGroup) {\n                completeSelectors += info.selectorGroup;\n            } else {\n                completeSelectors += info.selector;\n            }\n            return completeSelectors;\n        } else if (useGroup && info.selectorGroup) {\n            return info.selectorGroup;\n        }\n\n        return info.selector;\n    }\n\n    /**\n     * @typedef {{selector: !string,\n     *            ruleStartLine: number,\n     *            ruleStartChar: number,\n     *            selectorStartLine: number,\n     *            selectorStartChar: number,\n     *            selectorEndLine: number,\n     *            selectorEndChar: number,\n     *            selectorGroupStartLine: number,\n     *            selectorGroupStartChar: number,\n     *            selectorGroup: ?string,\n     *            declListStartLine: number,\n     *            declListStartChar: number,\n     *            declListEndLine: number,\n     *            declListEndChar: number,\n     *            level: number,\n     *            parentSelectors: ?string}} SelectorInfo\n     */\n\n    /**\n     * Extracts all CSS selectors from the given text\n     * Returns an array of SelectorInfo. Each SelectorInfo is an object with the following properties:\n         selector:                 the text of the selector (note: comma separated selector groups like\n                                   \"h1, h2\" are broken into separate selectors)\n         ruleStartLine:            line in the text where the rule (including preceding comment) appears\n         ruleStartChar:            column in the line where the rule (including preceding comment) starts\n         selectorStartLine:        line in the text where the selector appears\n         selectorStartChar:        column in the line where the selector starts\n         selectorEndLine:          line where the selector ends\n         selectorEndChar:          column where the selector ends\n         selectorGroupStartLine:   line where the comma-separated selector group (e.g. .foo, .bar, .baz)\n                                   starts that this selector (e.g. .baz) is part of. Particularly relevant for\n                                   groups that are on multiple lines.\n         selectorGroupStartChar:   column in line where the selector group starts.\n         selectorGroup:            the entire selector group containing this selector, or undefined if there\n                                   is only one selector in the rule.\n         declListStartLine:        line where the declaration list for the rule starts\n         declListStartChar:        column in line where the declaration list for the rule starts\n         declListEndLine:          line where the declaration list for the rule ends\n         declListEndChar:          column in the line where the declaration list for the rule ends\n         level:                    the level of the current selector including any containing @media block in the\n                                   nesting level count. Use this property with caution since it is primarily for internal\n                                   parsing use. For example, two sibling selectors may have different levels if one\n                                   of them is nested inside an @media block and it should not be used for sibling info.\n         parentSelectors:          all ancestor selectors separated with '/' if the current selector is a nested one\n     * @param {!string} text CSS text to extract from\n     * @param {?string} documentMode language mode of the document that text belongs to, default to css if undefined.\n     * @return {Array.<SelectorInfo>} Array with objects specifying selectors.\n     */\n    function extractAllSelectors(text, documentMode) {\n        var state, lines, lineCount,\n            token, style, stream, line,\n            selectors              = [],\n            mode                   = CodeMirror.getMode({indentUnit: 2}, documentMode || \"css\"),\n            currentSelector        = \"\",\n            currentLevel           = 0,\n            ruleStartChar          = -1,\n            ruleStartLine          = -1,\n            selectorStartChar      = -1,\n            selectorStartLine      = -1,\n            selectorGroupStartLine = -1,\n            selectorGroupStartChar = -1,\n            declListStartLine      = -1,\n            declListStartChar      = -1,\n            escapePattern          = new RegExp(\"\\\\\\\\[^\\\\\\\\]+\", \"g\"),\n            validationPattern      = new RegExp(\"\\\\\\\\([a-f0-9]{6}|[a-f0-9]{4}(\\\\s|\\\\\\\\|$)|[a-f0-9]{2}(\\\\s|\\\\\\\\|$)|.)\", \"i\"),\n            _parseRuleList;\n\n        // implement _firstToken()/_nextToken() methods to\n        // provide a single stream of tokens\n\n        function _hasStream() {\n            while (stream.eol()) {\n                line++;\n                if (line >= lineCount) {\n                    return false;\n                }\n                if (_hasNonWhitespace(currentSelector)) {\n                    // If we are in a current selector and starting a newline,\n                    // make sure there is whitespace in the selector\n                    currentSelector += \" \";\n                }\n                stream = new CodeMirror.StringStream(lines[line]);\n            }\n            return true;\n        }\n\n        function _firstToken() {\n            state = CodeMirror.startState(mode);\n            lines = CodeMirror.splitLines(text);\n            lineCount = lines.length;\n            if (lineCount === 0) {\n                return false;\n            }\n            line = 0;\n            stream = new CodeMirror.StringStream(lines[line]);\n            if (!_hasStream()) {\n                return false;\n            }\n            style = mode.token(stream, state);\n            token = stream.current();\n            return true;\n        }\n\n        function _nextToken() {\n            // advance the stream past this token\n            stream.start = stream.pos;\n            if (!_hasStream()) {\n                return false;\n            }\n            style = mode.token(stream, state);\n            token = stream.current();\n            return true;\n        }\n\n        function _firstTokenSkippingWhitespace() {\n            if (!_firstToken()) {\n                return false;\n            }\n            while (!_hasNonWhitespace(token)) {\n                if (!_nextToken()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function _nextTokenSkippingWhitespace() {\n            if (!_nextToken()) {\n                return false;\n            }\n            while (!_hasNonWhitespace(token)) {\n                if (!_nextToken()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function _isStartComment() {\n            // Also check for line comments used in LESS and SASS.\n            return (/^\\/[\\/\\*]/.test(token));\n        }\n\n        function _parseComment() {\n            // If it is a line comment, then do nothing and just return. Unlike block\n            // comment, a line comment is just one single token and the caller always\n            // has to find the next token by skipping the current token. So leaving\n            // it for the caller to skip the current token.\n            if (/^\\/\\//.test(token)) {\n                return;\n            }\n            while (!/\\*\\/$/.test(token)) {\n                if (!_nextToken()) {\n                    break;\n                }\n            }\n        }\n\n        function _nextTokenSkippingComments() {\n            if (!_nextToken()) {\n                return false;\n            }\n            while (_isStartComment()) {\n                _parseComment();\n                if (!_nextToken()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function _skipToClosingBracket(startChar) {\n            var skippedText = \"\",\n                unmatchedBraces = 0;\n            if (!startChar) {\n                startChar = \"{\";\n            }\n            while (true) {\n                if (token.indexOf(startChar) !== -1 && token.indexOf(_bracketPairs[startChar]) === -1) {\n                    // Found an opening bracket but not the matching closing bracket in the same token\n                    unmatchedBraces++;\n                } else if (token === _bracketPairs[startChar]) {\n                    unmatchedBraces--;\n                    if (unmatchedBraces <= 0) {\n                        skippedText += token;\n                        return skippedText;\n                    }\n                }\n                skippedText += token;\n\n                if (!_nextTokenSkippingComments()) {\n                    return skippedText; // eof\n                }\n            }\n        }\n\n        function _maybeProperty() {\n            return (/^-(moz|ms|o|webkit)-$/.test(token) ||\n                    (state.state !== \"top\" && state.state !== \"block\" && state.state !== \"pseudo\" &&\n                    // Has a semicolon as in \"rgb(0,0,0);\", but not one of those after a LESS\n                    // mixin parameter variable as in \".size(@width; @height)\"\n                    stream.string.indexOf(\";\") !== -1 && !/\\([^)]+;/.test(stream.string)));\n        }\n\n        function _skipProperty() {\n            var prevToken = \"\";\n            while (token !== \";\") {\n                // Skip tokens until the closing brace if we find an interpolated variable.\n                if (/[#@]\\{$/.test(token) || (token === \"{\" && /[#@]$/.test(prevToken))) {\n                    _skipToClosingBracket(\"{\");\n                    if (token === \"}\") {\n                        _nextToken();   // Skip the closing brace\n                    }\n                    if (token === \";\") {\n                        break;\n                    }\n                }\n                // If there is a '{' or '}' before the ';',\n                // then stop skipping.\n                if (token === \"{\" || token === \"}\") {\n                    return false;   // can't tell if the entire property is skipped\n                }\n                prevToken = token;\n                if (!_nextTokenSkippingComments()) {\n                    break;\n                }\n            }\n            return true;    // skip the entire property\n        }\n\n        function _getParentSelectors() {\n            var j;\n            for (j = selectors.length - 1; j >= 0; j--) {\n                if (selectors[j].declListEndLine === -1 && selectors[j].level < currentLevel) {\n                    return getCompleteSelectors(selectors[j], true);\n                }\n            }\n            return \"\";\n        }\n\n        function _parseSelector(start, level) {\n\n            currentSelector = \"\";\n            selectorStartChar = start;\n            selectorStartLine = line;\n\n            // Everything until the next ',' or '{' is part of the current selector\n            while ((token !== \",\" && token !== \"{\") ||\n                    (token === \"{\" && /[#@]$/.test(currentSelector)) ||\n                    (token === \",\" && !_hasNonWhitespace(currentSelector))) {\n                if (token === \"{\") {\n                    // Append the interpolated variable to selector\n                    currentSelector += _skipToClosingBracket(\"{\");\n                    _nextToken();  // skip the closing brace\n                } else if (token === \"}\" &&\n                        (!currentSelector || /:\\s*\\S/.test(currentSelector) || !/[#@]\\{.+/.test(currentSelector))) {\n                    // Either empty currentSelector or currentSelector is a CSS property\n                    // but not a selector that is in the form of #{$class} or @{class}\n                    return false;\n                }\n                // Clear currentSelector if we're in a property, but make sure we don't treat\n                // the semicolors inside a parameter as a property separators.\n                if ((token === \";\" && state.state !== \"parens\") ||\n                        // Make sure that something like `> li > a {` is not identified as a property\n                        (state.state === \"prop\" && !/\\{/.test(stream.string))) {\n                    currentSelector = \"\";\n                } else if (token === \"(\") {\n                    // Collect everything inside the parentheses as a whole chunk so that\n                    // commas inside the parentheses won't be identified as selector separators\n                    // by while loop.\n                    if (_hasNonWhitespace(currentSelector)) {\n                        currentSelector += _skipToClosingBracket(\"(\");\n                    } else {\n                        // Nothing in currentSelector yet. Skip to the closing parenthesis\n                        // without collecting the selector since a selector cannot start with\n                        // an opening parenthesis.\n                        _skipToClosingBracket(\"(\");\n                    }\n                } else if (_hasNonWhitespace(token) || _hasNonWhitespace(currentSelector)) {\n                    currentSelector += token;\n                }\n                if (!_nextTokenSkippingComments()) {\n                    return false; // eof\n                }\n            }\n\n            if (!currentSelector) {\n                return false;\n            }\n\n            // Unicode character replacement as defined in http://www.w3.org/TR/CSS21/syndata.html#characters\n            if (/\\\\/.test(currentSelector)) {\n                // Double replace in case of pattern overlapping (regex improvement?)\n                currentSelector = currentSelector.replace(escapePattern, function (escapedToken) {\n                    return escapedToken.replace(validationPattern, function (unicodeChar) {\n                        unicodeChar = unicodeChar.substr(1);\n                        if (unicodeChar.length === 1) {\n                            return unicodeChar;\n                        }\n                        if (parseInt(unicodeChar, 16) < 0x10FFFF) {\n                            return String.fromCharCode(parseInt(unicodeChar, 16));\n                        }  return String.fromCharCode(0xFFFD);\n\n                    });\n                });\n            }\n\n            currentSelector = currentSelector.trim();\n            var startChar = (selectorGroupStartLine === -1) ? selectorStartChar : selectorStartChar + 1;\n            var selectorStart = (stream.string.indexOf(currentSelector, selectorStartChar) !== -1) ? stream.string.indexOf(currentSelector, selectorStartChar - currentSelector.length) : startChar;\n\n            if (currentSelector !== \"\") {\n                if (currentLevel < level) {\n                    currentLevel++;\n                }\n                if (ruleStartLine === -1) {\n                    ruleStartLine = line;\n                    ruleStartChar = stream.start - currentSelector.length;\n                }\n                var parentSelectors = _getParentSelectors();\n                selectors.push({selector: currentSelector,\n                    ruleStartLine: ruleStartLine,\n                    ruleStartChar: ruleStartChar,\n                    selectorStartLine: selectorStartLine,\n                    selectorStartChar: selectorStart,\n                    declListEndLine: -1,\n                    selectorEndLine: line,\n                    selectorEndChar: selectorStart + currentSelector.length,\n                    selectorGroupStartLine: selectorGroupStartLine,\n                    selectorGroupStartChar: selectorGroupStartChar,\n                    level: currentLevel,\n                    parentSelectors: parentSelectors\n                });\n                currentSelector = \"\";\n            }\n            selectorStartChar = -1;\n\n            return true;\n        }\n\n        function _parseSelectorList(level) {\n            selectorGroupStartLine = (stream.string.indexOf(\",\") !== -1) ? line : -1;\n            selectorGroupStartChar = stream.start;\n\n            if (!_parseSelector(stream.start, level)) {\n                return false;\n            }\n\n            while (token === \",\") {\n                if (!_nextTokenSkippingComments()) {\n                    return false; // eof\n                }\n                if (!_parseSelector(stream.start, level)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function _parseDeclarationList(level) {\n\n            var j;\n            declListStartLine = Math.min(line, lineCount - 1);\n            declListStartChar = stream.start;\n\n            // Extract the entire selector group we just saw.\n            var selectorGroup, sgLine;\n            if (selectorGroupStartLine !== -1) {\n                selectorGroup = \"\";\n                for (sgLine = selectorGroupStartLine; sgLine <= declListStartLine; sgLine++) {\n                    var startChar = 0, endChar = lines[sgLine].length;\n                    if (sgLine === selectorGroupStartLine) {\n                        startChar = selectorGroupStartChar;\n                    } else {\n                        selectorGroup += \" \"; // replace the newline with a single space\n                    }\n                    if (sgLine === declListStartLine) {\n                        endChar = declListStartChar;\n                    }\n                    selectorGroup += lines[sgLine].substring(startChar, endChar).trim();\n                }\n                selectorGroup = selectorGroup.trim();\n            }\n\n            // assign this declaration list position and selector group to every selector on the stack\n            // that doesn't have a declaration list start and end line\n            for (j = selectors.length - 1; j >= 0; j--) {\n                if (selectors[j].level === level) {\n                    if (selectors[j].declListEndLine !== -1) {\n                        break;\n                    } else {\n                        selectors[j].declListStartLine = declListStartLine;\n                        selectors[j].declListStartChar = declListStartChar;\n                        if (selectorGroup) {\n                            selectors[j].selectorGroup = selectorGroup;\n                        }\n                    }\n                }\n            }\n\n            var nested = true;\n            do {\n                // Since we're now in a declaration list, that means we also finished\n                // parsing the whole selector group. Therefore, reset selectorGroupStartLine\n                // so that next time we parse a selector we know it's a new group\n                selectorGroupStartLine = -1;\n                selectorGroupStartChar = -1;\n                ruleStartLine = -1;\n                ruleStartChar = -1;\n\n                if (!nested) {\n                    if (currentLevel > 0 && currentLevel === level) {\n                        currentLevel--;\n                        // Skip past '}'\n                        if (token === \"}\") {\n                            _nextTokenSkippingWhitespace();\n                        }\n                    }\n                }\n                // Skip past '{' before parsing nested rule list.\n                if (token === \"{\") {\n                    _nextTokenSkippingWhitespace();\n                }\n                nested = _parseRuleList(undefined, currentLevel + 1);\n\n                // assign this declaration list position to every selector on the stack\n                // that doesn't have a declaration list end line\n                for (j = selectors.length - 1; j >= 0; j--) {\n                    if (selectors[j].level < currentLevel) {\n                        break;\n                    }\n                    if (selectors[j].declListEndLine === -1) {\n                        selectors[j].declListEndLine = line;\n                        selectors[j].declListEndChar = stream.pos - 1; // stream.pos actually points to the char after the }\n                    }\n                }\n            } while (currentLevel > 0 && currentLevel === level);\n        }\n\n        function includeCommentInNextRule() {\n            if (ruleStartChar !== -1) {\n                return false;       // already included\n            }\n            if (stream.start > 0 && lines[line].substr(0, stream.start).indexOf(\"}\") !== -1) {\n                return false;       // on same line as '}', so it's for previous rule\n            }\n            return true;\n        }\n\n        function _isStartAtRule() {\n            // Exclude @mixin from at-rule so that we can parse it like a normal rule list\n            return (/^@/.test(token) && !/^@mixin/i.test(token) && token !== \"@\");\n        }\n\n        function _followedByPseudoSelector() {\n            return (/\\}:(enabled|disabled|checked|indeterminate|link|visited|hover|active|focus|target|lang|root|nth-|first-|last-|only-|empty|not)/.test(stream.string));\n        }\n\n        function _isVariableInterpolatedProperty() {\n            return (/[@#]\\{\\S+\\}(\\s*:|.*;)/.test(stream.string) && !_followedByPseudoSelector());\n        }\n\n        function _parseAtRule(level) {\n\n            // reset these fields to ignore comments preceding @rules\n            ruleStartLine = -1;\n            ruleStartChar = -1;\n            selectorStartLine = -1;\n            selectorStartChar = -1;\n            selectorGroupStartLine = -1;\n            selectorGroupStartChar = -1;\n\n            if (/@media/i.test(token)) {\n                // @media rule holds a rule list\n\n                // Skip everything until the opening '{'\n                while (token !== \"{\") {\n                    if (!_nextTokenSkippingComments()) {\n                        return; // eof\n                    }\n                }\n\n                // skip past '{', to next non-ws token\n                if (!_nextTokenSkippingWhitespace()) {\n                    return; // eof\n                }\n\n                if (currentLevel <= level) {\n                    currentLevel++;\n                }\n\n                // Parse rules until we see '}'\n                // Treat media rule as one nested level by\n                // calling _parseRuleList with next level.\n                _parseRuleList(\"}\", currentLevel + 1);\n\n                if (currentLevel > 0) {\n                    currentLevel--;\n                }\n\n            } else {\n                // This code handles @rules in this format:\n                //   @rule ... ;\n                // Or any less variable that starts with @var ... ;\n                // Skip everything until the next ';'\n                while (token !== \";\") {\n                    // This code handle @rules that use this format:\n                    //    @rule ... { ... }\n                    // such as @page, @keyframes (also -webkit-keyframes, etc.), and @font-face.\n                    // Skip everything including nested braces until the next matching '}'\n                    if (token === \"{\") {\n                        _skipToClosingBracket(\"{\");\n                        return;\n                    }\n                    if (!_nextTokenSkippingComments()) {\n                        return; // eof\n                    }\n                }\n            }\n        }\n\n        // parse a style rule\n        function _parseRule(level) {\n            if (!_parseSelectorList(level)) {\n                return false;\n            }\n\n            _parseDeclarationList(level);\n            return true;\n        }\n\n        _parseRuleList = function (escapeToken, level) {\n            while ((!escapeToken) || token !== escapeToken) {\n                if (_isVariableInterpolatedProperty()) {\n                    if (!_skipProperty()) {\n                        // We found a \"{\" or \"}\" while skipping a property. Return false to handle the\n                        // opening or closing of a block properly.\n                        return false;\n                    }\n                } else if (_isStartAtRule()) {\n                    // @rule\n                    _parseAtRule(level);\n                } else if (_isStartComment()) {\n                    // comment - make this part of style rule\n                    if (includeCommentInNextRule()) {\n                        ruleStartChar = stream.start;\n                        ruleStartLine = line;\n                    }\n                    _parseComment();\n                } else if (_maybeProperty()) {\n                    // Skip the property.\n                    if (!_skipProperty()) {\n                        // We found a \"{\" or \"}\" while skipping a property. Return false to handle the\n                        // opening or closing of a block properly.\n                        return false;\n                    }\n                } else {\n                    // Otherwise, it's style rule\n                    if (!_parseRule(level === undefined ? 0 : level) && level > 0) {\n                        return false;\n                    }\n                    if (level > 0) {\n                        return true;\n                    }\n                    // Clear ruleStartChar and ruleStartLine in case we have a comment\n                    // at the end of previous rule in level 0.\n                    ruleStartChar = -1;\n                    ruleStartLine = -1;\n                }\n\n                if (!_nextTokenSkippingWhitespace()) {\n                    break;\n                }\n            }\n\n            return true;\n        };\n\n        // Do parsing\n\n        if (_firstTokenSkippingWhitespace()) {\n\n            // Style sheet is a rule list\n            _parseRuleList();\n        }\n\n        return selectors;\n    }\n\n    /*\n     * This code can be used to create an \"independent\" HTML document that can be passed to jQuery\n     * calls. Allows using jQuery's CSS selector engine without actually putting anything in the browser's DOM\n     *\n    var _htmlDoctype = document.implementation.createDocumentType('html',\n        '-//W3C//DTD XHTML 1.0 Strict//EN',\n        'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'\n    );\n    var _htmlDocument = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', _htmlDoctype);\n\n    function checkIfSelectorSelectsHTML(selector, theHTML) {\n        $('html', _htmlDocument).html(theHTML);\n        return ($(selector, _htmlDocument).length > 0);\n    }\n    */\n\n    /**\n     * Helper function to remove whitespaces before and after a selector\n     * Returns trimmed selector if it is not an at-rule, or null if it starts with @.\n     *\n     * @param {string} selector\n     * @return {string}\n     */\n    function _stripAtRules(selector) {\n        selector = selector.trim();\n        if (selector.indexOf(\"@\") === 0) {\n            return \"\";\n        }\n        return selector;\n    }\n\n    /**\n     * Converts the given selector array into the actual CSS selectors similar to\n     * those generated by a CSS preprocessor.\n     *\n     * @param {Array.<string>} selectorArray\n     * @return {string}\n     */\n    function _getSelectorInFinalCSSForm(selectorArray) {\n        var finalSelectorArray = [\"\"],\n            parentSelectorArray = [],\n            group = [];\n        _.forEach(selectorArray, function (selector) {\n            selector = _stripAtRules(selector);\n            group = selector.split(\",\");\n            parentSelectorArray = [];\n            _.forEach(group, function (cs) {\n                var ampersandIndex = cs.indexOf(\"&\");\n                _.forEach(finalSelectorArray, function (ps) {\n                    if (ampersandIndex === -1) {\n                        cs = _stripAtRules(cs);\n                        if (ps.length && cs.length) {\n                            ps += \" \";\n                        }\n                        ps += cs;\n                    } else {\n                        // Replace all instances of & with regexp\n                        ps = _stripAtRules(cs.replace(/&/g, ps));\n                    }\n                    parentSelectorArray.push(ps);\n                });\n            });\n            finalSelectorArray = parentSelectorArray;\n        });\n        return finalSelectorArray.join(\", \");\n    }\n\n    /**\n     * Finds all instances of the specified selector in \"text\".\n     * Returns an Array of Objects with start and end properties.\n     *\n     * For now, we only support simple selectors. This function will need to change\n     * dramatically to support full selectors.\n     *\n     * FUTURE: (JRB) It would be nice to eventually use the browser/jquery to do the selector evaluation.\n     * One way to do this would be to take the user's HTML, add a special attribute to every tag with a UID,\n     * and then construct a DOM (using the commented out code above). Then, give this DOM and the selector to\n     * jquery and ask what matches. If the node that the user's cursor is in comes back from jquery, then\n     * we know the selector applies.\n     *\n     * @param {!string} text CSS text to search\n     * @param {!string} selector selector to search for\n     * @param {!string} mode language mode of the document that text belongs to\n     * @return {Array.<{selectorGroupStartLine:number, declListEndLine:number, selector:string}>}\n     *      Array of objects containing the start and end line numbers (0-based, inclusive range) for each\n     *      matched selector.\n     */\n    function _findAllMatchingSelectorsInText(text, selector, mode) {\n        var allSelectors = extractAllSelectors(text, mode);\n        var result = [];\n\n        // For now, we only match the rightmost simple selector, and ignore\n        // attribute selectors and pseudo selectors\n        var classOrIdSelector = selector[0] === \".\" || selector[0] === \"#\";\n\n        // Escape initial \".\" in selector, if present.\n        if (selector[0] === \".\") {\n            selector = \"\\\\\" + selector;\n        }\n\n        if (!classOrIdSelector) {\n            // Tag selectors must have nothing, whitespace, or a combinator before it.\n            selector = \"(^|[\\\\s>+~])\" + selector;\n        }\n\n        var re = new RegExp(selector + \"(\\\\[[^\\\\]]*\\\\]|:{1,2}[\\\\w-()]+|\\\\.[\\\\w-]+|#[\\\\w-]+)*\\\\s*$\", classOrIdSelector ? \"\" : \"i\");\n        allSelectors.forEach(function (entry) {\n            var actualSelector = entry.selector;\n            if (entry.selector.indexOf(\"&\") !== -1 && entry.parentSelectors) {\n                var selectorArray = entry.parentSelectors.split(\" / \");\n                selectorArray.push(entry.selector);\n                actualSelector = _getSelectorInFinalCSSForm(selectorArray);\n            }\n            if (actualSelector.search(re) !== -1) {\n                result.push(entry);\n            } else if (!classOrIdSelector) {\n                // Special case for tag selectors - match \"*\" as the rightmost character\n                if (/\\*\\s*$/.test(actualSelector)) {\n                    result.push(entry);\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Converts the results of _findAllMatchingSelectorsInText() into a simpler bag of data and\n     * appends those new objects to the given 'resultSelectors' Array.\n     * @param {Array.<{document:Document, lineStart:number, lineEnd:number}>} resultSelectors\n     * @param {Array.<SelectorInfo>} selectorsToAdd\n     * @param {!Document} sourceDoc\n     * @param {!number} lineOffset Amount to offset all line number info by. Used if the first line\n     *          of the parsed CSS text is not the first line of the sourceDoc.\n     */\n    function _addSelectorsToResults(resultSelectors, selectorsToAdd, sourceDoc, lineOffset) {\n        selectorsToAdd.forEach(function (selectorInfo) {\n            resultSelectors.push({\n                name: getCompleteSelectors(selectorInfo),\n                document: sourceDoc,\n                lineStart: selectorInfo.ruleStartLine + lineOffset,\n                lineEnd: selectorInfo.declListEndLine + lineOffset,\n                selectorGroup: selectorInfo.selectorGroup\n            });\n        });\n    }\n\n    /** Finds matching selectors in CSS files; adds them to 'resultSelectors' */\n    function _findMatchingRulesInCSSFiles(selector, resultSelectors) {\n        var result          = new $.Deferred();\n\n        // Load one CSS file and search its contents\n        function _loadFileAndScan(fullPath, selector) {\n            var oneFileResult = new $.Deferred();\n\n            DocumentManager.getDocumentForPath(fullPath)\n                .done(function (doc) {\n                    // Find all matching rules for the given CSS file's content, and add them to the\n                    // overall search result\n                    var oneCSSFileMatches = _findAllMatchingSelectorsInText(doc.getText(), selector, doc.getLanguage().getMode());\n                    _addSelectorsToResults(resultSelectors, oneCSSFileMatches, doc, 0);\n\n                    oneFileResult.resolve();\n                })\n                .fail(function (error) {\n                    console.warn(\"Unable to read \" + fullPath + \" during CSS rule search:\", error);\n                    oneFileResult.resolve();  // still resolve, so the overall result doesn't reject\n                });\n\n            return oneFileResult.promise();\n        }\n\n        ProjectManager.getAllFiles(ProjectManager.getLanguageFilter([\"css\", \"less\", \"scss\"]))\n            .done(function (cssFiles) {\n                // Load index of all CSS files; then process each CSS file in turn (see above)\n                Async.doInParallel(cssFiles, function (fileInfo, number) {\n                    return _loadFileAndScan(fileInfo.fullPath, selector);\n                })\n                    .then(result.resolve, result.reject);\n            });\n\n        return result.promise();\n    }\n\n    /** Finds matching selectors in the <style> block of a single HTML file; adds them to 'resultSelectors' */\n    function _findMatchingRulesInStyleBlocks(htmlDocument, selector, resultSelectors) {\n        // HTMLUtils requires a real CodeMirror instance; make sure we can give it the right Editor\n        var htmlEditor = EditorManager.getCurrentFullEditor();\n        if (htmlEditor.document !== htmlDocument) {\n            console.error(\"Cannot search for <style> blocks in HTML file other than current editor\");\n            return;\n        }\n\n        // Find all <style> blocks in the HTML file\n        var styleBlocks = HTMLUtils.findStyleBlocks(htmlEditor);\n\n        styleBlocks.forEach(function (styleBlockInfo) {\n            // Search this one <style> block's content, appending results to 'resultSelectors'\n            var oneStyleBlockMatches = _findAllMatchingSelectorsInText(styleBlockInfo.text, selector);\n            _addSelectorsToResults(resultSelectors, oneStyleBlockMatches, htmlDocument, styleBlockInfo.start.line);\n        });\n    }\n\n    /**\n     * Return all rules matching the specified selector.\n     * For now, we only look at the rightmost simple selector. For example, searching for \".foo\" will\n     * match these rules:\n     *  .foo {}\n     *  div .foo {}\n     *  div.foo {}\n     *  div .foo[bar=\"42\"] {}\n     *  div .foo:hovered {}\n     *  div .foo::first-child\n     * but will *not* match these rules:\n     *  .foobar {}\n     *  .foo .bar {}\n     *  div .foo .bar {}\n     *  .foo.bar {}\n     *\n     * @param {!string} selector The selector to match. This can be a tag selector, class selector or id selector\n     * @param {?Document} htmlDocument An HTML file for context (so we can search <style> blocks)\n     * @return {$.Promise} that will be resolved with an Array of objects containing the\n     *      source document, start line, and end line (0-based, inclusive range) for each matching declaration list.\n     *      Does not addRef() the documents returned in the array.\n     */\n    function findMatchingRules(selector, htmlDocument) {\n        var result          = new $.Deferred(),\n            resultSelectors = [];\n\n        // Synchronously search for matches in <style> blocks\n        if (htmlDocument) {\n            _findMatchingRulesInStyleBlocks(htmlDocument, selector, resultSelectors);\n        }\n\n        // Asynchronously search for matches in all the project's CSS files\n        // (results are appended together in same 'resultSelectors' array)\n        _findMatchingRulesInCSSFiles(selector, resultSelectors)\n            .done(function () {\n                result.resolve(resultSelectors);\n            })\n            .fail(function (error) {\n                result.reject(error);\n            });\n\n        return result.promise();\n    }\n\n    /**\n     * Returns the selector(s) of the rule at the specified document pos, or \"\" if the position is\n     * is not within a style rule.\n     *\n     * @param {!Editor} editor Editor to search\n     * @param {!{line: number, ch: number}} pos Position to search\n     * @return {string} Selector(s) for the rule at the specified position, or \"\" if the position\n     *          is not within a style rule. If the rule has multiple selectors, a comma-separated\n     *          selector string is returned.\n     */\n    function findSelectorAtDocumentPos(editor, pos) {\n        var cm = editor._codeMirror;\n        var ctx = TokenUtils.getInitialContext(cm, $.extend({}, pos));\n        var selector = \"\", foundChars = false;\n        var isPreprocessorDoc = isCSSPreprocessorFile(editor.document.file.fullPath);\n        var selectorArray = [];\n\n        function _skipToOpeningBracket(ctx, startChar) {\n            var unmatchedBraces = 0;\n            if (!startChar) {\n                startChar = \"}\";\n            }\n            while (true) {\n                if (startChar === ctx.token.string) {\n                    unmatchedBraces++;\n                } else if (ctx.token.string.match(_invertedBracketPairs[startChar])) {\n                    unmatchedBraces--;\n                    if (unmatchedBraces <= 0) {\n                        return;\n                    }\n                }\n\n                if (!TokenUtils.movePrevToken(ctx)) {\n                    return;\n                }\n            }\n        }\n\n        // Parse a selector. Assumes ctx is pointing at the opening\n        // { that is after the selector name.\n        function _parseSelector(ctx) {\n            var selector = \"\";\n\n            // Skip over {\n            TokenUtils.movePrevToken(ctx);\n\n            while (true) {\n                if (ctx.token.type !== \"comment\") {\n                    // Stop once we've reached a {, }, or ;\n                    if (/[\\{\\}\\;]/.test(ctx.token.string)) {\n                        break;\n                    }\n\n                    // Stop once we've reached a <style ...> tag\n                    if (ctx.token.string === \"style\" && ctx.token.type === \"tag\") {\n                        // Remove everything up to end-of-tag from selector\n                        var eotIndex = selector.indexOf(\">\");\n                        if (eotIndex !== -1) {\n                            selector = selector.substring(eotIndex + 1);\n                        }\n                        break;\n                    }\n\n                    selector = ctx.token.string + selector;\n                }\n                if (!TokenUtils.movePrevToken(ctx)) {\n                    break;\n                }\n            }\n\n            return selector;\n        }\n\n        var skipPrevSibling = false,\n            state           = _getContextState(ctx);\n\n        // If the cursor is inside a non-whitespace token with \"block\" or \"top\" state, then it is inside a\n        // selector. The only exception is when it is immediately after the '{'.\n        if (isPreprocessorDoc && _hasNonWhitespace(ctx.token.string) && ctx.token.string !== \"{\" &&\n                (state.state === \"block\" || state.state === \"top\")) {\n            foundChars = true;\n        }\n\n        // scan backwards to see if the cursor is in a rule\n        do {\n            if (ctx.token.type !== \"comment\") {\n                if (ctx.token.string === \"}\") {\n                    if (isPreprocessorDoc) {\n                        if (state.state === \"top\") {\n                            break;\n                        }\n                        skipPrevSibling = true;\n                        // Skip past the entire preceding block until the matching \"{\"\n                        _skipToOpeningBracket(ctx, \"}\");\n                    } else {\n                        break;\n                    }\n                } else if (ctx.token.string === \"{\") {\n                    selector = _parseSelector(ctx);\n                    if (isPreprocessorDoc) {\n                        if (!skipPrevSibling && !/^\\s*@/.test(selector)) {\n                            selectorArray.unshift(selector);\n                        }\n                        if (skipPrevSibling) {\n                            skipPrevSibling = false;\n                        }\n                    } else {\n                        break;\n                    }\n                } else {\n                    if (!isPreprocessorDoc && _hasNonWhitespace(ctx.token.string)) {\n                        foundChars = true;\n                    }\n                    TokenUtils.movePrevToken(ctx);\n                }\n            } else {\n                TokenUtils.movePrevToken(ctx);\n            }\n        } while (!TokenUtils.isAtStart(ctx));\n\n        selector = _stripAtRules(selector);\n\n        // Reset the context to original scan position\n        ctx = TokenUtils.getInitialContext(cm, $.extend({}, pos));\n\n        // special case - we aren't in a selector and haven't found any chars,\n        // look at the next immediate token to see if it is non-whitespace.\n        // For preprocessor documents we need to move the cursor to next non-whitespace\n        // token so that we can collect the current selector if the cursor is inside it.\n        if ((!selector && !foundChars && !isPreprocessorDoc) ||\n                (isPreprocessorDoc && (ctx.token.string === \"\" || /\\s+/.test(ctx.token.string)))) {\n            if (TokenUtils.moveNextToken(ctx) && ctx.token.type !== \"comment\" && _hasNonWhitespace(ctx.token.string)) {\n                foundChars = true;\n                ctx = TokenUtils.getInitialContext(cm, $.extend({}, pos));\n            }\n        }\n\n        // At this point if we haven't found a selector, but have seen chars when\n        // scanning, assume we are in the middle of a selector. For a preprocessor\n        // document we also need to collect the current selector if the cursor is\n        // within the selector or whitespaces immediately before or after it.\n        if ((!selector || isPreprocessorDoc) && foundChars) {\n            // scan forward to see if the cursor is in a selector\n            while (true) {\n                if (ctx.token.type !== \"comment\") {\n                    if (ctx.token.string === \"{\") {\n                        selector = _parseSelector(ctx);\n                        if (isPreprocessorDoc && !/^\\s*@/.test(selector)) {\n                            selectorArray.push(selector);\n                        }\n                        break;\n                    } else if (ctx.token.string === \"}\" || ctx.token.string === \";\") {\n                        break;\n                    }\n                }\n                if (!TokenUtils.moveNextToken(ctx)) {\n                    break;\n                }\n            }\n        }\n\n        if (isPreprocessorDoc) {\n            return _getSelectorInFinalCSSForm(selectorArray);\n        }\n\n        return _stripAtRules(selector);\n    }\n\n    /**\n     * removes CSS comments from the content\n     * @param {!string} content to reduce\n     * @return {string} reduced content\n     */\n    function _removeComments(content) {\n        return content.replace(/\\/\\*(?:(?!\\*\\/)[\\s\\S])*\\*\\//g, \"\");\n    }\n\n    /**\n     * removes strings from the content\n     * @param {!string} content to reduce\n     * @return {string} reduced content\n     */\n    function _removeStrings(content) {\n        // First remove escaped quotes so we can balance unescaped quotes\n        // since JavaScript doesn't support negative lookbehind\n        var s = content.replace(/\\\\\\\"|\\\\\\'/g, \"\");\n\n        // Now remove strings\n        return s.replace(/\\\"(.*?)\\\"|\\'(.*?)\\'/g, \"\");\n    }\n\n    /**\n     * Reduces the style sheet by removing comments and strings\n     * so that the content can be parsed using a regular expression\n     * @param {!string} content to reduce\n     * @return {string} reduced content\n     */\n    function reduceStyleSheetForRegExParsing(content) {\n        return _removeStrings(_removeComments(content));\n    }\n\n    /**\n     * Adds a new rule to the end of the given document, and returns the range of the added rule\n     * and the position of the cursor on the indented blank line within it. Note that the range will\n     * not include all the inserted text (we insert extra newlines before and after the rule).\n     * @param {Document} doc The document to insert the rule into.\n     * @param {string} selector The selector to use for the given rule.\n     * @param {boolean} useTabChar Whether to indent with a tab.\n     * @param {number} indentUnit If useTabChar is false, how many spaces to indent with.\n     * @return {{range: {from: {line: number, ch: number}, to: {line: number, ch: number}}, pos: {line: number, ch: number}}}\n     *     The range of the inserted rule and the location where the cursor should be placed.\n     */\n    function addRuleToDocument(doc, selector, useTabChar, indentUnit) {\n        var newRule = \"\\n\" + selector + \" {\\n\",\n            blankLineOffset;\n        if (useTabChar) {\n            newRule += \"\\t\";\n            blankLineOffset = 1;\n        } else {\n            var i;\n            for (i = 0; i < indentUnit; i++) {\n                newRule += \" \";\n            }\n            blankLineOffset = indentUnit;\n        }\n        newRule += \"\\n}\\n\";\n\n        var docLines = doc.getText().split(\"\\n\"),\n            lastDocLine = docLines.length - 1,\n            lastDocChar = docLines[docLines.length - 1].length;\n        doc.replaceRange(newRule, {line: lastDocLine, ch: lastDocChar});\n        return {\n            range: {\n                from: {line: lastDocLine + 1, ch: 0},\n                to: {line: lastDocLine + 3, ch: 1}\n            },\n            pos: {line: lastDocLine + 2, ch: blankLineOffset}\n        };\n    }\n\n    /**\n     *\n     * In the given rule array (as returned by `findMatchingRules()`), if multiple rules in a row\n     * refer to the same rule (because there were multiple matching selectors), eliminate the redundant\n     * rules. Also, always use the selector group if available instead of the original matching selector.\n     */\n    function consolidateRules(rules) {\n        var newRules = [], lastRule;\n        rules.forEach(function (rule) {\n            if (rule.selectorGroup) {\n                rule.name = rule.selectorGroup;\n            }\n            // Push the entry unless it refers to the same rule as the previous entry.\n            if (!(lastRule &&\n                     rule.document === lastRule.document &&\n                     rule.lineStart === lastRule.lineStart &&\n                     rule.lineEnd === lastRule.lineEnd &&\n                     rule.selectorGroup === lastRule.selectorGroup)) {\n                newRules.push(rule);\n            }\n            lastRule = rule;\n        });\n        return newRules;\n    }\n\n    /**\n     * Given a TextRange, extracts the selector(s) for the rule in the range and returns it.\n     * Assumes the range only contains one rule; if there's more than one, it will return the\n     * selector(s) for the first rule.\n     * @param {TextRange} range The range to extract the selector(s) from.\n     * @return {string} The selector(s) for the rule in the range.\n     */\n    function getRangeSelectors(range) {\n        // There's currently no immediate way to access a given line in a Document, because it's just\n        // stored as a string. Eventually, we should have Documents cache the lines in the document\n        // as well, or make them use CodeMirror documents which do the same thing.\n        var i, startIndex = 0, endIndex, text = range.document.getText();\n        for (i = 0; i < range.startLine; i++) {\n            startIndex = text.indexOf(\"\\n\", startIndex) + 1;\n        }\n        endIndex = startIndex;\n        // Go one line past the end line. We'll extract text up to but not including the last newline.\n        for (i = range.startLine + 1; i <= range.endLine + 1; i++) {\n            endIndex = text.indexOf(\"\\n\", endIndex) + 1;\n        }\n        var allSelectors = extractAllSelectors(text.substring(startIndex, endIndex));\n\n        // There should only be one rule in the range, and if there are multiple selectors for\n        // the first rule, they'll all be recorded in the \"selectorGroup\" for the first selector,\n        // so we only need to look at the first one.\n        return (allSelectors.length ? allSelectors[0].selectorGroup || allSelectors[0].selector : \"\");\n    }\n\n    function _extractSelectorSet(selectorList) {\n        const regex = /[{}!]/;\n        const selectors = new Set();\n        if(!selectorList){\n            return selectors;\n        }\n        for(let item of selectorList) {\n            if(regex.test(item) || !item.trim()){\n                // this happens for scss selectors like #${var}-something. we ignore that for now instead of resolving\n                continue;\n            }\n            const extracted = extractSelectorBase(item);\n            extracted.trim() && selectors.add(extracted); // x:hover or x::some -> x\n        }\n        return selectors;\n    }\n\n    const CSSSelectorCache = new Phoenix.libs.LRUCache({\n        maxSize: 100*1024*1024, // 100MB\n        sizeCalculation: (value) => {\n            return value.length;\n        }\n    });\n\n    function _projectFileChanged(_evt, entry) {\n        if(!entry){\n            return;\n        }\n        let changedPath = entry.fullPath;\n        if(entry.isFile) {\n            CSSSelectorCache.delete(changedPath);\n        } else if(entry.isDirectory) {\n            changedPath = Phoenix.VFS.ensureTrailingSlash(changedPath);\n            const cachedFilePaths = Array.from(CSSSelectorCache.keys());\n            for(let filePath of cachedFilePaths) {\n                if(filePath.startsWith(changedPath)){\n                    CSSSelectorCache.delete(filePath);\n                }\n            }\n        }\n    }\n\n    const CSS_MODE_MAP = {\n        css: \"CSS\",\n        less: \"LESS\",\n        scss: \"SCSS\"\n    };\n\n    function _loadFileAndScanCSSSelectorCached(fullPath) {\n        return new Promise(resolve=>{\n            DocumentManager.getDocumentForPath(fullPath)\n                .done(function (doc) {\n                    // Find all matching rules for the given CSS file's content, and add them to the\n                    // overall search result\n                    let selectors = new Set();\n                    const cachedSelectors = CSSSelectorCache.get(fullPath);\n                    if(cachedSelectors){\n                        resolve(new Set(JSON.parse(cachedSelectors)));\n                        return;\n                    }\n                    const langID = doc.getLanguage().getId();\n                    if(!CSS_MODE_MAP[langID]){\n                        console.log(\"Cannot parse CSS for mode :\", langID, \"ignoring\", fullPath);\n                        resolve(selectors);\n                        return;\n                    }\n                    console.log(\"scanning file for css selector collation: \", fullPath);\n                    IndexingWorker.execPeer(\"css_getAllSymbols\",\n                        {text: doc.getText(), cssMode: CSS_MODE_MAP[langID], filePath: fullPath})\n                        .then((selectorArray)=>{\n                            selectors = _extractSelectorSet(selectorArray);\n                            CSSSelectorCache.set(fullPath, JSON.stringify(Array.from(selectors)));\n                            resolve(selectors);\n                        }).catch(err=>{\n                            console.warn(\"CSS language service unable to get selectors for\" + fullPath, err);\n                            resolve(selectors);  // still resolve, so the overall result doesn't reject\n                        });\n                })\n                .fail(function (error) {\n                    console.warn(\"Unable to read \" + fullPath + \" during CSS selector search:\", error);\n                    resolve(new Set());  // still resolve, so the overall result doesn't reject\n                });\n        });\n    }\n\n    function extractSelectorBase(selector) {\n        // Use a regular expression to find the base part of the selector before any spaces, combinators,\n        // pseudo-classes, or attribute selectors\n        const match = selector.match(/^[^\\s>+~:\\[]+/);\n        // Return the match if found, otherwise return the original selector if no ':' or '::' is present\n        selector = match ? match[0] : selector;\n        if(selector.startsWith(\".\")) {\n            // Eg .class1.class2 type selector, we have to consider this too, so we always take the first segment only\n            selector = \".\" + selector.split(\".\")[1];\n        }\n        return selector;\n    }\n\n    const _htmlLikeFileExts = [\"htm\", \"html\", \"xhtml\", \"php\"];\n    function _isHtmlLike(editor) {\n        const fullPath = editor && editor.document.file.fullPath;\n        if (!editor || !LanguageManager.getLanguageForPath(fullPath)) {\n            return false;\n        }\n\n        return (_htmlLikeFileExts.indexOf(LanguageManager.getLanguageForPath(fullPath).getId() || \"\") !== -1);\n    }\n\n    const cacheInProgress = new Set();\n    // block fetches to only happen once every 10 seconds to prevent loading web servers on every code hint type\n    // Cached external links are never fetched again. problem happens when links fetch fails, and can be immediately\n    // retried on next key press. we need to block that and do it once in 10 seconds only.\n    const fetchBlock10Secs = new Phoenix.libs.LRUCache({\n        max: 5000,\n        ttl: 1000 * 10 // in ms\n    });\n    async function _precacheExternalStyleSheet(link) {\n        try {\n            // dont use fetchBlock10Secs.has as lru cache wont delete ttl expired items for performance.\n            // fetchBlock10Secs.get will return undefined for ttl expired items\n            // we purge this cache anyway on project switch/max entry reached.\n            if(cacheInProgress.has(link) || fetchBlock10Secs.get(link)){\n                return;\n            }\n            fetchBlock10Secs.set(link, true);\n            cacheInProgress.add(link);\n            const extension = path.extname(new URL(link).pathname).slice(1);\n            if (!extension || !CSS_MODE_MAP[extension]) {\n                console.log(`Not a valid stylesheet type ${extension}, ignoring`, link);\n                return;\n            }\n            const responseHead = await fetch(link, { method: 'HEAD' });\n            const contentLength = responseHead.headers.get('Content-Length');\n            if (!contentLength || contentLength > MAX_CONTENT_LENGTH) {\n                console.log(`Stylesheet is larger than ${MAX_CONTENT_LENGTH}bytes - ${contentLength}, ignoring`, link);\n                return;\n            }\n\n            const response = await fetch(link);\n            const styleSheetText = await response.text();\n            IndexingWorker.execPeer(\"css_getAllSymbols\",\n                {text: styleSheetText, cssMode: CSS_MODE_MAP[extension], filePath: link})\n                .then((selectorArray)=>{\n                    const selectorJson = JSON.stringify(Array.from(_extractSelectorSet(selectorArray)));\n                    CSSSelectorCache.set(link, selectorJson);\n                }).catch(err=>{\n                    console.warn(\"CSS language service unable to get selectors for link\" + link, err);\n                });\n        } catch (e) {\n            console.error(\"Error pre caching externally linked style sheet \", link);\n        }\n        cacheInProgress.delete(link);\n    }\n\n    const MAX_ALLOWED_EXTERNAL_STYLE_SHEETS = 30;\n\n    /**\n     * html files may have embedded link style sheets to external CDN urls. We will parse them to get all selectors.\n     * @param htmlFileContent\n     * @param fileMode\n     * @param fullPath\n     * @return {Promise<void>}\n     * @private\n     */\n    async function _getLinkedCSSFileSelectors(htmlFileContent, fileMode, fullPath) {\n        const linkedFiles = await catchToNull(IndexingWorker.execPeer(\n            \"html_getAllLinks\", {text: htmlFileContent, htmlMode: fileMode, filePath: fullPath}),\n            \"error extracting linked css files from\"+ fullPath) || [];\n        let selectors = new Set();\n        let externalStyleSheetCount = 0;\n        for(const link of linkedFiles) {\n            if(externalStyleSheetCount >= MAX_ALLOWED_EXTERNAL_STYLE_SHEETS){\n                break;\n            }\n            if(link.startsWith(\"http://\") || link.startsWith(\"https://\")) {\n                externalStyleSheetCount ++;\n                let cachedSelectorsArray = CSSSelectorCache.get(link);\n                if(cachedSelectorsArray){\n                    cachedSelectorsArray = JSON.parse(cachedSelectorsArray);\n                    for(let value of cachedSelectorsArray){\n                        selectors.add(value);\n                    }\n                } else {\n                    _precacheExternalStyleSheet(link);\n                }\n            }\n        }\n        return selectors;\n    }\n\n    async function _getAllSelectorsInCurrentHTMLEditor() {\n        let selectors = new Set();\n        const htmlEditor = EditorManager.getCurrentFullEditor();\n        if (!htmlEditor || !_isHtmlLike(htmlEditor) ) {\n            return selectors;\n        }\n\n        // Find all <style> blocks in the HTML file\n        const styleBlocks = HTMLUtils.findStyleBlocks(htmlEditor);\n        let cssText = \"\";\n\n        styleBlocks.forEach(function (styleBlockInfo) {\n            // Search this one <style> block's content\n            cssText += styleBlockInfo.text;\n        });\n        const fullPath = htmlEditor.document.file.fullPath;\n        const selectorsPromise = IndexingWorker.execPeer(\n            \"css_getAllSymbols\", {text: cssText, cssMode: \"CSS\", filePath: fullPath});\n        const htmlLanguageID = LanguageManager.getLanguageForPath(fullPath).getId();\n        const remoteLinkedSelectors = await _getLinkedCSSFileSelectors(htmlEditor.document.getText(),\n            htmlLanguageID.toUpperCase(), fullPath);\n        selectors = await catchToNull(selectorsPromise, \"CSS language service unable to get selectors for\" + fullPath);\n        selectors = selectors || new Set();\n        return new Set([...selectors, ...remoteLinkedSelectors]);\n    }\n\n    let globalPrecacheRun = 0;\n    function getAllCssSelectorsInProject(options = {\n        includeClasses: true,\n        includeIDs: true,\n        scanCurrentHtml: true\n    }) {\n        globalPrecacheRun ++; // we need to stop the pre cache logic from doing the same cache again\n        return new Promise(resolve=>{\n            ProjectManager.getAllFiles(ProjectManager.getLanguageFilter([\"css\", \"less\", \"scss\"]))\n                .done(function (cssFiles) {\n                    // Create an array of promises from the array of cssFiles\n                    const promises = cssFiles.map(fileInfo => _loadFileAndScanCSSSelectorCached(fileInfo.fullPath));\n                    if(options.scanCurrentHtml){\n                        promises.push(_getAllSelectorsInCurrentHTMLEditor());\n                    }\n                    const mergedSets = new Set();\n                    // Use Promise.allSettled to handle all promises\n                    Promise.allSettled(promises)\n                        .then(results => {\n                            results.forEach((result, index) => {\n                                if (result.status === 'fulfilled') {\n                                    result.value.forEach(value => {\n                                        if((options.includeClasses && value.startsWith(\".\")) ||\n                                            (options.includeIDs && value.startsWith(\"#\"))) {\n                                            mergedSets.add(value);\n                                        }\n                                    });\n                                } else {\n                                    console.error(`Error collect css selectors from file ${cssFiles[index].fullPath}:`,\n                                        result.reason);\n                                }\n                            });\n                            resolve(Array.from(mergedSets.keys()));\n                        });\n                });\n        });\n    }\n\n    async function _populateSelectorCache() {\n        globalPrecacheRun ++;\n        const currentCacheRun = globalPrecacheRun;\n        const cssFiles = await jsPromise(ProjectManager.getAllFiles(\n            ProjectManager.getLanguageFilter([\"css\", \"less\", \"scss\"])));\n        for(let cssFile of cssFiles){\n            if(currentCacheRun !== globalPrecacheRun) {\n                // this is for cases in very large projects where the project switches while a\n                // project wide css parse was in progress.\n                break;\n            }\n            await _loadFileAndScanCSSSelectorCached(cssFile.fullPath); // this is serial to not hog processor\n        }\n    }\n\n    AppInit.appReady(function () {\n        if(Phoenix.isSpecRunnerWindow){\n            // no unit tests event handlers\n            return;\n        }\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_FILE_CHANGED, _projectFileChanged);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_OPEN, ()=>{\n            CSSSelectorCache.clear();\n            fetchBlock10Secs.clear();\n            setTimeout(_populateSelectorCache, 2000);\n        });\n        setTimeout(_populateSelectorCache, 2000);\n        DocumentManager.on(DocumentManager.EVENT_DOCUMENT_CHANGE, function (event, doc, _changelist) {\n            CSSSelectorCache.delete(doc.file.fullPath);\n        });\n    });\n\n    exports._findAllMatchingSelectorsInText = _findAllMatchingSelectorsInText; // For testing only\n    exports.findMatchingRules = findMatchingRules;\n    exports.extractAllSelectors = extractAllSelectors;\n    exports.findSelectorAtDocumentPos = findSelectorAtDocumentPos;\n    exports.reduceStyleSheetForRegExParsing = reduceStyleSheetForRegExParsing;\n    exports.addRuleToDocument = addRuleToDocument;\n    exports.consolidateRules = consolidateRules;\n    exports.getRangeSelectors = getRangeSelectors;\n    exports.getCompleteSelectors = getCompleteSelectors;\n    exports.isCSSPreprocessorFile = isCSSPreprocessorFile;\n    exports.getAllCssSelectorsInProject = getAllCssSelectorsInProject;\n\n    exports.SELECTOR = SELECTOR;\n    exports.PROP_NAME = PROP_NAME;\n    exports.PROP_VALUE = PROP_VALUE;\n    exports.IMPORT_URL = IMPORT_URL;\n\n    exports.getInfoAtPos = getInfoAtPos;\n\n    // The createInfo is really only for the unit tests so they can make the same\n    // structure to compare results with.\n    exports.createInfo = createInfo;\n});\n"],"file":"CSSUtils.js"}